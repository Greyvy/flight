// Generated by Haxe 3.4.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_luxe_utils_Maths
#include <luxe/utils/Maths.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_7_new,"luxe.utils.Maths","new",0x8e0da6c8,"luxe.utils.Maths.new","luxe/utils/Maths.hx",7,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_9_fixed,"luxe.utils.Maths","fixed",0xd14c39dc,"luxe.utils.Maths.fixed","luxe/utils/Maths.hx",9,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_16_lerp,"luxe.utils.Maths","lerp",0xbc91d70f,"luxe.utils.Maths.lerp","luxe/utils/Maths.hx",16,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_24_weighted_avg,"luxe.utils.Maths","weighted_avg",0x406fb2c2,"luxe.utils.Maths.weighted_avg","luxe/utils/Maths.hx",24,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_34_clamp,"luxe.utils.Maths","clamp",0x1902b363,"luxe.utils.Maths.clamp","luxe/utils/Maths.hx",34,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_38_clampi,"luxe.utils.Maths","clampi",0xc95a43a6,"luxe.utils.Maths.clampi","luxe/utils/Maths.hx",38,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_42_clamp_bottom,"luxe.utils.Maths","clamp_bottom",0x237bc787,"luxe.utils.Maths.clamp_bottom","luxe/utils/Maths.hx",42,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_46_within_range,"luxe.utils.Maths","within_range",0x4493cb41,"luxe.utils.Maths.within_range","luxe/utils/Maths.hx",46,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_49_wrap_angle,"luxe.utils.Maths","wrap_angle",0x41b47ef6,"luxe.utils.Maths.wrap_angle","luxe/utils/Maths.hx",49,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_59_nearest_power_of_two,"luxe.utils.Maths","nearest_power_of_two",0xd8e2f7b7,"luxe.utils.Maths.nearest_power_of_two","luxe/utils/Maths.hx",59,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_74_map_linear,"luxe.utils.Maths","map_linear",0x21a26b00,"luxe.utils.Maths.map_linear","luxe/utils/Maths.hx",74,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_77_smoothstep,"luxe.utils.Maths","smoothstep",0x89a4e512,"luxe.utils.Maths.smoothstep","luxe/utils/Maths.hx",77,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_93_smootherstep,"luxe.utils.Maths","smootherstep",0x31edf57f,"luxe.utils.Maths.smootherstep","luxe/utils/Maths.hx",93,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_111_sign,"luxe.utils.Maths","sign",0xc13554d5,"luxe.utils.Maths.sign","luxe/utils/Maths.hx",111,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_116_sign0,"luxe.utils.Maths","sign0",0x4d74e5bb,"luxe.utils.Maths.sign0","luxe/utils/Maths.hx",116,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_121_radians,"luxe.utils.Maths","radians",0x26f970da,"luxe.utils.Maths.radians","luxe/utils/Maths.hx",121,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_126_degrees,"luxe.utils.Maths","degrees",0x3a640e0f,"luxe.utils.Maths.degrees","luxe/utils/Maths.hx",126,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_131_vec_lengthsq,"luxe.utils.Maths","vec_lengthsq",0xbbbec627,"luxe.utils.Maths.vec_lengthsq","luxe/utils/Maths.hx",131,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_136_vec_length,"luxe.utils.Maths","vec_length",0xfaddbd49,"luxe.utils.Maths.vec_length","luxe/utils/Maths.hx",136,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_140_vec_normalize,"luxe.utils.Maths","vec_normalize",0x8b842f0a,"luxe.utils.Maths.vec_normalize","luxe/utils/Maths.hx",140,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_147_vec_dot,"luxe.utils.Maths","vec_dot",0xccbc4e46,"luxe.utils.Maths.vec_dot","luxe/utils/Maths.hx",147,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_153_boot,"luxe.utils.Maths","boot",0xb5fd48ca,"luxe.utils.Maths.boot","luxe/utils/Maths.hx",153,0x6644526a)
HX_LOCAL_STACK_FRAME(_hx_pos_0e989ffa3e3a881e_155_boot,"luxe.utils.Maths","boot",0xb5fd48ca,"luxe.utils.Maths.boot","luxe/utils/Maths.hx",155,0x6644526a)
namespace luxe{
namespace utils{

void Maths_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_7_new)
            	}

Dynamic Maths_obj::__CreateEmpty() { return new Maths_obj; }

void *Maths_obj::_hx_vtable = 0;

Dynamic Maths_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Maths_obj > _hx_result = new Maths_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Maths_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x7c0c2528;
}

Float Maths_obj::fixed(Float value,int precision){
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_9_fixed)
HXLINE(  11)		Float n = ::Math_obj::pow((int)10,precision);
HXLINE(  12)		return ((Float)::Std_obj::_hx_int((value * n)) / (Float)n);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Maths_obj,fixed,return )

Float Maths_obj::lerp(Float value,Float target,Float t){
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_16_lerp)
HXLINE(  18)		if ((t < (int)0)) {
HXLINE(  18)			t = (int)0;
            		}
            		else {
HXLINE(  18)			if ((t > (int)1)) {
HXLINE(  18)				t = (int)1;
            			}
            			else {
HXLINE(  18)				t = t;
            			}
            		}
HXLINE(  20)		return (value + (t * (target - value)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Maths_obj,lerp,return )

Float Maths_obj::weighted_avg(Float value,Float target,Float slowness){
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_24_weighted_avg)
HXLINE(  27)		if ((slowness == (int)0)) {
HXLINE(  27)			slowness = ((Float)0.00000001);
            		}
HXLINE(  29)		return ((Float)((value * (slowness - (int)1)) + target) / (Float)slowness);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Maths_obj,weighted_avg,return )

Float Maths_obj::clamp(Float value,Float a,Float b){
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_34_clamp)
HXDLIN(  34)		if ((value < a)) {
HXDLIN(  34)			return a;
            		}
            		else {
HXDLIN(  34)			if ((value > b)) {
HXDLIN(  34)				return b;
            			}
            			else {
HXDLIN(  34)				return value;
            			}
            		}
HXDLIN(  34)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Maths_obj,clamp,return )

int Maths_obj::clampi(int value,int a,int b){
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_38_clampi)
HXDLIN(  38)		if ((value < a)) {
HXDLIN(  38)			return a;
            		}
            		else {
HXDLIN(  38)			if ((value > b)) {
HXDLIN(  38)				return b;
            			}
            			else {
HXDLIN(  38)				return value;
            			}
            		}
HXDLIN(  38)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Maths_obj,clampi,return )

Float Maths_obj::clamp_bottom(Float value,Float a){
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_42_clamp_bottom)
HXDLIN(  42)		if ((value < a)) {
HXDLIN(  42)			return a;
            		}
            		else {
HXDLIN(  42)			return value;
            		}
HXDLIN(  42)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Maths_obj,clamp_bottom,return )

bool Maths_obj::within_range(Float value,Float start_range,Float end_range){
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_46_within_range)
HXDLIN(  46)		if ((value >= start_range)) {
HXDLIN(  46)			return (value <= end_range);
            		}
            		else {
HXDLIN(  46)			return false;
            		}
HXDLIN(  46)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Maths_obj,within_range,return )

Float Maths_obj::wrap_angle(Float degrees,Float lower,Float upper){
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_49_wrap_angle)
HXLINE(  51)		Float _radians = (degrees * ((Float)0.0174532925199432781));
HXLINE(  52)		Float _distance = (upper - lower);
HXLINE(  53)		Float _times = ::Math_obj::floor(((Float)(degrees - lower) / (Float)_distance));
HXLINE(  55)		return (degrees - (_times * _distance));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Maths_obj,wrap_angle,return )

int Maths_obj::nearest_power_of_two(int _value){
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_59_nearest_power_of_two)
HXLINE(  61)		_value = (_value - (int)1);
HXLINE(  62)		_value = ((int)_value | (int)((int)_value >> (int)(int)1));
HXLINE(  63)		_value = ((int)_value | (int)((int)_value >> (int)(int)2));
HXLINE(  64)		_value = ((int)_value | (int)((int)_value >> (int)(int)4));
HXLINE(  65)		_value = ((int)_value | (int)((int)_value >> (int)(int)8));
HXLINE(  66)		_value = ((int)_value | (int)((int)_value >> (int)(int)16));
HXLINE(  67)		_value = (_value + (int)1);
HXLINE(  69)		return _value;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Maths_obj,nearest_power_of_two,return )

Float Maths_obj::map_linear(Float value,Float a1,Float a2,Float b1,Float b2){
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_74_map_linear)
HXDLIN(  74)		return (b1 + ((Float)((value - a1) * (b2 - b1)) / (Float)(a2 - a1)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(Maths_obj,map_linear,return )

Float Maths_obj::smoothstep(Float x,Float min,Float max){
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_77_smoothstep)
HXLINE(  79)		if ((x <= min)) {
HXLINE(  80)			return (int)0;
            		}
HXLINE(  83)		if ((x >= max)) {
HXLINE(  84)			return (int)1;
            		}
HXLINE(  87)		x = ((Float)(x - min) / (Float)(max - min));
HXLINE(  89)		return ((x * x) * ((int)3 - ((int)2 * x)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Maths_obj,smoothstep,return )

Float Maths_obj::smootherstep(Float x,Float min,Float max){
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_93_smootherstep)
HXLINE(  95)		if ((x <= min)) {
HXLINE(  96)			return (int)0;
            		}
HXLINE(  99)		if ((x >= max)) {
HXLINE( 100)			return (int)1;
            		}
HXLINE( 103)		x = ((Float)(x - min) / (Float)(max - min));
HXLINE( 105)		return (((x * x) * x) * ((x * ((x * (int)6) - (int)15)) + (int)10));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Maths_obj,smootherstep,return )

int Maths_obj::sign(Float x){
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_111_sign)
HXDLIN( 111)		if ((x >= (int)0)) {
HXDLIN( 111)			return (int)1;
            		}
            		else {
HXDLIN( 111)			return (int)-1;
            		}
HXDLIN( 111)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Maths_obj,sign,return )

int Maths_obj::sign0(Float x){
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_116_sign0)
HXDLIN( 116)		if ((x < (int)0)) {
HXDLIN( 116)			return (int)-1;
            		}
            		else {
HXDLIN( 116)			if ((x > (int)0)) {
HXDLIN( 116)				return (int)1;
            			}
            			else {
HXDLIN( 116)				return (int)0;
            			}
            		}
HXDLIN( 116)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Maths_obj,sign0,return )

Float Maths_obj::radians(Float degrees){
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_121_radians)
HXDLIN( 121)		return (degrees * ((Float)0.0174532925199432781));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Maths_obj,radians,return )

Float Maths_obj::degrees(Float radians){
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_126_degrees)
HXDLIN( 126)		return (radians * ((Float)57.2957795130823797));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Maths_obj,degrees,return )

Float Maths_obj::vec_lengthsq(Float x,Float y){
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_131_vec_lengthsq)
HXDLIN( 131)		return ((x * x) + (y * y));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Maths_obj,vec_lengthsq,return )

Float Maths_obj::vec_length(Float x,Float y){
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_136_vec_length)
HXDLIN( 136)		return ::Math_obj::sqrt(((x * x) + (y * y)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Maths_obj,vec_length,return )

Float Maths_obj::vec_normalize(Float length,Float component){
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_140_vec_normalize)
HXLINE( 141)		if ((length == (int)0)) {
HXLINE( 141)			return (int)0;
            		}
HXLINE( 142)		component = ((Float)component / (Float)length);
HXDLIN( 142)		return component;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Maths_obj,vec_normalize,return )

Float Maths_obj::vec_dot(Float x,Float y,Float otherx,Float othery){
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_147_vec_dot)
HXDLIN( 147)		return ((x * otherx) + (y * othery));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Maths_obj,vec_dot,return )

Float Maths_obj::_PI_OVER_180;

Float Maths_obj::_180_OVER_PI;


Maths_obj::Maths_obj()
{
}

bool Maths_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"lerp") ) { outValue = lerp_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"sign") ) { outValue = sign_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"fixed") ) { outValue = fixed_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"clamp") ) { outValue = clamp_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"sign0") ) { outValue = sign0_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"clampi") ) { outValue = clampi_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"radians") ) { outValue = radians_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"degrees") ) { outValue = degrees_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"vec_dot") ) { outValue = vec_dot_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"wrap_angle") ) { outValue = wrap_angle_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"map_linear") ) { outValue = map_linear_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"smoothstep") ) { outValue = smoothstep_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"vec_length") ) { outValue = vec_length_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"weighted_avg") ) { outValue = weighted_avg_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"clamp_bottom") ) { outValue = clamp_bottom_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"within_range") ) { outValue = within_range_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"smootherstep") ) { outValue = smootherstep_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"vec_lengthsq") ) { outValue = vec_lengthsq_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"vec_normalize") ) { outValue = vec_normalize_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"nearest_power_of_two") ) { outValue = nearest_power_of_two_dyn(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *Maths_obj_sMemberStorageInfo = 0;
static hx::StaticInfo Maths_obj_sStaticStorageInfo[] = {
	{hx::fsFloat,(void *) &Maths_obj::_PI_OVER_180,HX_HCSTRING("_PI_OVER_180","\x05","\x90","\x90","\x73")},
	{hx::fsFloat,(void *) &Maths_obj::_180_OVER_PI,HX_HCSTRING("_180_OVER_PI","\x2f","\x07","\xd5","\x10")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void Maths_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Maths_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Maths_obj::_PI_OVER_180,"_PI_OVER_180");
	HX_MARK_MEMBER_NAME(Maths_obj::_180_OVER_PI,"_180_OVER_PI");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Maths_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Maths_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Maths_obj::_PI_OVER_180,"_PI_OVER_180");
	HX_VISIT_MEMBER_NAME(Maths_obj::_180_OVER_PI,"_180_OVER_PI");
};

#endif

hx::Class Maths_obj::__mClass;

static ::String Maths_obj_sStaticFields[] = {
	HX_HCSTRING("fixed","\x74","\xf9","\xa1","\x00"),
	HX_HCSTRING("lerp","\x77","\x12","\xb0","\x47"),
	HX_HCSTRING("weighted_avg","\x2a","\x96","\xd3","\x6e"),
	HX_HCSTRING("clamp","\xfb","\x72","\x58","\x48"),
	HX_HCSTRING("clampi","\x0e","\x29","\x0c","\x05"),
	HX_HCSTRING("clamp_bottom","\xef","\xaa","\xdf","\x51"),
	HX_HCSTRING("within_range","\xa9","\xae","\xf7","\x72"),
	HX_HCSTRING("wrap_angle","\x5e","\x38","\x69","\x4e"),
	HX_HCSTRING("nearest_power_of_two","\x1f","\x83","\x74","\x64"),
	HX_HCSTRING("map_linear","\x68","\x24","\x57","\x2e"),
	HX_HCSTRING("smoothstep","\x7a","\x9e","\x59","\x96"),
	HX_HCSTRING("smootherstep","\xe7","\xd8","\x51","\x60"),
	HX_HCSTRING("sign","\x3d","\x90","\x53","\x4c"),
	HX_HCSTRING("sign0","\x53","\xa5","\xca","\x7c"),
	HX_HCSTRING("radians","\x72","\x46","\xf0","\x26"),
	HX_HCSTRING("degrees","\xa7","\xe3","\x5a","\x3a"),
	HX_HCSTRING("vec_lengthsq","\x8f","\xa9","\x22","\xea"),
	HX_HCSTRING("vec_length","\xb1","\x76","\x92","\x07"),
	HX_HCSTRING("vec_normalize","\xa2","\x46","\x87","\xf4"),
	HX_HCSTRING("vec_dot","\xde","\x23","\xb3","\xcc"),
	HX_HCSTRING("_PI_OVER_180","\x05","\x90","\x90","\x73"),
	HX_HCSTRING("_180_OVER_PI","\x2f","\x07","\xd5","\x10"),
	::String(null())
};

void Maths_obj::__register()
{
	hx::Object *dummy = new Maths_obj;
	Maths_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("luxe.utils.Maths","\xd6","\xe2","\x78","\x0c");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Maths_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Maths_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Maths_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< Maths_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Maths_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Maths_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Maths_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Maths_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_153_boot)
HXDLIN( 153)		_PI_OVER_180 = ((Float)0.0174532925199432781);
            	}
{
            	HX_STACKFRAME(&_hx_pos_0e989ffa3e3a881e_155_boot)
HXDLIN( 155)		_180_OVER_PI = ((Float)57.2957795130823797);
            	}
}

} // end namespace luxe
} // end namespace utils
