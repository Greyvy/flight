// Generated by Haxe 3.4.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Type
#include <Type.h>
#endif
#ifndef INCLUDED_luxe_collision_data_RayCollision
#include <luxe/collision/data/RayCollision.h>
#endif
#ifndef INCLUDED_luxe_collision_data_RayIntersection
#include <luxe/collision/data/RayIntersection.h>
#endif
#ifndef INCLUDED_luxe_collision_data_ShapeCollision
#include <luxe/collision/data/ShapeCollision.h>
#endif
#ifndef INCLUDED_luxe_collision_sat_SAT2D
#include <luxe/collision/sat/SAT2D.h>
#endif
#ifndef INCLUDED_luxe_collision_shapes_Circle
#include <luxe/collision/shapes/Circle.h>
#endif
#ifndef INCLUDED_luxe_collision_shapes_InfiniteState
#include <luxe/collision/shapes/InfiniteState.h>
#endif
#ifndef INCLUDED_luxe_collision_shapes_Polygon
#include <luxe/collision/shapes/Polygon.h>
#endif
#ifndef INCLUDED_luxe_collision_shapes_Ray
#include <luxe/collision/shapes/Ray.h>
#endif
#ifndef INCLUDED_luxe_collision_shapes_Shape
#include <luxe/collision/shapes/Shape.h>
#endif
#ifndef INCLUDED_phoenix_Vector
#include <phoenix/Vector.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_17079a046eb6edaa_13_testCircleVsPolygon,"luxe.collision.sat.SAT2D","testCircleVsPolygon",0xd9d5ba49,"luxe.collision.sat.SAT2D.testCircleVsPolygon","luxe/collision/sat/SAT2D.hx",13,0x7b849025)
HX_LOCAL_STACK_FRAME(_hx_pos_17079a046eb6edaa_143_testCircleVsCircle,"luxe.collision.sat.SAT2D","testCircleVsCircle",0xd9d0e921,"luxe.collision.sat.SAT2D.testCircleVsCircle","luxe/collision/sat/SAT2D.hx",143,0x7b849025)
HX_LOCAL_STACK_FRAME(_hx_pos_17079a046eb6edaa_191_testPolygonVsPolygon,"luxe.collision.sat.SAT2D","testPolygonVsPolygon",0x381ddda7,"luxe.collision.sat.SAT2D.testPolygonVsPolygon","luxe/collision/sat/SAT2D.hx",191,0x7b849025)
HX_LOCAL_STACK_FRAME(_hx_pos_17079a046eb6edaa_226_testRayVsCircle,"luxe.collision.sat.SAT2D","testRayVsCircle",0x1c6510f3,"luxe.collision.sat.SAT2D.testRayVsCircle","luxe/collision/sat/SAT2D.hx",226,0x7b849025)
HX_LOCAL_STACK_FRAME(_hx_pos_17079a046eb6edaa_271_testRayVsPolygon,"luxe.collision.sat.SAT2D","testRayVsPolygon",0xd8e46a37,"luxe.collision.sat.SAT2D.testRayVsPolygon","luxe/collision/sat/SAT2D.hx",271,0x7b849025)
HX_LOCAL_STACK_FRAME(_hx_pos_17079a046eb6edaa_330_testRayVsRay,"luxe.collision.sat.SAT2D","testRayVsRay",0x22925b27,"luxe.collision.sat.SAT2D.testRayVsRay","luxe/collision/sat/SAT2D.hx",330,0x7b849025)
HX_LOCAL_STACK_FRAME(_hx_pos_17079a046eb6edaa_378_checkPolygons,"luxe.collision.sat.SAT2D","checkPolygons",0xeb680d0f,"luxe.collision.sat.SAT2D.checkPolygons","luxe/collision/sat/SAT2D.hx",378,0x7b849025)
HX_LOCAL_STACK_FRAME(_hx_pos_17079a046eb6edaa_456_rayU,"luxe.collision.sat.SAT2D","rayU",0xb98e757d,"luxe.collision.sat.SAT2D.rayU","luxe/collision/sat/SAT2D.hx",456,0x7b849025)
HX_LOCAL_STACK_FRAME(_hx_pos_17079a046eb6edaa_459_findNormalAxisX,"luxe.collision.sat.SAT2D","findNormalAxisX",0xdc39b025,"luxe.collision.sat.SAT2D.findNormalAxisX","luxe/collision/sat/SAT2D.hx",459,0x7b849025)
HX_LOCAL_STACK_FRAME(_hx_pos_17079a046eb6edaa_464_findNormalAxisY,"luxe.collision.sat.SAT2D","findNormalAxisY",0xdc39b026,"luxe.collision.sat.SAT2D.findNormalAxisY","luxe/collision/sat/SAT2D.hx",464,0x7b849025)
HX_LOCAL_STACK_FRAME(_hx_pos_17079a046eb6edaa_188_boot,"luxe.collision.sat.SAT2D","boot",0xaf05a284,"luxe.collision.sat.SAT2D.boot","luxe/collision/sat/SAT2D.hx",188,0x7b849025)
HX_LOCAL_STACK_FRAME(_hx_pos_17079a046eb6edaa_189_boot,"luxe.collision.sat.SAT2D","boot",0xaf05a284,"luxe.collision.sat.SAT2D.boot","luxe/collision/sat/SAT2D.hx",189,0x7b849025)
namespace luxe{
namespace collision{
namespace sat{

void SAT2D_obj::__construct() { }

Dynamic SAT2D_obj::__CreateEmpty() { return new SAT2D_obj; }

void *SAT2D_obj::_hx_vtable = 0;

Dynamic SAT2D_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< SAT2D_obj > _hx_result = new SAT2D_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool SAT2D_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x3fd399ae;
}

 ::luxe::collision::data::ShapeCollision SAT2D_obj::testCircleVsPolygon( ::luxe::collision::shapes::Circle circle, ::luxe::collision::shapes::Polygon polygon, ::luxe::collision::data::ShapeCollision into,hx::Null< bool >  __o_flip){
bool flip = __o_flip.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_17079a046eb6edaa_13_testCircleVsPolygon)
HXLINE(  15)		if (hx::IsNull( into )) {
HXLINE(  15)			into =  ::luxe::collision::data::ShapeCollision_obj::__alloc( HX_CTX );
            		}
            		else {
HXLINE(  15)			into->shape1 = (into->shape2 = null());
HXDLIN(  15)			into->overlap = (into->separationX = (into->separationY = (into->unitVectorX = (into->unitVectorY = ((Float)0.0)))));
HXDLIN(  15)			into->otherOverlap = (into->otherSeparationX = (into->otherSeparationY = (into->otherUnitVectorX = (into->otherUnitVectorY = ((Float)0.0)))));
HXDLIN(  15)			into = into;
            		}
HXLINE(  17)		::Array< ::Dynamic> verts = polygon->get_transformedVertices();
HXLINE(  19)		Float circleX = circle->_position->x;
HXLINE(  20)		Float circleY = circle->_position->y;
HXLINE(  22)		Float testDistance = (int)1073741823;
HXLINE(  23)		Float distance = ((Float)0.0);
HXDLIN(  23)		Float closestX = ((Float)0.0);
HXDLIN(  23)		Float closestY = ((Float)0.0);
HXLINE(  24)		{
HXLINE(  24)			int _g1 = (int)0;
HXDLIN(  24)			int _g = verts->length;
HXDLIN(  24)			while((_g1 < _g)){
HXLINE(  24)				_g1 = (_g1 + (int)1);
HXDLIN(  24)				int i = (_g1 - (int)1);
HXLINE(  26)				Float x = (circleX - verts->__get(i).StaticCast<  ::phoenix::Vector >()->x);
HXDLIN(  26)				Float y = (circleY - verts->__get(i).StaticCast<  ::phoenix::Vector >()->y);
HXDLIN(  26)				distance = ((x * x) + (y * y));
HXLINE(  28)				if ((distance < testDistance)) {
HXLINE(  29)					testDistance = distance;
HXLINE(  30)					closestX = verts->__get(i).StaticCast<  ::phoenix::Vector >()->x;
HXLINE(  31)					closestY = verts->__get(i).StaticCast<  ::phoenix::Vector >()->y;
            				}
            			}
            		}
HXLINE(  36)		Float normalAxisX = (closestX - circleX);
HXLINE(  37)		Float normalAxisY = (closestY - circleY);
HXLINE(  38)		Float normAxisLen = ::Math_obj::sqrt(((normalAxisX * normalAxisX) + (normalAxisY * normalAxisY)));
HXLINE(  39)		Float component = normalAxisX;
HXDLIN(  39)		if ((normAxisLen == (int)0)) {
HXLINE(  39)			normalAxisX = (int)0;
            		}
            		else {
HXLINE(  39)			component = ((Float)component / (Float)normAxisLen);
HXDLIN(  39)			normalAxisX = component;
            		}
HXLINE(  40)		Float component1 = normalAxisY;
HXDLIN(  40)		if ((normAxisLen == (int)0)) {
HXLINE(  40)			normalAxisY = (int)0;
            		}
            		else {
HXLINE(  40)			component1 = ((Float)component1 / (Float)normAxisLen);
HXDLIN(  40)			normalAxisY = component1;
            		}
HXLINE(  43)		Float test = ((Float)0.0);
HXLINE(  44)		Float min1 = ((normalAxisX * verts->__get((int)0).StaticCast<  ::phoenix::Vector >()->x) + (normalAxisY * verts->__get((int)0).StaticCast<  ::phoenix::Vector >()->y));
HXLINE(  45)		Float max1 = min1;
HXLINE(  47)		{
HXLINE(  47)			int _g11 = (int)1;
HXDLIN(  47)			int _g2 = verts->length;
HXDLIN(  47)			while((_g11 < _g2)){
HXLINE(  47)				_g11 = (_g11 + (int)1);
HXDLIN(  47)				int j = (_g11 - (int)1);
HXLINE(  48)				test = ((normalAxisX * verts->__get(j).StaticCast<  ::phoenix::Vector >()->x) + (normalAxisY * verts->__get(j).StaticCast<  ::phoenix::Vector >()->y));
HXLINE(  49)				if ((test < min1)) {
HXLINE(  49)					min1 = test;
            				}
HXLINE(  50)				if ((test > max1)) {
HXLINE(  50)					max1 = test;
            				}
            			}
            		}
HXLINE(  54)		Float max2 = circle->get_transformedRadius();
HXLINE(  55)		Float min2 = -(circle->get_transformedRadius());
HXLINE(  56)		Float offset = ((normalAxisX * -(circleX)) + (normalAxisY * -(circleY)));
HXLINE(  58)		min1 = (min1 + offset);
HXLINE(  59)		max1 = (max1 + offset);
HXLINE(  61)		Float test1 = (min1 - max2);
HXLINE(  62)		Float test2 = (min2 - max1);
HXLINE(  65)		bool _hx_tmp;
HXDLIN(  65)		if (!((test1 > (int)0))) {
HXLINE(  65)			_hx_tmp = (test2 > (int)0);
            		}
            		else {
HXLINE(  65)			_hx_tmp = true;
            		}
HXDLIN(  65)		if (_hx_tmp) {
HXLINE(  65)			return null();
            		}
HXLINE(  68)		Float distMin = -((max2 - min1));
HXLINE(  69)		if (flip) {
HXLINE(  69)			distMin = (distMin * (int)-1);
            		}
HXLINE(  71)		into->overlap = distMin;
HXLINE(  72)		into->unitVectorX = normalAxisX;
HXLINE(  73)		into->unitVectorY = normalAxisY;
HXLINE(  74)		Float closest = ::Math_obj::abs(distMin);
HXLINE(  77)		{
HXLINE(  77)			int _g12 = (int)0;
HXDLIN(  77)			int _g3 = verts->length;
HXDLIN(  77)			while((_g12 < _g3)){
HXLINE(  77)				_g12 = (_g12 + (int)1);
HXDLIN(  77)				int i1 = (_g12 - (int)1);
HXLINE(  79)				 ::phoenix::Vector v2;
HXDLIN(  79)				if ((i1 >= (verts->length - (int)1))) {
HXLINE(  79)					v2 = verts->__get((int)0).StaticCast<  ::phoenix::Vector >();
            				}
            				else {
HXLINE(  79)					v2 = verts->__get((i1 + (int)1)).StaticCast<  ::phoenix::Vector >();
            				}
HXDLIN(  79)				normalAxisX = -((v2->y - verts->__get(i1).StaticCast<  ::phoenix::Vector >()->y));
HXLINE(  80)				 ::phoenix::Vector v21;
HXDLIN(  80)				if ((i1 >= (verts->length - (int)1))) {
HXLINE(  80)					v21 = verts->__get((int)0).StaticCast<  ::phoenix::Vector >();
            				}
            				else {
HXLINE(  80)					v21 = verts->__get((i1 + (int)1)).StaticCast<  ::phoenix::Vector >();
            				}
HXDLIN(  80)				normalAxisY = (v21->x - verts->__get(i1).StaticCast<  ::phoenix::Vector >()->x);
HXLINE(  81)				Float aLen = ::Math_obj::sqrt(((normalAxisX * normalAxisX) + (normalAxisY * normalAxisY)));
HXLINE(  82)				Float component2 = normalAxisX;
HXDLIN(  82)				if ((aLen == (int)0)) {
HXLINE(  82)					normalAxisX = (int)0;
            				}
            				else {
HXLINE(  82)					component2 = ((Float)component2 / (Float)aLen);
HXDLIN(  82)					normalAxisX = component2;
            				}
HXLINE(  83)				Float component3 = normalAxisY;
HXDLIN(  83)				if ((aLen == (int)0)) {
HXLINE(  83)					normalAxisY = (int)0;
            				}
            				else {
HXLINE(  83)					component3 = ((Float)component3 / (Float)aLen);
HXDLIN(  83)					normalAxisY = component3;
            				}
HXLINE(  86)				min1 = ((normalAxisX * verts->__get((int)0).StaticCast<  ::phoenix::Vector >()->x) + (normalAxisY * verts->__get((int)0).StaticCast<  ::phoenix::Vector >()->y));
HXLINE(  87)				max1 = min1;
HXLINE(  90)				{
HXLINE(  90)					int _g31 = (int)1;
HXDLIN(  90)					int _g21 = verts->length;
HXDLIN(  90)					while((_g31 < _g21)){
HXLINE(  90)						_g31 = (_g31 + (int)1);
HXDLIN(  90)						int j1 = (_g31 - (int)1);
HXLINE(  91)						test = ((normalAxisX * verts->__get(j1).StaticCast<  ::phoenix::Vector >()->x) + (normalAxisY * verts->__get(j1).StaticCast<  ::phoenix::Vector >()->y));
HXLINE(  92)						if ((test < min1)) {
HXLINE(  92)							min1 = test;
            						}
HXLINE(  93)						if ((test > max1)) {
HXLINE(  93)							max1 = test;
            						}
            					}
            				}
HXLINE(  97)				max2 = circle->get_transformedRadius();
HXLINE(  98)				min2 = -(circle->get_transformedRadius());
HXLINE( 101)				offset = ((normalAxisX * -(circleX)) + (normalAxisY * -(circleY)));
HXLINE( 102)				min1 = (min1 + offset);
HXLINE( 103)				max1 = (max1 + offset);
HXLINE( 106)				test1 = (min1 - max2);
HXLINE( 107)				test2 = (min2 - max1);
HXLINE( 110)				bool _hx_tmp1;
HXDLIN( 110)				if (!((test1 > (int)0))) {
HXLINE( 110)					_hx_tmp1 = (test2 > (int)0);
            				}
            				else {
HXLINE( 110)					_hx_tmp1 = true;
            				}
HXDLIN( 110)				if (_hx_tmp1) {
HXLINE( 111)					return null();
            				}
HXLINE( 114)				distMin = -((max2 - min1));
HXLINE( 115)				if (flip) {
HXLINE( 115)					distMin = (distMin * (int)-1);
            				}
HXLINE( 117)				if ((::Math_obj::abs(distMin) < closest)) {
HXLINE( 118)					into->unitVectorX = normalAxisX;
HXLINE( 119)					into->unitVectorY = normalAxisY;
HXLINE( 120)					into->overlap = distMin;
HXLINE( 121)					closest = ::Math_obj::abs(distMin);
            				}
            			}
            		}
HXLINE( 128)		 ::luxe::collision::shapes::Shape _hx_tmp2;
HXDLIN( 128)		if (flip) {
HXLINE( 128)			_hx_tmp2 = polygon;
            		}
            		else {
HXLINE( 128)			_hx_tmp2 = circle;
            		}
HXDLIN( 128)		into->shape1 = _hx_tmp2;
HXLINE( 129)		 ::luxe::collision::shapes::Shape _hx_tmp3;
HXDLIN( 129)		if (flip) {
HXLINE( 129)			_hx_tmp3 = circle;
            		}
            		else {
HXLINE( 129)			_hx_tmp3 = polygon;
            		}
HXDLIN( 129)		into->shape2 = _hx_tmp3;
HXLINE( 130)		into->separationX = (into->unitVectorX * into->overlap);
HXLINE( 131)		into->separationY = (into->unitVectorY * into->overlap);
HXLINE( 133)		if (!(flip)) {
HXLINE( 134)			into->unitVectorX = -(into->unitVectorX);
HXLINE( 135)			into->unitVectorY = -(into->unitVectorY);
            		}
HXLINE( 138)		return into;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(SAT2D_obj,testCircleVsPolygon,return )

 ::luxe::collision::data::ShapeCollision SAT2D_obj::testCircleVsCircle( ::luxe::collision::shapes::Circle circleA, ::luxe::collision::shapes::Circle circleB, ::luxe::collision::data::ShapeCollision into,hx::Null< bool >  __o_flip){
bool flip = __o_flip.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_17079a046eb6edaa_143_testCircleVsCircle)
HXLINE( 146)		 ::luxe::collision::shapes::Circle circle1;
HXDLIN( 146)		if (flip) {
HXLINE( 146)			circle1 = circleB;
            		}
            		else {
HXLINE( 146)			circle1 = circleA;
            		}
HXLINE( 147)		 ::luxe::collision::shapes::Circle circle2;
HXDLIN( 147)		if (flip) {
HXLINE( 147)			circle2 = circleA;
            		}
            		else {
HXLINE( 147)			circle2 = circleB;
            		}
HXLINE( 150)		Float totalRadius = circle1->get_transformedRadius();
HXDLIN( 150)		Float totalRadius1 = (totalRadius + circle2->get_transformedRadius());
HXLINE( 152)		Float x = (circle1->_position->x - circle2->_position->x);
HXDLIN( 152)		Float y = (circle1->_position->y - circle2->_position->y);
HXDLIN( 152)		Float distancesq = ((x * x) + (y * y));
HXLINE( 155)		if ((distancesq < (totalRadius1 * totalRadius1))) {
HXLINE( 157)			if (hx::IsNull( into )) {
HXLINE( 157)				into =  ::luxe::collision::data::ShapeCollision_obj::__alloc( HX_CTX );
            			}
            			else {
HXLINE( 157)				into->shape1 = (into->shape2 = null());
HXDLIN( 157)				into->overlap = (into->separationX = (into->separationY = (into->unitVectorX = (into->unitVectorY = ((Float)0.0)))));
HXDLIN( 157)				into->otherOverlap = (into->otherSeparationX = (into->otherSeparationY = (into->otherUnitVectorX = (into->otherUnitVectorY = ((Float)0.0)))));
HXDLIN( 157)				into = into;
            			}
HXLINE( 159)			Float difference = (totalRadius1 - ::Math_obj::sqrt(distancesq));
HXLINE( 161)			into->shape1 = circle1;
HXLINE( 162)			into->shape2 = circle2;
HXLINE( 164)			Float unitVecX = (circle1->_position->x - circle2->_position->x);
HXLINE( 165)			Float unitVecY = (circle1->_position->y - circle2->_position->y);
HXLINE( 166)			Float unitVecLen = ::Math_obj::sqrt(((unitVecX * unitVecX) + (unitVecY * unitVecY)));
HXLINE( 168)			Float component = unitVecX;
HXDLIN( 168)			if ((unitVecLen == (int)0)) {
HXLINE( 168)				unitVecX = (int)0;
            			}
            			else {
HXLINE( 168)				component = ((Float)component / (Float)unitVecLen);
HXDLIN( 168)				unitVecX = component;
            			}
HXLINE( 169)			Float component1 = unitVecY;
HXDLIN( 169)			if ((unitVecLen == (int)0)) {
HXLINE( 169)				unitVecY = (int)0;
            			}
            			else {
HXLINE( 169)				component1 = ((Float)component1 / (Float)unitVecLen);
HXDLIN( 169)				unitVecY = component1;
            			}
HXLINE( 171)			into->unitVectorX = unitVecX;
HXLINE( 172)			into->unitVectorY = unitVecY;
HXLINE( 175)			into->separationX = (into->unitVectorX * difference);
HXLINE( 176)			into->separationY = (into->unitVectorY * difference);
HXLINE( 177)			into->overlap = difference;
HXLINE( 179)			return into;
            		}
HXLINE( 183)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(SAT2D_obj,testCircleVsCircle,return )

 ::luxe::collision::data::ShapeCollision SAT2D_obj::tmp1;

 ::luxe::collision::data::ShapeCollision SAT2D_obj::tmp2;

 ::luxe::collision::data::ShapeCollision SAT2D_obj::testPolygonVsPolygon( ::luxe::collision::shapes::Polygon polygon1, ::luxe::collision::shapes::Polygon polygon2, ::luxe::collision::data::ShapeCollision into,hx::Null< bool >  __o_flip){
bool flip = __o_flip.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_17079a046eb6edaa_191_testPolygonVsPolygon)
HXLINE( 193)		if (hx::IsNull( into )) {
HXLINE( 193)			into =  ::luxe::collision::data::ShapeCollision_obj::__alloc( HX_CTX );
            		}
            		else {
HXLINE( 193)			into->shape1 = (into->shape2 = null());
HXDLIN( 193)			into->overlap = (into->separationX = (into->separationY = (into->unitVectorX = (into->unitVectorY = ((Float)0.0)))));
HXDLIN( 193)			into->otherOverlap = (into->otherSeparationX = (into->otherSeparationY = (into->otherUnitVectorX = (into->otherUnitVectorY = ((Float)0.0)))));
HXDLIN( 193)			into = into;
            		}
HXLINE( 195)		if (hx::IsNull( ::luxe::collision::sat::SAT2D_obj::checkPolygons(polygon1,polygon2,::luxe::collision::sat::SAT2D_obj::tmp1,flip) )) {
HXLINE( 196)			return null();
            		}
HXLINE( 199)		if (hx::IsNull( ::luxe::collision::sat::SAT2D_obj::checkPolygons(polygon2,polygon1,::luxe::collision::sat::SAT2D_obj::tmp2,!(flip)) )) {
HXLINE( 200)			return null();
            		}
HXLINE( 203)		 ::luxe::collision::data::ShapeCollision result = null();
HXDLIN( 203)		 ::luxe::collision::data::ShapeCollision other = null();
HXLINE( 204)		Float _hx_tmp = ::Math_obj::abs(::luxe::collision::sat::SAT2D_obj::tmp1->overlap);
HXDLIN( 204)		if ((_hx_tmp < ::Math_obj::abs(::luxe::collision::sat::SAT2D_obj::tmp2->overlap))) {
HXLINE( 205)			result = ::luxe::collision::sat::SAT2D_obj::tmp1;
HXLINE( 206)			other = ::luxe::collision::sat::SAT2D_obj::tmp2;
            		}
            		else {
HXLINE( 208)			result = ::luxe::collision::sat::SAT2D_obj::tmp2;
HXLINE( 209)			other = ::luxe::collision::sat::SAT2D_obj::tmp1;
            		}
HXLINE( 212)		result->otherOverlap = other->overlap;
HXLINE( 213)		result->otherSeparationX = other->separationX;
HXLINE( 214)		result->otherSeparationY = other->separationY;
HXLINE( 215)		result->otherUnitVectorX = other->unitVectorX;
HXLINE( 216)		result->otherUnitVectorY = other->unitVectorY;
HXLINE( 218)		{
HXLINE( 218)			into->overlap = result->overlap;
HXDLIN( 218)			into->separationX = result->separationX;
HXDLIN( 218)			into->separationY = result->separationY;
HXDLIN( 218)			into->unitVectorX = result->unitVectorX;
HXDLIN( 218)			into->unitVectorY = result->unitVectorY;
HXDLIN( 218)			into->otherOverlap = result->otherOverlap;
HXDLIN( 218)			into->otherSeparationX = result->otherSeparationX;
HXDLIN( 218)			into->otherSeparationY = result->otherSeparationY;
HXDLIN( 218)			into->otherUnitVectorX = result->otherUnitVectorX;
HXDLIN( 218)			into->otherUnitVectorY = result->otherUnitVectorY;
HXDLIN( 218)			into->shape1 = result->shape1;
HXDLIN( 218)			into->shape2 = result->shape2;
            		}
HXLINE( 219)		other = null();
HXDLIN( 219)		result = other;
HXLINE( 221)		return into;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(SAT2D_obj,testPolygonVsPolygon,return )

 ::luxe::collision::data::RayCollision SAT2D_obj::testRayVsCircle( ::luxe::collision::shapes::Ray ray, ::luxe::collision::shapes::Circle circle, ::luxe::collision::data::RayCollision into){
            	HX_GC_STACKFRAME(&_hx_pos_17079a046eb6edaa_226_testRayVsCircle)
HXLINE( 228)		Float deltaX = (ray->end->x - ray->start->x);
HXLINE( 229)		Float deltaY = (ray->end->y - ray->start->y);
HXLINE( 230)		Float ray2circleX = (ray->start->x - circle->_position->x);
HXLINE( 231)		Float ray2circleY = (ray->start->y - circle->_position->y);
HXLINE( 233)		Float a = ((deltaX * deltaX) + (deltaY * deltaY));
HXLINE( 234)		Float b = ((int)2 * ((deltaX * ray2circleX) + (deltaY * ray2circleY)));
HXLINE( 235)		Float c = circle->get_transformedRadius();
HXDLIN( 235)		Float c1 = (((ray2circleX * ray2circleX) + (ray2circleY * ray2circleY)) - (c * circle->get_transformedRadius()));
HXLINE( 236)		Float d = ((b * b) - (((int)4 * a) * c1));
HXLINE( 238)		if ((d >= (int)0)) {
HXLINE( 240)			d = ::Math_obj::sqrt(d);
HXLINE( 242)			Float t1 = ((Float)(-(b) - d) / (Float)((int)2 * a));
HXLINE( 243)			Float t2 = ((Float)(-(b) + d) / (Float)((int)2 * a));
HXLINE( 245)			bool valid;
HXDLIN( 245)			 ::luxe::collision::shapes::InfiniteState _g = ray->infinite;
HXDLIN( 245)			switch((int)(_hx_getEnumValueIndex(_g))){
            				case (int)0: {
HXLINE( 246)					if ((t1 >= ((Float)0.0))) {
HXLINE( 245)						valid = (t1 <= ((Float)1.0));
            					}
            					else {
HXLINE( 245)						valid = false;
            					}
            				}
            				break;
            				case (int)1: {
HXLINE( 245)					valid = (t1 >= ((Float)0.0));
            				}
            				break;
            				case (int)2: {
HXLINE( 245)					valid = true;
            				}
            				break;
            			}
HXLINE( 251)			if (valid) {
HXLINE( 253)				if (hx::IsNull( into )) {
HXLINE( 253)					into =  ::luxe::collision::data::RayCollision_obj::__alloc( HX_CTX );
            				}
            				else {
HXLINE( 253)					into->ray = null();
HXDLIN( 253)					into->shape = null();
HXDLIN( 253)					into->start = ((Float)0.0);
HXDLIN( 253)					into->end = ((Float)0.0);
HXDLIN( 253)					into = into;
            				}
HXLINE( 255)				into->shape = circle;
HXLINE( 256)				into->ray = ray;
HXLINE( 257)				into->start = t1;
HXLINE( 258)				into->end = t2;
HXLINE( 260)				return into;
            			}
            		}
HXLINE( 266)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(SAT2D_obj,testRayVsCircle,return )

 ::luxe::collision::data::RayCollision SAT2D_obj::testRayVsPolygon( ::luxe::collision::shapes::Ray ray, ::luxe::collision::shapes::Polygon polygon, ::luxe::collision::data::RayCollision into){
            	HX_GC_STACKFRAME(&_hx_pos_17079a046eb6edaa_271_testRayVsPolygon)
HXLINE( 273)		Float min_u = ::Math_obj::POSITIVE_INFINITY;
HXLINE( 274)		Float max_u = ::Math_obj::NEGATIVE_INFINITY;
HXLINE( 276)		Float startX = ray->start->x;
HXLINE( 277)		Float startY = ray->start->y;
HXLINE( 278)		Float deltaX = (ray->end->x - startX);
HXLINE( 279)		Float deltaY = (ray->end->y - startY);
HXLINE( 281)		::Array< ::Dynamic> verts = polygon->get_transformedVertices();
HXLINE( 282)		 ::phoenix::Vector v1 = verts->__get((verts->length - (int)1)).StaticCast<  ::phoenix::Vector >();
HXLINE( 283)		 ::phoenix::Vector v2 = verts->__get((int)0).StaticCast<  ::phoenix::Vector >();
HXLINE( 285)		Float ud = ((v2->y - v1->y) * deltaX);
HXDLIN( 285)		Float ud1 = (ud - ((v2->x - v1->x) * deltaY));
HXLINE( 286)		Float ua = ((Float)(((v2->x - v1->x) * (startY - v1->y)) - ((v2->y - v1->y) * (startX - v1->x))) / (Float)ud1);
HXLINE( 287)		Float ub = ((Float)((deltaX * (startY - v1->y)) - (deltaY * (startX - v1->x))) / (Float)ud1);
HXLINE( 289)		bool _hx_tmp;
HXDLIN( 289)		bool _hx_tmp1;
HXDLIN( 289)		if ((ud1 != ((Float)0.0))) {
HXLINE( 289)			_hx_tmp1 = (ub >= ((Float)0.0));
            		}
            		else {
HXLINE( 289)			_hx_tmp1 = false;
            		}
HXDLIN( 289)		if (_hx_tmp1) {
HXLINE( 289)			_hx_tmp = (ub <= ((Float)1.0));
            		}
            		else {
HXLINE( 289)			_hx_tmp = false;
            		}
HXDLIN( 289)		if (_hx_tmp) {
HXLINE( 290)			if ((ua < min_u)) {
HXLINE( 290)				min_u = ua;
            			}
HXLINE( 291)			if ((ua > max_u)) {
HXLINE( 291)				max_u = ua;
            			}
            		}
HXLINE( 294)		{
HXLINE( 294)			int _g1 = (int)1;
HXDLIN( 294)			int _g = verts->length;
HXDLIN( 294)			while((_g1 < _g)){
HXLINE( 294)				_g1 = (_g1 + (int)1);
HXDLIN( 294)				int i = (_g1 - (int)1);
HXLINE( 296)				v1 = verts->__get((i - (int)1)).StaticCast<  ::phoenix::Vector >();
HXLINE( 297)				v2 = verts->__get(i).StaticCast<  ::phoenix::Vector >();
HXLINE( 299)				Float ud2 = ((v2->y - v1->y) * deltaX);
HXDLIN( 299)				ud1 = (ud2 - ((v2->x - v1->x) * deltaY));
HXLINE( 300)				ua = ((Float)(((v2->x - v1->x) * (startY - v1->y)) - ((v2->y - v1->y) * (startX - v1->x))) / (Float)ud1);
HXLINE( 301)				ub = ((Float)((deltaX * (startY - v1->y)) - (deltaY * (startX - v1->x))) / (Float)ud1);
HXLINE( 303)				bool _hx_tmp2;
HXDLIN( 303)				bool _hx_tmp3;
HXDLIN( 303)				if ((ud1 != ((Float)0.0))) {
HXLINE( 303)					_hx_tmp3 = (ub >= ((Float)0.0));
            				}
            				else {
HXLINE( 303)					_hx_tmp3 = false;
            				}
HXDLIN( 303)				if (_hx_tmp3) {
HXLINE( 303)					_hx_tmp2 = (ub <= ((Float)1.0));
            				}
            				else {
HXLINE( 303)					_hx_tmp2 = false;
            				}
HXDLIN( 303)				if (_hx_tmp2) {
HXLINE( 304)					if ((ua < min_u)) {
HXLINE( 304)						min_u = ua;
            					}
HXLINE( 305)					if ((ua > max_u)) {
HXLINE( 305)						max_u = ua;
            					}
            				}
            			}
            		}
HXLINE( 310)		bool valid;
HXDLIN( 310)		 ::luxe::collision::shapes::InfiniteState _g2 = ray->infinite;
HXDLIN( 310)		switch((int)(_hx_getEnumValueIndex(_g2))){
            			case (int)0: {
HXLINE( 311)				if ((min_u >= ((Float)0.0))) {
HXLINE( 310)					valid = (min_u <= ((Float)1.0));
            				}
            				else {
HXLINE( 310)					valid = false;
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 312)				if ((min_u != ::Math_obj::POSITIVE_INFINITY)) {
HXLINE( 310)					valid = (min_u >= ((Float)0.0));
            				}
            				else {
HXLINE( 310)					valid = false;
            				}
            			}
            			break;
            			case (int)2: {
HXLINE( 310)				valid = (min_u != ::Math_obj::POSITIVE_INFINITY);
            			}
            			break;
            		}
HXLINE( 316)		if (valid) {
HXLINE( 317)			if (hx::IsNull( into )) {
HXLINE( 317)				into =  ::luxe::collision::data::RayCollision_obj::__alloc( HX_CTX );
            			}
            			else {
HXLINE( 317)				into->ray = null();
HXDLIN( 317)				into->shape = null();
HXDLIN( 317)				into->start = ((Float)0.0);
HXDLIN( 317)				into->end = ((Float)0.0);
HXDLIN( 317)				into = into;
            			}
HXLINE( 318)			into->shape = polygon;
HXLINE( 319)			into->ray = ray;
HXLINE( 320)			into->start = min_u;
HXLINE( 321)			into->end = max_u;
HXLINE( 322)			return into;
            		}
HXLINE( 325)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(SAT2D_obj,testRayVsPolygon,return )

 ::luxe::collision::data::RayIntersection SAT2D_obj::testRayVsRay( ::luxe::collision::shapes::Ray ray1, ::luxe::collision::shapes::Ray ray2, ::luxe::collision::data::RayIntersection into){
            	HX_GC_STACKFRAME(&_hx_pos_17079a046eb6edaa_330_testRayVsRay)
HXLINE( 332)		Float delta1X = (ray1->end->x - ray1->start->x);
HXLINE( 333)		Float delta1Y = (ray1->end->y - ray1->start->y);
HXLINE( 334)		Float delta2X = (ray2->end->x - ray2->start->x);
HXLINE( 335)		Float delta2Y = (ray2->end->y - ray2->start->y);
HXLINE( 336)		Float diffX = (ray1->start->x - ray2->start->x);
HXLINE( 337)		Float diffY = (ray1->start->y - ray2->start->y);
HXLINE( 338)		Float ud = ((delta2Y * delta1X) - (delta2X * delta1Y));
HXLINE( 340)		if ((ud == ((Float)0.0))) {
HXLINE( 340)			return null();
            		}
HXLINE( 342)		Float u1 = ((Float)((delta2X * diffY) - (delta2Y * diffX)) / (Float)ud);
HXLINE( 343)		Float u2 = ((Float)((delta1X * diffY) - (delta1Y * diffX)) / (Float)ud);
HXLINE( 346)		bool valid1;
HXDLIN( 346)		 ::luxe::collision::shapes::InfiniteState _g = ray1->infinite;
HXDLIN( 346)		switch((int)(_hx_getEnumValueIndex(_g))){
            			case (int)0: {
HXLINE( 347)				if ((u1 > ((Float)0.0))) {
HXLINE( 346)					valid1 = (u1 <= ((Float)1.0));
            				}
            				else {
HXLINE( 346)					valid1 = false;
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 346)				valid1 = (u1 > ((Float)0.0));
            			}
            			break;
            			case (int)2: {
HXLINE( 346)				valid1 = true;
            			}
            			break;
            		}
HXLINE( 352)		bool valid2;
HXDLIN( 352)		 ::luxe::collision::shapes::InfiniteState _g1 = ray2->infinite;
HXDLIN( 352)		switch((int)(_hx_getEnumValueIndex(_g1))){
            			case (int)0: {
HXLINE( 353)				if ((u2 > ((Float)0.0))) {
HXLINE( 352)					valid2 = (u2 <= ((Float)1.0));
            				}
            				else {
HXLINE( 352)					valid2 = false;
            				}
            			}
            			break;
            			case (int)1: {
HXLINE( 352)				valid2 = (u2 > ((Float)0.0));
            			}
            			break;
            			case (int)2: {
HXLINE( 352)				valid2 = true;
            			}
            			break;
            		}
HXLINE( 358)		bool _hx_tmp;
HXDLIN( 358)		if (valid1) {
HXLINE( 358)			_hx_tmp = valid2;
            		}
            		else {
HXLINE( 358)			_hx_tmp = false;
            		}
HXDLIN( 358)		if (_hx_tmp) {
HXLINE( 360)			if (hx::IsNull( into )) {
HXLINE( 360)				into =  ::luxe::collision::data::RayIntersection_obj::__alloc( HX_CTX );
            			}
            			else {
HXLINE( 360)				into->ray1 = null();
HXDLIN( 360)				into->ray2 = null();
HXDLIN( 360)				into->u1 = ((Float)0.0);
HXDLIN( 360)				into->u2 = ((Float)0.0);
HXDLIN( 360)				into = into;
            			}
HXLINE( 362)			into->ray1 = ray1;
HXLINE( 363)			into->ray2 = ray2;
HXLINE( 364)			into->u1 = u1;
HXLINE( 365)			into->u2 = u2;
HXLINE( 367)			return into;
            		}
HXLINE( 371)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(SAT2D_obj,testRayVsRay,return )

 ::luxe::collision::data::ShapeCollision SAT2D_obj::checkPolygons( ::luxe::collision::shapes::Polygon polygon1, ::luxe::collision::shapes::Polygon polygon2, ::luxe::collision::data::ShapeCollision into,hx::Null< bool >  __o_flip){
bool flip = __o_flip.Default(false);
            	HX_STACKFRAME(&_hx_pos_17079a046eb6edaa_378_checkPolygons)
HXLINE( 380)		{
HXLINE( 380)			into->shape1 = (into->shape2 = null());
HXDLIN( 380)			into->overlap = (into->separationX = (into->separationY = (into->unitVectorX = (into->unitVectorY = ((Float)0.0)))));
HXDLIN( 380)			into->otherOverlap = (into->otherSeparationX = (into->otherSeparationY = (into->otherUnitVectorX = (into->otherUnitVectorY = ((Float)0.0)))));
            		}
HXLINE( 382)		Float offset = ((Float)0.0);
HXDLIN( 382)		Float test1 = ((Float)0.0);
HXDLIN( 382)		Float test2 = ((Float)0.0);
HXDLIN( 382)		Float testNum = ((Float)0.0);
HXLINE( 383)		Float min1 = ((Float)0.0);
HXDLIN( 383)		Float max1 = ((Float)0.0);
HXDLIN( 383)		Float min2 = ((Float)0.0);
HXDLIN( 383)		Float max2 = ((Float)0.0);
HXLINE( 384)		Float closest = (int)1073741823;
HXLINE( 386)		Float axisX = ((Float)0.0);
HXLINE( 387)		Float axisY = ((Float)0.0);
HXLINE( 388)		::Array< ::Dynamic> verts1 = polygon1->get_transformedVertices();
HXLINE( 389)		::Array< ::Dynamic> verts2 = polygon2->get_transformedVertices();
HXLINE( 392)		{
HXLINE( 392)			int _g1 = (int)0;
HXDLIN( 392)			int _g = verts1->length;
HXDLIN( 392)			while((_g1 < _g)){
HXLINE( 392)				_g1 = (_g1 + (int)1);
HXDLIN( 392)				int i = (_g1 - (int)1);
HXLINE( 394)				 ::phoenix::Vector v2;
HXDLIN( 394)				if ((i >= (verts1->length - (int)1))) {
HXLINE( 394)					v2 = verts1->__get((int)0).StaticCast<  ::phoenix::Vector >();
            				}
            				else {
HXLINE( 394)					v2 = verts1->__get((i + (int)1)).StaticCast<  ::phoenix::Vector >();
            				}
HXDLIN( 394)				axisX = -((v2->y - verts1->__get(i).StaticCast<  ::phoenix::Vector >()->y));
HXLINE( 395)				 ::phoenix::Vector v21;
HXDLIN( 395)				if ((i >= (verts1->length - (int)1))) {
HXLINE( 395)					v21 = verts1->__get((int)0).StaticCast<  ::phoenix::Vector >();
            				}
            				else {
HXLINE( 395)					v21 = verts1->__get((i + (int)1)).StaticCast<  ::phoenix::Vector >();
            				}
HXDLIN( 395)				axisY = (v21->x - verts1->__get(i).StaticCast<  ::phoenix::Vector >()->x);
HXLINE( 396)				Float aLen = ::Math_obj::sqrt(((axisX * axisX) + (axisY * axisY)));
HXLINE( 397)				Float component = axisX;
HXDLIN( 397)				if ((aLen == (int)0)) {
HXLINE( 397)					axisX = (int)0;
            				}
            				else {
HXLINE( 397)					component = ((Float)component / (Float)aLen);
HXDLIN( 397)					axisX = component;
            				}
HXLINE( 398)				Float component1 = axisY;
HXDLIN( 398)				if ((aLen == (int)0)) {
HXLINE( 398)					axisY = (int)0;
            				}
            				else {
HXLINE( 398)					component1 = ((Float)component1 / (Float)aLen);
HXDLIN( 398)					axisY = component1;
            				}
HXLINE( 401)				min1 = ((axisX * verts1->__get((int)0).StaticCast<  ::phoenix::Vector >()->x) + (axisY * verts1->__get((int)0).StaticCast<  ::phoenix::Vector >()->y));
HXLINE( 402)				max1 = min1;
HXLINE( 404)				{
HXLINE( 404)					int _g3 = (int)1;
HXDLIN( 404)					int _g2 = verts1->length;
HXDLIN( 404)					while((_g3 < _g2)){
HXLINE( 404)						_g3 = (_g3 + (int)1);
HXDLIN( 404)						int j = (_g3 - (int)1);
HXLINE( 405)						testNum = ((axisX * verts1->__get(j).StaticCast<  ::phoenix::Vector >()->x) + (axisY * verts1->__get(j).StaticCast<  ::phoenix::Vector >()->y));
HXLINE( 406)						if ((testNum < min1)) {
HXLINE( 406)							min1 = testNum;
            						}
HXLINE( 407)						if ((testNum > max1)) {
HXLINE( 407)							max1 = testNum;
            						}
            					}
            				}
HXLINE( 411)				min2 = ((axisX * verts2->__get((int)0).StaticCast<  ::phoenix::Vector >()->x) + (axisY * verts2->__get((int)0).StaticCast<  ::phoenix::Vector >()->y));
HXLINE( 412)				max2 = min2;
HXLINE( 414)				{
HXLINE( 414)					int _g31 = (int)1;
HXDLIN( 414)					int _g21 = verts2->length;
HXDLIN( 414)					while((_g31 < _g21)){
HXLINE( 414)						_g31 = (_g31 + (int)1);
HXDLIN( 414)						int j1 = (_g31 - (int)1);
HXLINE( 415)						testNum = ((axisX * verts2->__get(j1).StaticCast<  ::phoenix::Vector >()->x) + (axisY * verts2->__get(j1).StaticCast<  ::phoenix::Vector >()->y));
HXLINE( 416)						if ((testNum < min2)) {
HXLINE( 416)							min2 = testNum;
            						}
HXLINE( 417)						if ((testNum > max2)) {
HXLINE( 417)							max2 = testNum;
            						}
            					}
            				}
HXLINE( 420)				test1 = (min1 - max2);
HXLINE( 421)				test2 = (min2 - max1);
HXLINE( 423)				bool _hx_tmp;
HXDLIN( 423)				if (!((test1 > (int)0))) {
HXLINE( 423)					_hx_tmp = (test2 > (int)0);
            				}
            				else {
HXLINE( 423)					_hx_tmp = true;
            				}
HXDLIN( 423)				if (_hx_tmp) {
HXLINE( 423)					return null();
            				}
HXLINE( 425)				Float distMin = -((max2 - min1));
HXLINE( 426)				if (flip) {
HXLINE( 426)					distMin = (distMin * (int)-1);
            				}
HXLINE( 428)				if ((::Math_obj::abs(distMin) < closest)) {
HXLINE( 429)					into->unitVectorX = axisX;
HXLINE( 430)					into->unitVectorY = axisY;
HXLINE( 431)					into->overlap = distMin;
HXLINE( 432)					closest = ::Math_obj::abs(distMin);
            				}
            			}
            		}
HXLINE( 437)		 ::luxe::collision::shapes::Shape _hx_tmp1;
HXDLIN( 437)		if (flip) {
HXLINE( 437)			_hx_tmp1 = polygon2;
            		}
            		else {
HXLINE( 437)			_hx_tmp1 = polygon1;
            		}
HXDLIN( 437)		into->shape1 = _hx_tmp1;
HXLINE( 438)		 ::luxe::collision::shapes::Shape _hx_tmp2;
HXDLIN( 438)		if (flip) {
HXLINE( 438)			_hx_tmp2 = polygon1;
            		}
            		else {
HXLINE( 438)			_hx_tmp2 = polygon2;
            		}
HXDLIN( 438)		into->shape2 = _hx_tmp2;
HXLINE( 439)		into->separationX = (-(into->unitVectorX) * into->overlap);
HXLINE( 440)		into->separationY = (-(into->unitVectorY) * into->overlap);
HXLINE( 442)		if (flip) {
HXLINE( 443)			into->unitVectorX = -(into->unitVectorX);
HXLINE( 444)			into->unitVectorY = -(into->unitVectorY);
            		}
HXLINE( 447)		return into;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(SAT2D_obj,checkPolygons,return )

Float SAT2D_obj::rayU(Float udelta,Float aX,Float aY,Float bX,Float bY,Float dX,Float dY){
            	HX_STACKFRAME(&_hx_pos_17079a046eb6edaa_456_rayU)
HXDLIN( 456)		return ((Float)((dX * (aY - bY)) - (dY * (aX - bX))) / (Float)udelta);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC7(SAT2D_obj,rayU,return )

Float SAT2D_obj::findNormalAxisX(::Array< ::Dynamic> verts,int index){
            	HX_STACKFRAME(&_hx_pos_17079a046eb6edaa_459_findNormalAxisX)
HXLINE( 460)		 ::phoenix::Vector v2;
HXDLIN( 460)		if ((index >= (verts->length - (int)1))) {
HXLINE( 460)			v2 = verts->__get((int)0).StaticCast<  ::phoenix::Vector >();
            		}
            		else {
HXLINE( 460)			v2 = verts->__get((index + (int)1)).StaticCast<  ::phoenix::Vector >();
            		}
HXLINE( 461)		return -((v2->y - verts->__get(index).StaticCast<  ::phoenix::Vector >()->y));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(SAT2D_obj,findNormalAxisX,return )

Float SAT2D_obj::findNormalAxisY(::Array< ::Dynamic> verts,int index){
            	HX_STACKFRAME(&_hx_pos_17079a046eb6edaa_464_findNormalAxisY)
HXLINE( 465)		 ::phoenix::Vector v2;
HXDLIN( 465)		if ((index >= (verts->length - (int)1))) {
HXLINE( 465)			v2 = verts->__get((int)0).StaticCast<  ::phoenix::Vector >();
            		}
            		else {
HXLINE( 465)			v2 = verts->__get((index + (int)1)).StaticCast<  ::phoenix::Vector >();
            		}
HXLINE( 466)		return (v2->x - verts->__get(index).StaticCast<  ::phoenix::Vector >()->x);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(SAT2D_obj,findNormalAxisY,return )


SAT2D_obj::SAT2D_obj()
{
}

bool SAT2D_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"tmp1") ) { outValue = ( tmp1 ); return true; }
		if (HX_FIELD_EQ(inName,"tmp2") ) { outValue = ( tmp2 ); return true; }
		if (HX_FIELD_EQ(inName,"rayU") ) { outValue = rayU_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"testRayVsRay") ) { outValue = testRayVsRay_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"checkPolygons") ) { outValue = checkPolygons_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"testRayVsCircle") ) { outValue = testRayVsCircle_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"findNormalAxisX") ) { outValue = findNormalAxisX_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"findNormalAxisY") ) { outValue = findNormalAxisY_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"testRayVsPolygon") ) { outValue = testRayVsPolygon_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"testCircleVsCircle") ) { outValue = testCircleVsCircle_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"testCircleVsPolygon") ) { outValue = testCircleVsPolygon_dyn(); return true; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"testPolygonVsPolygon") ) { outValue = testPolygonVsPolygon_dyn(); return true; }
	}
	return false;
}

bool SAT2D_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"tmp1") ) { tmp1=ioValue.Cast<  ::luxe::collision::data::ShapeCollision >(); return true; }
		if (HX_FIELD_EQ(inName,"tmp2") ) { tmp2=ioValue.Cast<  ::luxe::collision::data::ShapeCollision >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *SAT2D_obj_sMemberStorageInfo = 0;
static hx::StaticInfo SAT2D_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::luxe::collision::data::ShapeCollision*/ ,(void *) &SAT2D_obj::tmp1,HX_HCSTRING("tmp1","\x7a","\xd7","\xff","\x4c")},
	{hx::fsObject /*::luxe::collision::data::ShapeCollision*/ ,(void *) &SAT2D_obj::tmp2,HX_HCSTRING("tmp2","\x7b","\xd7","\xff","\x4c")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void SAT2D_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(SAT2D_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(SAT2D_obj::tmp1,"tmp1");
	HX_MARK_MEMBER_NAME(SAT2D_obj::tmp2,"tmp2");
};

#ifdef HXCPP_VISIT_ALLOCS
static void SAT2D_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(SAT2D_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(SAT2D_obj::tmp1,"tmp1");
	HX_VISIT_MEMBER_NAME(SAT2D_obj::tmp2,"tmp2");
};

#endif

hx::Class SAT2D_obj::__mClass;

static ::String SAT2D_obj_sStaticFields[] = {
	HX_HCSTRING("testCircleVsPolygon","\x5b","\xec","\x40","\x9e"),
	HX_HCSTRING("testCircleVsCircle","\x4f","\x1f","\x15","\x71"),
	HX_HCSTRING("tmp1","\x7a","\xd7","\xff","\x4c"),
	HX_HCSTRING("tmp2","\x7b","\xd7","\xff","\x4c"),
	HX_HCSTRING("testPolygonVsPolygon","\x55","\x7b","\x7e","\x51"),
	HX_HCSTRING("testRayVsCircle","\x05","\x52","\xe5","\xb7"),
	HX_HCSTRING("testRayVsPolygon","\xe5","\x18","\x9d","\x4d"),
	HX_HCSTRING("testRayVsRay","\xd5","\x9a","\x06","\xdf"),
	HX_HCSTRING("checkPolygons","\xa1","\x85","\xab","\x14"),
	HX_HCSTRING("rayU","\x2b","\x57","\xa4","\x4b"),
	HX_HCSTRING("findNormalAxisX","\x37","\xf1","\xb9","\x77"),
	HX_HCSTRING("findNormalAxisY","\x38","\xf1","\xb9","\x77"),
	::String(null())
};

void SAT2D_obj::__register()
{
	hx::Object *dummy = new SAT2D_obj;
	SAT2D_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("luxe.collision.sat.SAT2D","\x5c","\xe3","\x02","\xb3");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &SAT2D_obj::__GetStatic;
	__mClass->mSetStaticField = &SAT2D_obj::__SetStatic;
	__mClass->mMarkFunc = SAT2D_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(SAT2D_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< SAT2D_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = SAT2D_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = SAT2D_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = SAT2D_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void SAT2D_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_17079a046eb6edaa_188_boot)
HXDLIN( 188)		tmp1 =  ::luxe::collision::data::ShapeCollision_obj::__alloc( HX_CTX );
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_17079a046eb6edaa_189_boot)
HXDLIN( 189)		tmp2 =  ::luxe::collision::data::ShapeCollision_obj::__alloc( HX_CTX );
            	}
}

} // end namespace luxe
} // end namespace collision
} // end namespace sat
