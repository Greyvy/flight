// Generated by Haxe 3.4.5
#include <hxcpp.h>

#ifndef INCLUDED_luxe_collision_data_RayCollision
#include <luxe/collision/data/RayCollision.h>
#endif
#ifndef INCLUDED_luxe_collision_data_ShapeCollision
#include <luxe/collision/data/ShapeCollision.h>
#endif
#ifndef INCLUDED_luxe_collision_sat_SAT2D
#include <luxe/collision/sat/SAT2D.h>
#endif
#ifndef INCLUDED_luxe_collision_shapes_Circle
#include <luxe/collision/shapes/Circle.h>
#endif
#ifndef INCLUDED_luxe_collision_shapes_Polygon
#include <luxe/collision/shapes/Polygon.h>
#endif
#ifndef INCLUDED_luxe_collision_shapes_Ray
#include <luxe/collision/shapes/Ray.h>
#endif
#ifndef INCLUDED_luxe_collision_shapes_Shape
#include <luxe/collision/shapes/Shape.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_5f0b5929bd4e205a_18_new,"luxe.collision.shapes.Circle","new",0xd9f4c42a,"luxe.collision.shapes.Circle.new","luxe/collision/shapes/Circle.hx",18,0x913b75a7)
HX_LOCAL_STACK_FRAME(_hx_pos_5f0b5929bd4e205a_29_test,"luxe.collision.shapes.Circle","test",0xe02e2548,"luxe.collision.shapes.Circle.test","luxe/collision/shapes/Circle.hx",29,0x913b75a7)
HX_LOCAL_STACK_FRAME(_hx_pos_5f0b5929bd4e205a_36_testCircle,"luxe.collision.shapes.Circle","testCircle",0x0d833178,"luxe.collision.shapes.Circle.testCircle","luxe/collision/shapes/Circle.hx",36,0x913b75a7)
HX_LOCAL_STACK_FRAME(_hx_pos_5f0b5929bd4e205a_43_testPolygon,"luxe.collision.shapes.Circle","testPolygon",0xe222be12,"luxe.collision.shapes.Circle.testPolygon","luxe/collision/shapes/Circle.hx",43,0x913b75a7)
HX_LOCAL_STACK_FRAME(_hx_pos_5f0b5929bd4e205a_50_testRay,"luxe.collision.shapes.Circle","testRay",0x954ce582,"luxe.collision.shapes.Circle.testRay","luxe/collision/shapes/Circle.hx",50,0x913b75a7)
HX_LOCAL_STACK_FRAME(_hx_pos_5f0b5929bd4e205a_58_get_radius,"luxe.collision.shapes.Circle","get_radius",0x3fffb991,"luxe.collision.shapes.Circle.get_radius","luxe/collision/shapes/Circle.hx",58,0x913b75a7)
HX_LOCAL_STACK_FRAME(_hx_pos_5f0b5929bd4e205a_64_get_transformedRadius,"luxe.collision.shapes.Circle","get_transformedRadius",0x598ed89e,"luxe.collision.shapes.Circle.get_transformedRadius","luxe/collision/shapes/Circle.hx",64,0x913b75a7)
namespace luxe{
namespace collision{
namespace shapes{

void Circle_obj::__construct(Float x,Float y,Float radius){
            	HX_STACKFRAME(&_hx_pos_5f0b5929bd4e205a_18_new)
HXLINE(  20)		super::__construct(x,y);
HXLINE(  21)		this->_radius = radius;
HXLINE(  22)		this->name = (HX_("circle ",10,5c,b6,f5) + this->_radius);
            	}

Dynamic Circle_obj::__CreateEmpty() { return new Circle_obj; }

void *Circle_obj::_hx_vtable = 0;

Dynamic Circle_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Circle_obj > _hx_result = new Circle_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

bool Circle_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x2003dd7f) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x2003dd7f;
	} else {
		return inClassId==(int)0x2070719e;
	}
}

 ::luxe::collision::data::ShapeCollision Circle_obj::test( ::luxe::collision::shapes::Shape shape, ::luxe::collision::data::ShapeCollision into){
            	HX_STACKFRAME(&_hx_pos_5f0b5929bd4e205a_29_test)
HXDLIN(  29)		return shape->testCircle(hx::ObjectPtr<OBJ_>(this),into,true);
            	}


 ::luxe::collision::data::ShapeCollision Circle_obj::testCircle( ::luxe::collision::shapes::Circle circle, ::luxe::collision::data::ShapeCollision into,hx::Null< bool >  __o_flip){
bool flip = __o_flip.Default(false);
            	HX_STACKFRAME(&_hx_pos_5f0b5929bd4e205a_36_testCircle)
HXDLIN(  36)		return ::luxe::collision::sat::SAT2D_obj::testCircleVsCircle(hx::ObjectPtr<OBJ_>(this),circle,into,flip);
            	}


 ::luxe::collision::data::ShapeCollision Circle_obj::testPolygon( ::luxe::collision::shapes::Polygon polygon, ::luxe::collision::data::ShapeCollision into,hx::Null< bool >  __o_flip){
bool flip = __o_flip.Default(false);
            	HX_STACKFRAME(&_hx_pos_5f0b5929bd4e205a_43_testPolygon)
HXDLIN(  43)		return ::luxe::collision::sat::SAT2D_obj::testCircleVsPolygon(hx::ObjectPtr<OBJ_>(this),polygon,into,flip);
            	}


 ::luxe::collision::data::RayCollision Circle_obj::testRay( ::luxe::collision::shapes::Ray ray, ::luxe::collision::data::RayCollision into){
            	HX_STACKFRAME(&_hx_pos_5f0b5929bd4e205a_50_testRay)
HXDLIN(  50)		return ::luxe::collision::sat::SAT2D_obj::testRayVsCircle(ray,hx::ObjectPtr<OBJ_>(this),into);
            	}


Float Circle_obj::get_radius(){
            	HX_STACKFRAME(&_hx_pos_5f0b5929bd4e205a_58_get_radius)
HXDLIN(  58)		return this->_radius;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Circle_obj,get_radius,return )

Float Circle_obj::get_transformedRadius(){
            	HX_STACKFRAME(&_hx_pos_5f0b5929bd4e205a_64_get_transformedRadius)
HXDLIN(  64)		return (this->_radius * this->_scaleX);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Circle_obj,get_transformedRadius,return )


hx::ObjectPtr< Circle_obj > Circle_obj::__new(Float x,Float y,Float radius) {
	hx::ObjectPtr< Circle_obj > __this = new Circle_obj();
	__this->__construct(x,y,radius);
	return __this;
}

hx::ObjectPtr< Circle_obj > Circle_obj::__alloc(hx::Ctx *_hx_ctx,Float x,Float y,Float radius) {
	Circle_obj *__this = (Circle_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Circle_obj), true, "luxe.collision.shapes.Circle"));
	*(void **)__this = Circle_obj::_hx_vtable;
	__this->__construct(x,y,radius);
	return __this;
}

Circle_obj::Circle_obj()
{
}

hx::Val Circle_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"test") ) { return hx::Val( test_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"radius") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_radius() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"_radius") ) { return hx::Val( _radius ); }
		if (HX_FIELD_EQ(inName,"testRay") ) { return hx::Val( testRay_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"testCircle") ) { return hx::Val( testCircle_dyn() ); }
		if (HX_FIELD_EQ(inName,"get_radius") ) { return hx::Val( get_radius_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"testPolygon") ) { return hx::Val( testPolygon_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"transformedRadius") ) { if (inCallProp == hx::paccAlways) return hx::Val( get_transformedRadius() ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"get_transformedRadius") ) { return hx::Val( get_transformedRadius_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Circle_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"_radius") ) { _radius=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Circle_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("radius","\x52","\xd0","\xf6","\xb0"));
	outFields->push(HX_HCSTRING("transformedRadius","\x7d","\x27","\xb5","\xb2"));
	outFields->push(HX_HCSTRING("_radius","\xf1","\xe1","\x6d","\x1f"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Circle_obj_sMemberStorageInfo[] = {
	{hx::fsFloat,(int)offsetof(Circle_obj,_radius),HX_HCSTRING("_radius","\xf1","\xe1","\x6d","\x1f")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Circle_obj_sStaticStorageInfo = 0;
#endif

static ::String Circle_obj_sMemberFields[] = {
	HX_HCSTRING("_radius","\xf1","\xe1","\x6d","\x1f"),
	HX_HCSTRING("test","\x52","\xc8","\xf9","\x4c"),
	HX_HCSTRING("testCircle","\x02","\xb8","\x01","\x6f"),
	HX_HCSTRING("testPolygon","\x48","\xf0","\x59","\xcf"),
	HX_HCSTRING("testRay","\xb8","\x44","\xc5","\xbd"),
	HX_HCSTRING("get_radius","\x1b","\x40","\x7e","\xa1"),
	HX_HCSTRING("get_transformedRadius","\x54","\x2a","\x63","\x31"),
	::String(null()) };

static void Circle_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Circle_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Circle_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Circle_obj::__mClass,"__mClass");
};

#endif

hx::Class Circle_obj::__mClass;

void Circle_obj::__register()
{
	hx::Object *dummy = new Circle_obj;
	Circle_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("luxe.collision.shapes.Circle","\x38","\x27","\xa9","\x53");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Circle_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Circle_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Circle_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Circle_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Circle_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Circle_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace luxe
} // end namespace collision
} // end namespace shapes
