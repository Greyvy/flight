// Generated by Haxe 3.4.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_luxe_collision_ShapeDrawer
#include <luxe/collision/ShapeDrawer.h>
#endif
#ifndef INCLUDED_luxe_collision_data_ShapeCollision
#include <luxe/collision/data/ShapeCollision.h>
#endif
#ifndef INCLUDED_luxe_collision_shapes_Circle
#include <luxe/collision/shapes/Circle.h>
#endif
#ifndef INCLUDED_luxe_collision_shapes_Polygon
#include <luxe/collision/shapes/Polygon.h>
#endif
#ifndef INCLUDED_luxe_collision_shapes_Shape
#include <luxe/collision/shapes/Shape.h>
#endif
#ifndef INCLUDED_phoenix_Vector
#include <phoenix/Vector.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_e9c50222ce0f5d60_13_new,"luxe.collision.ShapeDrawer","new",0xca2c2290,"luxe.collision.ShapeDrawer.new","luxe/collision/ShapeDrawer.hx",13,0xa5ce39a2)
HX_LOCAL_STACK_FRAME(_hx_pos_e9c50222ce0f5d60_18_drawLine,"luxe.collision.ShapeDrawer","drawLine",0x57fc81e8,"luxe.collision.ShapeDrawer.drawLine","luxe/collision/ShapeDrawer.hx",18,0xa5ce39a2)
HX_LOCAL_STACK_FRAME(_hx_pos_e9c50222ce0f5d60_25_drawShape,"luxe.collision.ShapeDrawer","drawShape",0xac102ead,"luxe.collision.ShapeDrawer.drawShape","luxe/collision/ShapeDrawer.hx",25,0xa5ce39a2)
HX_LOCAL_STACK_FRAME(_hx_pos_e9c50222ce0f5d60_36_drawPolygon,"luxe.collision.ShapeDrawer","drawPolygon",0x9e974906,"luxe.collision.ShapeDrawer.drawPolygon","luxe/collision/ShapeDrawer.hx",36,0xa5ce39a2)
HX_LOCAL_STACK_FRAME(_hx_pos_e9c50222ce0f5d60_41_drawCircle,"luxe.collision.ShapeDrawer","drawCircle",0x1afc4104,"luxe.collision.ShapeDrawer.drawCircle","luxe/collision/ShapeDrawer.hx",41,0xa5ce39a2)
HX_LOCAL_STACK_FRAME(_hx_pos_e9c50222ce0f5d60_82_drawPoint,"luxe.collision.ShapeDrawer","drawPoint",0xf682ffdc,"luxe.collision.ShapeDrawer.drawPoint","luxe/collision/ShapeDrawer.hx",82,0xa5ce39a2)
HX_LOCAL_STACK_FRAME(_hx_pos_e9c50222ce0f5d60_99_drawShapeCollision,"luxe.collision.ShapeDrawer","drawShapeCollision",0x22da9c05,"luxe.collision.ShapeDrawer.drawShapeCollision","luxe/collision/ShapeDrawer.hx",99,0xa5ce39a2)
HX_LOCAL_STACK_FRAME(_hx_pos_e9c50222ce0f5d60_126_drawVertList,"luxe.collision.ShapeDrawer","drawVertList",0x50669da3,"luxe.collision.ShapeDrawer.drawVertList","luxe/collision/ShapeDrawer.hx",126,0xa5ce39a2)
namespace luxe{
namespace collision{

void ShapeDrawer_obj::__construct(){
            	HX_STACKFRAME(&_hx_pos_e9c50222ce0f5d60_13_new)
            	}

Dynamic ShapeDrawer_obj::__CreateEmpty() { return new ShapeDrawer_obj; }

void *ShapeDrawer_obj::_hx_vtable = 0;

Dynamic ShapeDrawer_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< ShapeDrawer_obj > _hx_result = new ShapeDrawer_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool ShapeDrawer_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x64773956;
}

void ShapeDrawer_obj::drawLine(Float p0x,Float p0y,Float p1x,Float p1y, ::Dynamic __o_startPoint){
 ::Dynamic startPoint = __o_startPoint.Default(true);
            	HX_STACKFRAME(&_hx_pos_e9c50222ce0f5d60_18_drawLine)
            	}


HX_DEFINE_DYNAMIC_FUNC5(ShapeDrawer_obj,drawLine,(void))

void ShapeDrawer_obj::drawShape( ::luxe::collision::shapes::Shape shape){
            	HX_STACKFRAME(&_hx_pos_e9c50222ce0f5d60_25_drawShape)
HXDLIN(  25)		if (::Std_obj::is(shape,hx::ClassOf< ::luxe::collision::shapes::Polygon >())) {
HXLINE(  26)			this->drawPolygon(( ( ::luxe::collision::shapes::Polygon)(shape) ));
            		}
            		else {
HXLINE(  28)			this->drawCircle(( ( ::luxe::collision::shapes::Circle)(shape) ));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(ShapeDrawer_obj,drawShape,(void))

void ShapeDrawer_obj::drawPolygon( ::luxe::collision::shapes::Polygon poly){
            	HX_STACKFRAME(&_hx_pos_e9c50222ce0f5d60_36_drawPolygon)
HXDLIN(  36)		this->drawVertList(poly->get_transformedVertices());
            	}


HX_DEFINE_DYNAMIC_FUNC1(ShapeDrawer_obj,drawPolygon,(void))

void ShapeDrawer_obj::drawCircle( ::luxe::collision::shapes::Circle circle){
            	HX_GC_STACKFRAME(&_hx_pos_e9c50222ce0f5d60_41_drawCircle)
HXLINE(  45)		Float _smooth = (int)10;
HXLINE(  46)		int _steps = ::Std_obj::_hx_int((_smooth * ::Math_obj::sqrt(circle->get_transformedRadius())));
HXLINE(  49)		Float theta = ((Float)((Float)6.2831852) / (Float)_steps);
HXLINE(  51)		Float tangential_factor = ::Math_obj::tan(theta);
HXLINE(  52)		Float radial_factor = ::Math_obj::cos(theta);
HXLINE(  54)		Float x = circle->get_transformedRadius();
HXLINE(  55)		Float y = (int)0;
HXLINE(  57)		::Array< ::Dynamic> _verts = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  59)		{
HXLINE(  59)			int _g1 = (int)0;
HXDLIN(  59)			int _g = _steps;
HXDLIN(  59)			while((_g1 < _g)){
HXLINE(  59)				_g1 = (_g1 + (int)1);
HXDLIN(  59)				int i = (_g1 - (int)1);
HXLINE(  61)				Float _hx___x = (x + circle->_position->x);
HXLINE(  62)				Float _hx___y = (y + circle->_position->y);
HXLINE(  64)				_verts->push( ::phoenix::Vector_obj::__alloc( HX_CTX ,_hx___x,_hx___y,null(),null()));
HXLINE(  66)				Float tx = -(y);
HXLINE(  67)				Float ty = x;
HXLINE(  69)				x = (x + (tx * tangential_factor));
HXLINE(  70)				y = (y + (ty * tangential_factor));
HXLINE(  72)				x = (x * radial_factor);
HXLINE(  73)				y = (y * radial_factor);
            			}
            		}
HXLINE(  78)		this->drawVertList(_verts);
            	}


HX_DEFINE_DYNAMIC_FUNC1(ShapeDrawer_obj,drawCircle,(void))

void ShapeDrawer_obj::drawPoint(Float x,Float y,hx::Null< Float >  __o_size){
Float size = __o_size.Default(4);
            	HX_STACKFRAME(&_hx_pos_e9c50222ce0f5d60_82_drawPoint)
HXLINE(  84)		Float xs = (x - size);
HXLINE(  85)		Float xe = (x + size);
HXLINE(  86)		Float ys = y;
HXLINE(  87)		Float ye = y;
HXLINE(  89)		this->drawLine(xs,ys,xe,ye,null());
HXLINE(  91)		xe = x;
HXDLIN(  91)		xs = xe;
HXLINE(  92)		ys = (y - size);
HXLINE(  93)		ye = (y + size);
HXLINE(  95)		this->drawLine(xs,ys,xe,ye,null());
            	}


HX_DEFINE_DYNAMIC_FUNC3(ShapeDrawer_obj,drawPoint,(void))

void ShapeDrawer_obj::drawShapeCollision( ::luxe::collision::data::ShapeCollision c, ::Dynamic __o_length){
 ::Dynamic length = __o_length.Default(30);
            	HX_STACKFRAME(&_hx_pos_e9c50222ce0f5d60_99_drawShapeCollision)
HXLINE( 103)		this->drawPoint(c->shape1->_position->x,c->shape1->_position->y,null());
HXLINE( 104)		this->drawPoint(c->shape2->_position->x,c->shape2->_position->y,null());
HXLINE( 108)		Float _hx_tmp = c->shape1->_position->x;
HXDLIN( 108)		Float _hx_tmp1 = c->shape1->_position->y;
HXDLIN( 108)		Float _hx_tmp2 = c->shape1->_position->x;
HXDLIN( 108)		Float _hx_tmp3 = (_hx_tmp2 + (c->unitVectorX * length));
HXDLIN( 108)		Float _hx_tmp4 = c->shape1->_position->y;
HXDLIN( 108)		this->drawLine(_hx_tmp,_hx_tmp1,_hx_tmp3,(_hx_tmp4 + (c->unitVectorY * length)),null());
HXLINE( 112)		Float _hx_tmp5 = (c->shape1->_position->x + c->separationX);
HXDLIN( 112)		this->drawPoint(_hx_tmp5,(c->shape1->_position->y + c->separationY),null());
HXLINE( 114)		if ((c->otherOverlap != ((Float)0.0))) {
HXLINE( 115)			Float _hx_tmp6 = c->shape1->_position->x;
HXDLIN( 115)			Float _hx_tmp7 = c->shape1->_position->y;
HXDLIN( 115)			Float _hx_tmp8 = c->shape1->_position->x;
HXDLIN( 115)			Float _hx_tmp9 = (_hx_tmp8 + (c->otherUnitVectorX * length));
HXDLIN( 115)			Float _hx_tmp10 = c->shape1->_position->y;
HXDLIN( 115)			this->drawLine(_hx_tmp6,_hx_tmp7,_hx_tmp9,(_hx_tmp10 + (c->otherUnitVectorY * length)),null());
HXLINE( 116)			Float _hx_tmp11 = (c->shape1->_position->x + c->otherSeparationX);
HXDLIN( 116)			this->drawPoint(_hx_tmp11,(c->shape1->_position->y + c->otherSeparationY),null());
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(ShapeDrawer_obj,drawShapeCollision,(void))

void ShapeDrawer_obj::drawVertList(::Array< ::Dynamic> _verts){
            	HX_STACKFRAME(&_hx_pos_e9c50222ce0f5d60_126_drawVertList)
HXLINE( 128)		int _count = _verts->length;
HXLINE( 130)		if ((_count == (int)2)) {
HXLINE( 131)			this->drawLine(_verts->__get((int)0).StaticCast<  ::phoenix::Vector >()->x,_verts->__get((int)0).StaticCast<  ::phoenix::Vector >()->y,_verts->__get((int)1).StaticCast<  ::phoenix::Vector >()->x,_verts->__get((int)1).StaticCast<  ::phoenix::Vector >()->y,true);
HXLINE( 132)			return;
            		}
HXLINE( 135)		if ((_count == (int)1)) {
HXLINE( 136)			this->drawPoint(_verts->__get((int)0).StaticCast<  ::phoenix::Vector >()->x,_verts->__get((int)0).StaticCast<  ::phoenix::Vector >()->y,null());
HXLINE( 137)			return;
            		}
HXLINE( 141)		this->drawLine(_verts->__get((int)0).StaticCast<  ::phoenix::Vector >()->x,_verts->__get((int)0).StaticCast<  ::phoenix::Vector >()->y,_verts->__get((int)1).StaticCast<  ::phoenix::Vector >()->x,_verts->__get((int)1).StaticCast<  ::phoenix::Vector >()->y,true);
HXLINE( 144)		{
HXLINE( 144)			int _g1 = (int)1;
HXDLIN( 144)			int _g = (_count - (int)1);
HXDLIN( 144)			while((_g1 < _g)){
HXLINE( 144)				_g1 = (_g1 + (int)1);
HXDLIN( 144)				int i = (_g1 - (int)1);
HXLINE( 145)				this->drawLine(_verts->__get(i).StaticCast<  ::phoenix::Vector >()->x,_verts->__get(i).StaticCast<  ::phoenix::Vector >()->y,_verts->__get((i + (int)1)).StaticCast<  ::phoenix::Vector >()->x,_verts->__get((i + (int)1)).StaticCast<  ::phoenix::Vector >()->y,false);
            			}
            		}
HXLINE( 148)		this->drawLine(_verts->__get((_count - (int)1)).StaticCast<  ::phoenix::Vector >()->x,_verts->__get((_count - (int)1)).StaticCast<  ::phoenix::Vector >()->y,_verts->__get((int)0).StaticCast<  ::phoenix::Vector >()->x,_verts->__get((int)0).StaticCast<  ::phoenix::Vector >()->y,false);
            	}


HX_DEFINE_DYNAMIC_FUNC1(ShapeDrawer_obj,drawVertList,(void))


hx::ObjectPtr< ShapeDrawer_obj > ShapeDrawer_obj::__new() {
	hx::ObjectPtr< ShapeDrawer_obj > __this = new ShapeDrawer_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< ShapeDrawer_obj > ShapeDrawer_obj::__alloc(hx::Ctx *_hx_ctx) {
	ShapeDrawer_obj *__this = (ShapeDrawer_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(ShapeDrawer_obj), false, "luxe.collision.ShapeDrawer"));
	*(void **)__this = ShapeDrawer_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

ShapeDrawer_obj::ShapeDrawer_obj()
{
}

hx::Val ShapeDrawer_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"drawLine") ) { return hx::Val( drawLine_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"drawShape") ) { return hx::Val( drawShape_dyn() ); }
		if (HX_FIELD_EQ(inName,"drawPoint") ) { return hx::Val( drawPoint_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"drawCircle") ) { return hx::Val( drawCircle_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"drawPolygon") ) { return hx::Val( drawPolygon_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"drawVertList") ) { return hx::Val( drawVertList_dyn() ); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"drawShapeCollision") ) { return hx::Val( drawShapeCollision_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *ShapeDrawer_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *ShapeDrawer_obj_sStaticStorageInfo = 0;
#endif

static ::String ShapeDrawer_obj_sMemberFields[] = {
	HX_HCSTRING("drawLine","\x18","\xc2","\x1c","\x5c"),
	HX_HCSTRING("drawShape","\x7d","\x18","\x28","\x44"),
	HX_HCSTRING("drawPolygon","\xd6","\x46","\xd9","\x5b"),
	HX_HCSTRING("drawCircle","\x34","\xed","\xd0","\x97"),
	HX_HCSTRING("drawPoint","\xac","\xe9","\x9a","\x8e"),
	HX_HCSTRING("drawShapeCollision","\x35","\xf8","\x7e","\x53"),
	HX_HCSTRING("drawVertList","\xd3","\xb5","\xe2","\x2c"),
	::String(null()) };

static void ShapeDrawer_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(ShapeDrawer_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void ShapeDrawer_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(ShapeDrawer_obj::__mClass,"__mClass");
};

#endif

hx::Class ShapeDrawer_obj::__mClass;

void ShapeDrawer_obj::__register()
{
	hx::Object *dummy = new ShapeDrawer_obj;
	ShapeDrawer_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("luxe.collision.ShapeDrawer","\x9e","\xda","\x2b","\x66");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = ShapeDrawer_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(ShapeDrawer_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< ShapeDrawer_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = ShapeDrawer_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ShapeDrawer_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ShapeDrawer_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace luxe
} // end namespace collision
