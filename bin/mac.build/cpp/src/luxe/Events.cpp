// Generated by Haxe 3.4.5
#include <hxcpp.h>

#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_Luxe
#include <Luxe.h>
#endif
#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_luxe_Events
#include <luxe/Events.h>
#endif
#ifndef INCLUDED_luxe_Timer
#include <luxe/Timer.h>
#endif
#ifndef INCLUDED_luxe__Events_EventConnection
#include <luxe/_Events/EventConnection.h>
#endif
#ifndef INCLUDED_luxe__Events_EventObject
#include <luxe/_Events/EventObject.h>
#endif
#ifndef INCLUDED_luxe_utils_Utils
#include <luxe/utils/Utils.h>
#endif
#ifndef INCLUDED_snow_api_Timer
#include <snow/api/Timer.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_72d0ab454a963b47_13_new,"luxe.Events","new",0xd3c5ce63,"luxe.Events.new","luxe/Events.hx",13,0xab6dc64c)
HX_LOCAL_STACK_FRAME(_hx_pos_72d0ab454a963b47_38_destroy,"luxe.Events","destroy",0x8602e87d,"luxe.Events.destroy","luxe/Events.hx",38,0xab6dc64c)
HX_LOCAL_STACK_FRAME(_hx_pos_72d0ab454a963b47_43_clear,"luxe.Events","clear",0x5acb3650,"luxe.Events.clear","luxe/Events.hx",43,0xab6dc64c)
HX_LOCAL_STACK_FRAME(_hx_pos_72d0ab454a963b47_71_does_filter_event,"luxe.Events","does_filter_event",0xeac610dc,"luxe.Events.does_filter_event","luxe/Events.hx",71,0xab6dc64c)
HX_LOCAL_STACK_FRAME(_hx_pos_72d0ab454a963b47_85_listen,"luxe.Events","listen",0xff562e24,"luxe.Events.listen","luxe/Events.hx",85,0xab6dc64c)
HX_LOCAL_STACK_FRAME(_hx_pos_72d0ab454a963b47_132_unlisten,"luxe.Events","unlisten",0xdde84e7d,"luxe.Events.unlisten","luxe/Events.hx",132,0xab6dc64c)
HX_LOCAL_STACK_FRAME(_hx_pos_72d0ab454a963b47_162_queue,"luxe.Events","queue",0x705a5254,"luxe.Events.queue","luxe/Events.hx",162,0xab6dc64c)
HX_LOCAL_STACK_FRAME(_hx_pos_72d0ab454a963b47_173_dequeue,"luxe.Events","dequeue",0x5fd51df3,"luxe.Events.dequeue","luxe/Events.hx",173,0xab6dc64c)
HX_LOCAL_STACK_FRAME(_hx_pos_72d0ab454a963b47_195_process,"luxe.Events","process",0x52c75df2,"luxe.Events.process","luxe/Events.hx",195,0xab6dc64c)
HX_LOCAL_STACK_FRAME(_hx_pos_72d0ab454a963b47_212_fire,"luxe.Events","fire",0x74081853,"luxe.Events.fire","luxe/Events.hx",212,0xab6dc64c)
HX_LOCAL_STACK_FRAME(_hx_pos_72d0ab454a963b47_269_schedule,"luxe.Events","schedule",0xb1262174,"luxe.Events.schedule","luxe/Events.hx",269,0xab6dc64c)
HX_LOCAL_STACK_FRAME(_hx_pos_72d0ab454a963b47_265_schedule,"luxe.Events","schedule",0xb1262174,"luxe.Events.schedule","luxe/Events.hx",265,0xab6dc64c)
HX_LOCAL_STACK_FRAME(_hx_pos_72d0ab454a963b47_280_unschedule,"luxe.Events","unschedule",0xf0c3ca0d,"luxe.Events.unschedule","luxe/Events.hx",280,0xab6dc64c)
HX_LOCAL_STACK_FRAME(_hx_pos_72d0ab454a963b47_299_tag_properties,"luxe.Events","tag_properties",0x704843d5,"luxe.Events.tag_properties","luxe/Events.hx",299,0xab6dc64c)
namespace luxe{

void Events_obj::__construct(){
            	HX_GC_STACKFRAME(&_hx_pos_72d0ab454a963b47_13_new)
HXLINE(  21)		this->event_queue_count = (int)0;
HXLINE(  27)		this->event_connections =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE(  28)		this->event_slots =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE(  29)		this->event_filters =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXLINE(  30)		this->event_queue = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  31)		this->event_schedules =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
            	}

Dynamic Events_obj::__CreateEmpty() { return new Events_obj; }

void *Events_obj::_hx_vtable = 0;

Dynamic Events_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Events_obj > _hx_result = new Events_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool Events_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x2ad967af;
}

void Events_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_72d0ab454a963b47_38_destroy)
HXDLIN(  38)		this->clear();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Events_obj,destroy,(void))

void Events_obj::clear(){
            	HX_STACKFRAME(&_hx_pos_72d0ab454a963b47_43_clear)
HXLINE(  45)		{
HXLINE(  45)			 ::Dynamic schedule = this->event_schedules->iterator();
HXDLIN(  45)			while(( (bool)(schedule->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE(  45)				 ::snow::api::Timer schedule1 = ( ( ::snow::api::Timer)(schedule->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE(  46)				schedule1->stop();
HXLINE(  47)				schedule1 = null();
            			}
            		}
HXLINE(  50)		{
HXLINE(  50)			 ::Dynamic connection = this->event_connections->keys();
HXDLIN(  50)			while(( (bool)(connection->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE(  50)				::String connection1 = ( (::String)(connection->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE(  51)				this->event_connections->remove(connection1);
            			}
            		}
HXLINE(  54)		{
HXLINE(  54)			 ::Dynamic filter = this->event_filters->keys();
HXDLIN(  54)			while(( (bool)(filter->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE(  54)				::String filter1 = ( (::String)(filter->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE(  55)				this->event_filters->remove(filter1);
            			}
            		}
HXLINE(  58)		{
HXLINE(  58)			 ::Dynamic slot = this->event_slots->keys();
HXDLIN(  58)			while(( (bool)(slot->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE(  58)				::String slot1 = ( (::String)(slot->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE(  59)				this->event_slots->remove(slot1);
            			}
            		}
HXLINE(  62)		int _count = this->event_queue->length;
HXLINE(  63)		while((_count > (int)0)){
HXLINE(  64)			this->event_queue->pop().StaticCast<  ::luxe::_Events::EventObject >();
HXLINE(  65)			_count = (_count - (int)1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Events_obj,clear,(void))

bool Events_obj::does_filter_event(::String _filter,::String _event){
            	HX_GC_STACKFRAME(&_hx_pos_72d0ab454a963b47_71_does_filter_event)
HXLINE(  73)		 ::EReg _replace_stars =  ::EReg_obj::__alloc( HX_CTX ,HX_("\\*",4e,50,00,00),HX_("gi",22,5a,00,00));
HXLINE(  74)		::String _final_filter = _replace_stars->replace(_filter,HX_(".*?",83,0c,23,00));
HXLINE(  75)		 ::EReg _final_search =  ::EReg_obj::__alloc( HX_CTX ,_final_filter,HX_("gi",22,5a,00,00));
HXLINE(  77)		return _final_search->match(_event);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Events_obj,does_filter_event,return )

::String Events_obj::listen(::String _event_name, ::Dynamic _listener){
            	HX_GC_STACKFRAME(&_hx_pos_72d0ab454a963b47_85_listen)
HXLINE(  88)		::String _id = ::Luxe_obj::utils->uniqueid(null());
HXLINE(  89)		 ::luxe::_Events::EventConnection _connection =  ::luxe::_Events::EventConnection_obj::__alloc( HX_CTX ,_id,_event_name,_listener);
HXLINE(  92)		this->event_connections->set(_id,_connection);
HXLINE(  97)		 ::EReg _has_stars =  ::EReg_obj::__alloc( HX_CTX ,HX_("\\*",4e,50,00,00),HX_("gi",22,5a,00,00));
HXLINE(  98)		if (_has_stars->match(_event_name)) {
HXLINE( 101)			if (!(this->event_filters->exists(_event_name))) {
HXLINE( 103)				this->event_filters->set(_event_name,::Array_obj< ::Dynamic>::__new(0));
            			}
HXLINE( 107)			( (::Array< ::Dynamic>)(this->event_filters->get(_event_name)) )->push(_connection);
            		}
            		else {
HXLINE( 112)			if (!(this->event_slots->exists(_event_name))) {
HXLINE( 114)				this->event_slots->set(_event_name,::Array_obj< ::Dynamic>::__new(0));
            			}
HXLINE( 118)			( (::Array< ::Dynamic>)(this->event_slots->get(_event_name)) )->push(_connection);
            		}
HXLINE( 123)		return _id;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Events_obj,listen,return )

bool Events_obj::unlisten(::String event_id){
            	HX_STACKFRAME(&_hx_pos_72d0ab454a963b47_132_unlisten)
HXDLIN( 132)		if (this->event_connections->exists(event_id)) {
HXLINE( 134)			 ::luxe::_Events::EventConnection _connection = this->event_connections->get(event_id).StaticCast<  ::luxe::_Events::EventConnection >();
HXLINE( 135)			::Array< ::Dynamic> _event_slot = ( (::Array< ::Dynamic>)(this->event_slots->get(_connection->event_name)) );
HXLINE( 137)			if (hx::IsNotNull( _event_slot )) {
HXLINE( 138)				_event_slot->remove(_connection);
HXLINE( 139)				return true;
            			}
            			else {
HXLINE( 141)				::Array< ::Dynamic> _event_filter = ( (::Array< ::Dynamic>)(this->event_filters->get(_connection->event_name)) );
HXLINE( 142)				if (hx::IsNotNull( _event_filter )) {
HXLINE( 143)					_event_filter->remove(_connection);
HXLINE( 144)					return true;
            				}
            				else {
HXLINE( 146)					return false;
            				}
            			}
            		}
            		else {
HXLINE( 153)			return false;
            		}
HXLINE( 132)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Events_obj,unlisten,return )

::String Events_obj::queue(::String event_name, ::Dynamic properties){
            	HX_GC_STACKFRAME(&_hx_pos_72d0ab454a963b47_162_queue)
HXLINE( 164)		::String _id = ::Luxe_obj::utils->uniqueid(null());
HXLINE( 166)		::Array< ::Dynamic> _hx_tmp = this->event_queue;
HXDLIN( 166)		_hx_tmp->push( ::luxe::_Events::EventObject_obj::__alloc( HX_CTX ,_id,event_name,properties));
HXLINE( 168)		return _id;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Events_obj,queue,return )

bool Events_obj::dequeue(::String event_id){
            	HX_STACKFRAME(&_hx_pos_72d0ab454a963b47_173_dequeue)
HXLINE( 176)		int _idx = (int)0;
HXLINE( 177)		int _count = this->event_queue->length;
HXLINE( 178)		while(true){
HXLINE( 180)			if ((this->event_queue->__get(_idx).StaticCast<  ::luxe::_Events::EventObject >()->id == event_id)) {
HXLINE( 181)				this->event_queue->removeRange(_idx,(int)1);
HXLINE( 182)				return true;
            			}
HXLINE( 185)			_idx = (_idx + (int)1);
HXLINE( 178)			if (!((_idx < _count))) {
HXLINE( 178)				goto _hx_goto_12;
            			}
            		}
            		_hx_goto_12:;
HXLINE( 189)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Events_obj,dequeue,return )

void Events_obj::process(){
            	HX_STACKFRAME(&_hx_pos_72d0ab454a963b47_195_process)
HXLINE( 198)		int _count = this->event_queue->length;
HXLINE( 199)		while((_count > (int)0)){
HXLINE( 200)			 ::luxe::_Events::EventObject _event = this->event_queue->shift().StaticCast<  ::luxe::_Events::EventObject >();
HXLINE( 201)			this->fire(_event->name,_event->properties,null());
HXLINE( 202)			_count = (_count - (int)1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Events_obj,process,(void))

bool Events_obj::fire(::String _event_name, ::Dynamic _properties, ::Dynamic __o__tag){
 ::Dynamic _tag = __o__tag.Default(false);
            	HX_STACKFRAME(&_hx_pos_72d0ab454a963b47_212_fire)
HXLINE( 214)		bool _fired = false;
HXLINE( 217)		{
HXLINE( 217)			 ::Dynamic _filter = this->event_filters->iterator();
HXDLIN( 217)			while(( (bool)(_filter->__Field(HX_("hasNext",6d,a5,46,18),hx::paccDynamic)()) )){
HXLINE( 217)				::Array< ::Dynamic> _filter1 = ( (::Array< ::Dynamic>)(_filter->__Field(HX_("next",f3,84,02,49),hx::paccDynamic)()) );
HXLINE( 219)				if ((_filter1->length > (int)0)) {
HXLINE( 221)					::String _filter_name = _filter1->__get((int)0).StaticCast<  ::luxe::_Events::EventConnection >()->event_name;
HXLINE( 222)					if (this->does_filter_event(_filter_name,_event_name)) {
HXLINE( 224)						if (_tag) {
HXLINE( 225)							_properties = this->tag_properties(_properties,_event_name,_filter1->length);
            						}
HXLINE( 228)						{
HXLINE( 228)							int _g = (int)0;
HXDLIN( 228)							while((_g < _filter1->length)){
HXLINE( 228)								 ::luxe::_Events::EventConnection _connection = _filter1->__get(_g).StaticCast<  ::luxe::_Events::EventConnection >();
HXDLIN( 228)								_g = (_g + (int)1);
HXLINE( 229)								_connection->listener(_properties);
            							}
            						}
HXLINE( 232)						_fired = true;
            					}
            				}
            			}
            		}
HXLINE( 239)		if (this->event_slots->exists(_event_name)) {
HXLINE( 242)			::Array< ::Dynamic> _connections = ( (::Array< ::Dynamic>)(this->event_slots->get(_event_name)) );
HXLINE( 244)			if (_tag) {
HXLINE( 245)				_properties = this->tag_properties(_properties,_event_name,_connections->length);
            			}
HXLINE( 249)			{
HXLINE( 249)				int _g1 = (int)0;
HXDLIN( 249)				while((_g1 < _connections->length)){
HXLINE( 249)					 ::luxe::_Events::EventConnection connection = _connections->__get(_g1).StaticCast<  ::luxe::_Events::EventConnection >();
HXDLIN( 249)					_g1 = (_g1 + (int)1);
HXLINE( 250)					connection->listener(_properties);
            				}
            			}
HXLINE( 253)			_fired = true;
            		}
HXLINE( 257)		return _fired;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Events_obj,fire,return )

::String Events_obj::schedule(Float time,::String event_name, ::Dynamic properties){
            		HX_BEGIN_LOCAL_FUNC_S3(hx::LocalFunc,_hx_Closure_0, ::Dynamic,a2, ::Dynamic,f,::String,a1) HXARGC(0)
            		bool _hx_run(){
            			HX_STACKFRAME(&_hx_pos_72d0ab454a963b47_269_schedule)
HXLINE( 269)			return ( (bool)(f(a1,a2,null())) );
            		}
            		HX_END_LOCAL_FUNC0(return)

            	HX_STACKFRAME(&_hx_pos_72d0ab454a963b47_265_schedule)
HXLINE( 267)		::String _id = ::Luxe_obj::utils->uniqueid(null());
HXLINE( 269)		 ::Dynamic f = this->fire_dyn();
HXDLIN( 269)		::String a1 = event_name;
HXDLIN( 269)		 ::Dynamic a2 = properties;
HXDLIN( 269)		 ::Dynamic _timer =  ::Dynamic(new _hx_Closure_0(a2,f,a1));
HXDLIN( 269)		 ::snow::api::Timer _timer1 = ::Luxe_obj::timer->schedule(time,_timer,null());
HXLINE( 271)		this->event_schedules->set(_id,_timer1);
HXLINE( 273)		return _id;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Events_obj,schedule,return )

bool Events_obj::unschedule(::String schedule_id){
            	HX_STACKFRAME(&_hx_pos_72d0ab454a963b47_280_unschedule)
HXLINE( 282)		if (this->event_schedules->exists(schedule_id)) {
HXLINE( 284)			 ::snow::api::Timer _timer = this->event_schedules->get(schedule_id).StaticCast<  ::snow::api::Timer >();
HXLINE( 286)			_timer->stop();
HXLINE( 288)			this->event_schedules->remove(schedule_id);
HXLINE( 290)			return true;
            		}
HXLINE( 293)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Events_obj,unschedule,return )

 ::Dynamic Events_obj::tag_properties( ::Dynamic _properties,::String _name,int _count){
            	HX_STACKFRAME(&_hx_pos_72d0ab454a963b47_299_tag_properties)
HXLINE( 301)		if (hx::IsNull( _properties )) {
HXLINE( 301)			_properties =  ::Dynamic(hx::Anon_obj::Create(0));
            		}
HXLINE( 304)		::Reflect_obj::setField(_properties,HX_("_event_name_",90,5c,2e,17),_name);
HXLINE( 306)		::Reflect_obj::setField(_properties,HX_("_event_connection_count_",cd,68,f2,d6),_count);
HXLINE( 308)		return _properties;
            	}


HX_DEFINE_DYNAMIC_FUNC3(Events_obj,tag_properties,return )


hx::ObjectPtr< Events_obj > Events_obj::__new() {
	hx::ObjectPtr< Events_obj > __this = new Events_obj();
	__this->__construct();
	return __this;
}

hx::ObjectPtr< Events_obj > Events_obj::__alloc(hx::Ctx *_hx_ctx) {
	Events_obj *__this = (Events_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Events_obj), true, "luxe.Events"));
	*(void **)__this = Events_obj::_hx_vtable;
	__this->__construct();
	return __this;
}

Events_obj::Events_obj()
{
}

void Events_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Events);
	HX_MARK_MEMBER_NAME(event_queue,"event_queue");
	HX_MARK_MEMBER_NAME(event_connections,"event_connections");
	HX_MARK_MEMBER_NAME(event_slots,"event_slots");
	HX_MARK_MEMBER_NAME(event_filters,"event_filters");
	HX_MARK_MEMBER_NAME(event_schedules,"event_schedules");
	HX_MARK_MEMBER_NAME(event_queue_count,"event_queue_count");
	HX_MARK_END_CLASS();
}

void Events_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(event_queue,"event_queue");
	HX_VISIT_MEMBER_NAME(event_connections,"event_connections");
	HX_VISIT_MEMBER_NAME(event_slots,"event_slots");
	HX_VISIT_MEMBER_NAME(event_filters,"event_filters");
	HX_VISIT_MEMBER_NAME(event_schedules,"event_schedules");
	HX_VISIT_MEMBER_NAME(event_queue_count,"event_queue_count");
}

hx::Val Events_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"fire") ) { return hx::Val( fire_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"clear") ) { return hx::Val( clear_dyn() ); }
		if (HX_FIELD_EQ(inName,"queue") ) { return hx::Val( queue_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"listen") ) { return hx::Val( listen_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"destroy") ) { return hx::Val( destroy_dyn() ); }
		if (HX_FIELD_EQ(inName,"dequeue") ) { return hx::Val( dequeue_dyn() ); }
		if (HX_FIELD_EQ(inName,"process") ) { return hx::Val( process_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"unlisten") ) { return hx::Val( unlisten_dyn() ); }
		if (HX_FIELD_EQ(inName,"schedule") ) { return hx::Val( schedule_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"unschedule") ) { return hx::Val( unschedule_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"event_queue") ) { return hx::Val( event_queue ); }
		if (HX_FIELD_EQ(inName,"event_slots") ) { return hx::Val( event_slots ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"event_filters") ) { return hx::Val( event_filters ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"tag_properties") ) { return hx::Val( tag_properties_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"event_schedules") ) { return hx::Val( event_schedules ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"event_connections") ) { return hx::Val( event_connections ); }
		if (HX_FIELD_EQ(inName,"event_queue_count") ) { return hx::Val( event_queue_count ); }
		if (HX_FIELD_EQ(inName,"does_filter_event") ) { return hx::Val( does_filter_event_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Events_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 11:
		if (HX_FIELD_EQ(inName,"event_queue") ) { event_queue=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		if (HX_FIELD_EQ(inName,"event_slots") ) { event_slots=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"event_filters") ) { event_filters=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"event_schedules") ) { event_schedules=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"event_connections") ) { event_connections=inValue.Cast<  ::haxe::ds::StringMap >(); return inValue; }
		if (HX_FIELD_EQ(inName,"event_queue_count") ) { event_queue_count=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Events_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("event_queue","\x6c","\xac","\x8a","\x78"));
	outFields->push(HX_HCSTRING("event_connections","\xb0","\xaf","\xa0","\x64"));
	outFields->push(HX_HCSTRING("event_slots","\x90","\x7f","\x6c","\x99"));
	outFields->push(HX_HCSTRING("event_filters","\x56","\x6d","\x50","\x23"));
	outFields->push(HX_HCSTRING("event_schedules","\x97","\x6a","\x3a","\x12"));
	outFields->push(HX_HCSTRING("event_queue_count","\x7c","\x51","\x2c","\xb9"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Events_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Events_obj,event_queue),HX_HCSTRING("event_queue","\x6c","\xac","\x8a","\x78")},
	{hx::fsObject /*::haxe::ds::StringMap*/ ,(int)offsetof(Events_obj,event_connections),HX_HCSTRING("event_connections","\xb0","\xaf","\xa0","\x64")},
	{hx::fsObject /*::haxe::ds::StringMap*/ ,(int)offsetof(Events_obj,event_slots),HX_HCSTRING("event_slots","\x90","\x7f","\x6c","\x99")},
	{hx::fsObject /*::haxe::ds::StringMap*/ ,(int)offsetof(Events_obj,event_filters),HX_HCSTRING("event_filters","\x56","\x6d","\x50","\x23")},
	{hx::fsObject /*::haxe::ds::StringMap*/ ,(int)offsetof(Events_obj,event_schedules),HX_HCSTRING("event_schedules","\x97","\x6a","\x3a","\x12")},
	{hx::fsInt,(int)offsetof(Events_obj,event_queue_count),HX_HCSTRING("event_queue_count","\x7c","\x51","\x2c","\xb9")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Events_obj_sStaticStorageInfo = 0;
#endif

static ::String Events_obj_sMemberFields[] = {
	HX_HCSTRING("event_queue","\x6c","\xac","\x8a","\x78"),
	HX_HCSTRING("event_connections","\xb0","\xaf","\xa0","\x64"),
	HX_HCSTRING("event_slots","\x90","\x7f","\x6c","\x99"),
	HX_HCSTRING("event_filters","\x56","\x6d","\x50","\x23"),
	HX_HCSTRING("event_schedules","\x97","\x6a","\x3a","\x12"),
	HX_HCSTRING("event_queue_count","\x7c","\x51","\x2c","\xb9"),
	HX_HCSTRING("destroy","\xfa","\x2c","\x86","\x24"),
	HX_HCSTRING("clear","\x8d","\x71","\x5b","\x48"),
	HX_HCSTRING("does_filter_event","\x99","\xb3","\x20","\xec"),
	HX_HCSTRING("listen","\x47","\xc8","\xf9","\xef"),
	HX_HCSTRING("unlisten","\x60","\xf7","\x40","\xf2"),
	HX_HCSTRING("queue","\x91","\x8d","\xea","\x5d"),
	HX_HCSTRING("dequeue","\x70","\x62","\x58","\xfe"),
	HX_HCSTRING("process","\x6f","\xa2","\x4a","\xf1"),
	HX_HCSTRING("fire","\xb6","\xd3","\xbb","\x43"),
	HX_HCSTRING("schedule","\x57","\xca","\x7e","\xc5"),
	HX_HCSTRING("unschedule","\xb0","\xb1","\x42","\x4b"),
	HX_HCSTRING("tag_properties","\xf8","\x38","\x17","\x4c"),
	::String(null()) };

static void Events_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Events_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Events_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Events_obj::__mClass,"__mClass");
};

#endif

hx::Class Events_obj::__mClass;

void Events_obj::__register()
{
	hx::Object *dummy = new Events_obj;
	Events_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("luxe.Events","\xf1","\x60","\xc8","\xf5");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Events_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Events_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Events_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Events_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Events_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Events_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace luxe
