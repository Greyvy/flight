// Generated by Haxe 3.4.5
#include <hxcpp.h>

#ifndef INCLUDED_9484b18fc186cc5e
#define INCLUDED_9484b18fc186cc5e
#include "linc_opengl.h"
#endif
#ifndef INCLUDED_Lambda
#include <Lambda.h>
#endif
#ifndef INCLUDED_Luxe
#include <Luxe.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif
#ifndef INCLUDED_luxe_Debug
#include <luxe/Debug.h>
#endif
#ifndef INCLUDED_luxe_DebugError
#include <luxe/DebugError.h>
#endif
#ifndef INCLUDED_luxe_Emitter
#include <luxe/Emitter.h>
#endif
#ifndef INCLUDED_luxe_ID
#include <luxe/ID.h>
#endif
#ifndef INCLUDED_luxe_resource_Resource
#include <luxe/resource/Resource.h>
#endif
#ifndef INCLUDED_luxe_structural_BalancedBSTIterator_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry
#include <luxe/structural/BalancedBSTIterator_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry.h>
#endif
#ifndef INCLUDED_luxe_structural_BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry
#include <luxe/structural/BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry.h>
#endif
#ifndef INCLUDED_luxe_structural_BalancedBST_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry
#include <luxe/structural/BalancedBST_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry.h>
#endif
#ifndef INCLUDED_luxe_utils_Utils
#include <luxe/utils/Utils.h>
#endif
#ifndef INCLUDED_opengl_GLObject
#include <opengl/GLObject.h>
#endif
#ifndef INCLUDED_phoenix_BatchState
#include <phoenix/BatchState.h>
#endif
#ifndef INCLUDED_phoenix_Batcher
#include <phoenix/Batcher.h>
#endif
#ifndef INCLUDED_phoenix_Camera
#include <phoenix/Camera.h>
#endif
#ifndef INCLUDED_phoenix_Color
#include <phoenix/Color.h>
#endif
#ifndef INCLUDED_phoenix_Matrix
#include <phoenix/Matrix.h>
#endif
#ifndef INCLUDED_phoenix_Rectangle
#include <phoenix/Rectangle.h>
#endif
#ifndef INCLUDED_phoenix_RenderState
#include <phoenix/RenderState.h>
#endif
#ifndef INCLUDED_phoenix_Renderer
#include <phoenix/Renderer.h>
#endif
#ifndef INCLUDED_phoenix_RendererStats
#include <phoenix/RendererStats.h>
#endif
#ifndef INCLUDED_phoenix_Shader
#include <phoenix/Shader.h>
#endif
#ifndef INCLUDED_phoenix_Spatial
#include <phoenix/Spatial.h>
#endif
#ifndef INCLUDED_phoenix_Texture
#include <phoenix/Texture.h>
#endif
#ifndef INCLUDED_phoenix_Transform
#include <phoenix/Transform.h>
#endif
#ifndef INCLUDED_phoenix_Uniforms
#include <phoenix/Uniforms.h>
#endif
#ifndef INCLUDED_phoenix_Vector
#include <phoenix/Vector.h>
#endif
#ifndef INCLUDED_phoenix__Shader_Uniform_snow_api_buffers_Float32Array
#include <phoenix/_Shader/Uniform_snow_api_buffers_Float32Array.h>
#endif
#ifndef INCLUDED_phoenix_geometry_Geometry
#include <phoenix/geometry/Geometry.h>
#endif
#ifndef INCLUDED_phoenix_geometry_GeometryKey
#include <phoenix/geometry/GeometryKey.h>
#endif
#ifndef INCLUDED_phoenix_geometry_GeometryState
#include <phoenix/geometry/GeometryState.h>
#endif
#ifndef INCLUDED_phoenix_geometry_TextureCoord
#include <phoenix/geometry/TextureCoord.h>
#endif
#ifndef INCLUDED_phoenix_geometry_TextureCoordSet
#include <phoenix/geometry/TextureCoordSet.h>
#endif
#ifndef INCLUDED_phoenix_geometry_Vertex
#include <phoenix/geometry/Vertex.h>
#endif
#ifndef INCLUDED_snow_api_buffers_ArrayBufferView
#include <snow/api/buffers/ArrayBufferView.h>
#endif
#ifndef INCLUDED_snow_api_buffers_TAError
#include <snow/api/buffers/TAError.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_8831ea6108d72700_16_new,"phoenix.Batcher","new",0x3e82c79a,"phoenix.Batcher.new","phoenix/Batcher.hx",16,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_114_on,"phoenix.Batcher","on",0x2875af25,"phoenix.Batcher.on","phoenix/Batcher.hx",114,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_119_off,"phoenix.Batcher","off",0x3e838aa9,"phoenix.Batcher.off","phoenix/Batcher.hx",119,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_128_add,"phoenix.Batcher","add",0x3e78e95b,"phoenix.Batcher.add","phoenix/Batcher.hx",128,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_156_empty,"phoenix.Batcher","empty",0xd120f447,"phoenix.Batcher.empty","phoenix/Batcher.hx",156,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_174_destroy,"phoenix.Batcher","destroy",0x703a4934,"phoenix.Batcher.destroy","phoenix/Batcher.hx",174,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_199_remove,"phoenix.Batcher","remove",0xc124654a,"phoenix.Batcher.remove","phoenix/Batcher.hx",199,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_228_batch,"phoenix.Batcher","batch",0x0f01a174,"phoenix.Batcher.batch","phoenix/Batcher.hx",228,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_354_prune,"phoenix.Batcher","prune",0x29db2ce4,"phoenix.Batcher.prune","phoenix/Batcher.hx",354,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_366_draw,"phoenix.Batcher","draw",0x6d59878a,"phoenix.Batcher.draw","phoenix/Batcher.hx",366,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_396_update_view,"phoenix.Batcher","update_view",0x26fb08d5,"phoenix.Batcher.update_view","phoenix/Batcher.hx",396,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_411_apply_default_uniforms,"phoenix.Batcher","apply_default_uniforms",0xa32f6d74,"phoenix.Batcher.apply_default_uniforms","phoenix/Batcher.hx",411,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_421_submit_geometry,"phoenix.Batcher","submit_geometry",0x018ac533,"phoenix.Batcher.submit_geometry","phoenix/Batcher.hx",421,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_455_submit_buffers,"phoenix.Batcher","submit_buffers",0x8abe6c12,"phoenix.Batcher.submit_buffers","phoenix/Batcher.hx",455,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_498_submit_static_geometry,"phoenix.Batcher","submit_static_geometry",0x9aab1742,"phoenix.Batcher.submit_static_geometry","phoenix/Batcher.hx",498,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_529_submit_current_vertex_list,"phoenix.Batcher","submit_current_vertex_list",0x67dd8932,"phoenix.Batcher.submit_current_vertex_list","phoenix/Batcher.hx",529,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_568_geometry_batch,"phoenix.Batcher","geometry_batch",0x429a8233,"phoenix.Batcher.geometry_batch","phoenix/Batcher.hx",568,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_603_set_layer,"phoenix.Batcher","set_layer",0x4cd9e8ee,"phoenix.Batcher.set_layer","phoenix/Batcher.hx",603,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_617_toString,"phoenix.Batcher","toString",0x2a536732,"phoenix.Batcher.toString","phoenix/Batcher.hx",617,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_622_compare,"phoenix.Batcher","compare",0xcf1d34df,"phoenix.Batcher.compare","phoenix/Batcher.hx",622,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_632_compare_rule_to_string,"phoenix.Batcher","compare_rule_to_string",0xb26938b2,"phoenix.Batcher.compare_rule_to_string","phoenix/Batcher.hx",632,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_664_compare_rule,"phoenix.Batcher","compare_rule",0xfee0579c,"phoenix.Batcher.compare_rule","phoenix/Batcher.hx",664,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_755_geometry_compare,"phoenix.Batcher","geometry_compare",0xc33f035e,"phoenix.Batcher.geometry_compare","phoenix/Batcher.hx",755,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_852_list_geometry,"phoenix.Batcher","list_geometry",0x542e65ad,"phoenix.Batcher.list_geometry","phoenix/Batcher.hx",852,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_858_set_show_stats,"phoenix.Batcher","set_show_stats",0x179d9de0,"phoenix.Batcher.set_show_stats","phoenix/Batcher.hx",858,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_53_boot,"phoenix.Batcher","boot",0x6c04dfb8,"phoenix.Batcher.boot","phoenix/Batcher.hx",53,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_62_boot,"phoenix.Batcher","boot",0x6c04dfb8,"phoenix.Batcher.boot","phoenix/Batcher.hx",62,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_867_boot,"phoenix.Batcher","boot",0x6c04dfb8,"phoenix.Batcher.boot","phoenix/Batcher.hx",867,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_868_boot,"phoenix.Batcher","boot",0x6c04dfb8,"phoenix.Batcher.boot","phoenix/Batcher.hx",868,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_869_boot,"phoenix.Batcher","boot",0x6c04dfb8,"phoenix.Batcher.boot","phoenix/Batcher.hx",869,0xa9541457)
HX_LOCAL_STACK_FRAME(_hx_pos_8831ea6108d72700_870_boot,"phoenix.Batcher","boot",0x6c04dfb8,"phoenix.Batcher.boot","phoenix/Batcher.hx",870,0xa9541457)
namespace phoenix{

void Batcher_obj::__construct( ::phoenix::Renderer _r,::String __o__name, ::Dynamic __o__max_verts){
::String _name = __o__name.Default(HX_HCSTRING("","\x00","\x00","\x00","\x00"));
 ::Dynamic _max_verts = __o__max_verts.Default(16384);
            	HX_GC_STACKFRAME(&_hx_pos_8831ea6108d72700_16_new)
HXLINE(  59)		this->normal_floats = (int)0;
HXLINE(  58)		this->color_floats = (int)0;
HXLINE(  57)		this->tcoord_floats = (int)0;
HXLINE(  56)		this->pos_floats = (int)0;
HXLINE(  54)		this->sequence = (int)-1;
HXLINE(  49)		this->show_stats = (int)1;
HXLINE(  47)		this->name = HX_("",00,00,00,00);
HXLINE(  46)		this->log = false;
HXLINE(  44)		this->visible_count = (int)0;
HXLINE(  43)		this->static_batched_count = (int)0;
HXLINE(  42)		this->dynamic_batched_count = (int)0;
HXLINE(  41)		this->draw_calls = (int)0;
HXLINE(  33)		this->vert_count = (int)0;
HXLINE(  32)		this->max_floats = (int)0;
HXLINE(  31)		this->max_verts = (int)0;
HXLINE(  24)		this->tree_changed = false;
HXLINE(  20)		this->layer = (int)0;
HXLINE(  19)		this->enabled = true;
HXLINE(  66)		this->id = ::Luxe_obj::utils->uniqueid(null());
HXLINE(  67)		this->renderer = _r;
HXLINE(  68)		this->sequence = ++::phoenix::Batcher_obj::_sequence_key;
HXLINE(  70)		this->geometry =  ::luxe::structural::BalancedBST_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry_obj::__alloc( HX_CTX ,this->geometry_compare_dyn());
HXLINE(  71)		this->emitter =  ::luxe::Emitter_obj::__alloc( HX_CTX );
HXLINE(  73)		this->max_verts = _max_verts;
HXLINE(  75)		this->max_floats = (this->max_verts * (int)4);
HXLINE(  78)		 ::snow::api::buffers::ArrayBufferView this1;
HXDLIN(  78)		int _elements = this->max_floats;
HXDLIN(  78)		if ((_elements < (int)0)) {
HXLINE(  78)			_elements = (int)0;
            		}
HXDLIN(  78)		 ::snow::api::buffers::ArrayBufferView _view =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN(  78)		int _bytelen = (_elements * _view->bytesPerElement);
HXDLIN(  78)		_view->byteOffset = (int)0;
HXDLIN(  78)		_view->byteLength = _bytelen;
HXDLIN(  78)		::Array< unsigned char > this2 = ::Array_obj< unsigned char >::__new();
HXDLIN(  78)		if ((_bytelen > (int)0)) {
HXLINE(  78)			this2[(_bytelen - (int)1)] = (int)0;
            		}
HXDLIN(  78)		_view->buffer = this2;
HXDLIN(  78)		_view->length = _elements;
HXDLIN(  78)		this1 = _view;
HXDLIN(  78)		this->pos_list = this1;
HXLINE(  79)		 ::snow::api::buffers::ArrayBufferView this3;
HXDLIN(  79)		int _elements1 = this->max_floats;
HXDLIN(  79)		if ((_elements1 < (int)0)) {
HXLINE(  79)			_elements1 = (int)0;
            		}
HXDLIN(  79)		 ::snow::api::buffers::ArrayBufferView _view1 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN(  79)		int _bytelen1 = (_elements1 * _view1->bytesPerElement);
HXDLIN(  79)		_view1->byteOffset = (int)0;
HXDLIN(  79)		_view1->byteLength = _bytelen1;
HXDLIN(  79)		::Array< unsigned char > this4 = ::Array_obj< unsigned char >::__new();
HXDLIN(  79)		if ((_bytelen1 > (int)0)) {
HXLINE(  79)			this4[(_bytelen1 - (int)1)] = (int)0;
            		}
HXDLIN(  79)		_view1->buffer = this4;
HXDLIN(  79)		_view1->length = _elements1;
HXDLIN(  79)		this3 = _view1;
HXDLIN(  79)		this->tcoord_list = this3;
HXLINE(  80)		 ::snow::api::buffers::ArrayBufferView this5;
HXDLIN(  80)		int _elements2 = this->max_floats;
HXDLIN(  80)		if ((_elements2 < (int)0)) {
HXLINE(  80)			_elements2 = (int)0;
            		}
HXDLIN(  80)		 ::snow::api::buffers::ArrayBufferView _view2 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN(  80)		int _bytelen2 = (_elements2 * _view2->bytesPerElement);
HXDLIN(  80)		_view2->byteOffset = (int)0;
HXDLIN(  80)		_view2->byteLength = _bytelen2;
HXDLIN(  80)		::Array< unsigned char > this6 = ::Array_obj< unsigned char >::__new();
HXDLIN(  80)		if ((_bytelen2 > (int)0)) {
HXLINE(  80)			this6[(_bytelen2 - (int)1)] = (int)0;
            		}
HXDLIN(  80)		_view2->buffer = this6;
HXDLIN(  80)		_view2->length = _elements2;
HXDLIN(  80)		this5 = _view2;
HXDLIN(  80)		this->color_list = this5;
HXLINE(  87)		this->view = this->renderer->camera;
HXLINE(  89)		glEnableVertexAttribArray((int)0);
HXLINE(  90)		glEnableVertexAttribArray((int)1);
HXLINE(  91)		glEnableVertexAttribArray((int)2);
HXLINE(  98)		if ((_name.length == (int)0)) {
HXLINE(  99)			this->name = ::Luxe_obj::utils->uniqueid(null());
            		}
            		else {
HXLINE( 101)			this->name = _name;
            		}
HXLINE( 104)		this->_dropped = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 106)		this->renderer->stats->batchers++;
HXLINE( 107)		::phoenix::Batcher_obj::all->push(hx::ObjectPtr<OBJ_>(this));
            	}

Dynamic Batcher_obj::__CreateEmpty() { return new Batcher_obj; }

void *Batcher_obj::_hx_vtable = 0;

Dynamic Batcher_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Batcher_obj > _hx_result = new Batcher_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2]);
	return _hx_result;
}

bool Batcher_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x2547c658;
}

void Batcher_obj::on(int event, ::Dynamic handler){
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_114_on)
HXDLIN( 114)		this->emitter->on(event,handler);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Batcher_obj,on,(void))

bool Batcher_obj::off(int event, ::Dynamic handler){
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_119_off)
HXDLIN( 119)		return this->emitter->off(event,handler);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Batcher_obj,off,return )

void Batcher_obj::add( ::phoenix::geometry::Geometry _geom,hx::Null< bool >  __o__force_add){
bool _force_add = __o__force_add.Default(false);
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_128_add)
HXDLIN( 128)		bool _hx_tmp;
HXDLIN( 128)		if (hx::IsNotNull( this->geometry->find(_geom->key) )) {
HXDLIN( 128)			_hx_tmp = _force_add;
            		}
            		else {
HXDLIN( 128)			_hx_tmp = true;
            		}
HXDLIN( 128)		if (_hx_tmp) {
HXLINE( 131)			if (!(::Lambda_obj::has(_geom->batchers,hx::ObjectPtr<OBJ_>(this)))) {
HXLINE( 132)				_geom->batchers->push(hx::ObjectPtr<OBJ_>(this));
            			}
HXLINE( 136)			{
HXLINE( 136)				 ::luxe::structural::BalancedBST_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _this = this->geometry;
HXDLIN( 136)				_this->root = _this->node_insert(_this->root,_geom->key,_geom);
HXDLIN( 136)				_this->root->color = false;
            			}
HXLINE( 139)			_geom->added = true;
HXLINE( 142)			this->tree_changed = true;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Batcher_obj,add,(void))

void Batcher_obj::empty(hx::Null< bool >  __o__drop){
bool _drop = __o__drop.Default(true);
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_156_empty)
HXDLIN( 156)		if (_drop) {
HXLINE( 157)			 ::luxe::structural::BalancedBSTIterator_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _g = this->geometry->iterator();
HXDLIN( 157)			while(true){
HXLINE( 157)				bool _hx_tmp;
HXDLIN( 157)				bool _hx_tmp1;
HXDLIN( 157)				if (hx::IsNotNull( _g->current )) {
HXLINE( 157)					_hx_tmp1 = hx::IsNull( _g->rightest );
            				}
            				else {
HXLINE( 157)					_hx_tmp1 = true;
            				}
HXDLIN( 157)				if (_hx_tmp1) {
HXLINE( 157)					_hx_tmp = false;
            				}
            				else {
HXLINE( 157)					_hx_tmp = (( (int)(_g->tree->compare(_g->current->key,_g->rightest->key)) ) <= (int)0);
            				}
HXDLIN( 157)				if (!(_hx_tmp)) {
HXLINE( 157)					goto _hx_goto_4;
            				}
HXDLIN( 157)				 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _temp = _g->current;
HXDLIN( 157)				 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _hx_tmp2;
HXDLIN( 157)				bool _hx_tmp3;
HXDLIN( 157)				bool _hx_tmp4;
HXDLIN( 157)				if (hx::IsNotNull( _g->current )) {
HXLINE( 157)					_hx_tmp4 = hx::IsNull( _g->rightest );
            				}
            				else {
HXLINE( 157)					_hx_tmp4 = true;
            				}
HXDLIN( 157)				if (_hx_tmp4) {
HXLINE( 157)					_hx_tmp3 = false;
            				}
            				else {
HXLINE( 157)					_hx_tmp3 = (( (int)(_g->tree->compare(_g->current->key,_g->rightest->key)) ) <= (int)0);
            				}
HXDLIN( 157)				if (!(_hx_tmp3)) {
HXLINE( 157)					_hx_tmp2 = null();
            				}
            				else {
HXLINE( 157)					if (hx::IsNotNull( _g->current->right )) {
HXLINE( 157)						 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _node = _g->current->right;
HXDLIN( 157)						while(hx::IsNotNull( _node->left )){
HXLINE( 157)							_node = _node->left;
            						}
HXDLIN( 157)						_hx_tmp2 = _node;
            					}
            					else {
HXLINE( 157)						 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _next = null();
HXDLIN( 157)						 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _temp1 = _g->tree->root;
HXDLIN( 157)						while(hx::IsNotNull( _temp1 )){
HXLINE( 157)							int _comp = ( (int)(_g->tree->compare(_g->current->key,_temp1->key)) );
HXDLIN( 157)							if ((_comp < (int)0)) {
HXLINE( 157)								_next = _temp1;
HXDLIN( 157)								_temp1 = _temp1->left;
            							}
            							else {
HXLINE( 157)								if ((_comp > (int)0)) {
HXLINE( 157)									_temp1 = _temp1->right;
            								}
            								else {
HXLINE( 157)									_g->current = _next;
HXDLIN( 157)									goto _hx_goto_6;
            								}
            							}
            						}
            						_hx_goto_6:;
HXDLIN( 157)						_hx_tmp2 = _next;
            					}
            				}
HXDLIN( 157)				_g->current = _hx_tmp2;
HXDLIN( 157)				 ::phoenix::geometry::Geometry geom = _temp->value;
HXLINE( 158)				geom->drop(true);
HXLINE( 159)				geom = null();
            			}
            			_hx_goto_4:;
            		}
            		else {
HXLINE( 162)			 ::luxe::structural::BalancedBSTIterator_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _g1 = this->geometry->iterator();
HXDLIN( 162)			while(true){
HXLINE( 162)				bool _hx_tmp5;
HXDLIN( 162)				bool _hx_tmp6;
HXDLIN( 162)				if (hx::IsNotNull( _g1->current )) {
HXLINE( 162)					_hx_tmp6 = hx::IsNull( _g1->rightest );
            				}
            				else {
HXLINE( 162)					_hx_tmp6 = true;
            				}
HXDLIN( 162)				if (_hx_tmp6) {
HXLINE( 162)					_hx_tmp5 = false;
            				}
            				else {
HXLINE( 162)					_hx_tmp5 = (( (int)(_g1->tree->compare(_g1->current->key,_g1->rightest->key)) ) <= (int)0);
            				}
HXDLIN( 162)				if (!(_hx_tmp5)) {
HXLINE( 162)					goto _hx_goto_7;
            				}
HXDLIN( 162)				 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _temp2 = _g1->current;
HXDLIN( 162)				 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _hx_tmp7;
HXDLIN( 162)				bool _hx_tmp8;
HXDLIN( 162)				bool _hx_tmp9;
HXDLIN( 162)				if (hx::IsNotNull( _g1->current )) {
HXLINE( 162)					_hx_tmp9 = hx::IsNull( _g1->rightest );
            				}
            				else {
HXLINE( 162)					_hx_tmp9 = true;
            				}
HXDLIN( 162)				if (_hx_tmp9) {
HXLINE( 162)					_hx_tmp8 = false;
            				}
            				else {
HXLINE( 162)					_hx_tmp8 = (( (int)(_g1->tree->compare(_g1->current->key,_g1->rightest->key)) ) <= (int)0);
            				}
HXDLIN( 162)				if (!(_hx_tmp8)) {
HXLINE( 162)					_hx_tmp7 = null();
            				}
            				else {
HXLINE( 162)					if (hx::IsNotNull( _g1->current->right )) {
HXLINE( 162)						 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _node1 = _g1->current->right;
HXDLIN( 162)						while(hx::IsNotNull( _node1->left )){
HXLINE( 162)							_node1 = _node1->left;
            						}
HXDLIN( 162)						_hx_tmp7 = _node1;
            					}
            					else {
HXLINE( 162)						 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _next1 = null();
HXDLIN( 162)						 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _temp3 = _g1->tree->root;
HXDLIN( 162)						while(hx::IsNotNull( _temp3 )){
HXLINE( 162)							int _comp1 = ( (int)(_g1->tree->compare(_g1->current->key,_temp3->key)) );
HXDLIN( 162)							if ((_comp1 < (int)0)) {
HXLINE( 162)								_next1 = _temp3;
HXDLIN( 162)								_temp3 = _temp3->left;
            							}
            							else {
HXLINE( 162)								if ((_comp1 > (int)0)) {
HXLINE( 162)									_temp3 = _temp3->right;
            								}
            								else {
HXLINE( 162)									_g1->current = _next1;
HXDLIN( 162)									goto _hx_goto_9;
            								}
            							}
            						}
            						_hx_goto_9:;
HXDLIN( 162)						_hx_tmp7 = _next1;
            					}
            				}
HXDLIN( 162)				_g1->current = _hx_tmp7;
HXDLIN( 162)				 ::phoenix::geometry::Geometry geom1 = _temp2->value;
HXLINE( 163)				this->geometry->remove(geom1->key);
            			}
            			_hx_goto_7:;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Batcher_obj,empty,(void))

void Batcher_obj::destroy(hx::Null< bool >  __o__drop){
bool _drop = __o__drop.Default(true);
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_174_destroy)
HXLINE( 176)		this->empty(_drop);
HXLINE( 178)		this->renderer->remove_batch(hx::ObjectPtr<OBJ_>(this));
HXLINE( 179)		this->renderer->stats->batchers--;
HXLINE( 181)		this->emitter = null();
HXLINE( 182)		this->geometry = null();
HXLINE( 183)		this->pos_list = null();
HXLINE( 184)		this->tcoord_list = null();
HXLINE( 185)		this->color_list = null();
HXLINE( 186)		this->normal_list = null();
HXLINE( 188)		this->max_verts = (int)0;
HXLINE( 189)		this->max_floats = (int)0;
HXLINE( 190)		this->vert_count = (int)0;
HXLINE( 192)		this->renderer = null();
HXLINE( 193)		this->view = null();
HXLINE( 195)		::phoenix::Batcher_obj::all->remove(hx::ObjectPtr<OBJ_>(this));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Batcher_obj,destroy,(void))

void Batcher_obj::remove( ::phoenix::geometry::Geometry _geom, ::Dynamic __o__remove_batcher_from_geometry){
 ::Dynamic _remove_batcher_from_geometry = __o__remove_batcher_from_geometry.Default(true);
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_199_remove)
HXLINE( 201)		if (_remove_batcher_from_geometry) {
HXLINE( 202)			_geom->batchers->remove(hx::ObjectPtr<OBJ_>(this));
HXLINE( 203)			if ((_geom->batchers->length == (int)0)) {
HXLINE( 204)				_geom->added = false;
            			}
            		}
HXLINE( 208)		 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _node = this->geometry->root;
HXDLIN( 208)		int countbefore;
HXDLIN( 208)		if (hx::IsNull( _node )) {
HXLINE( 208)			countbefore = (int)0;
            		}
            		else {
HXLINE( 208)			countbefore = _node->nodecount;
            		}
HXLINE( 210)		this->geometry->remove(_geom->key);
HXLINE( 212)		 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _node1 = this->geometry->root;
HXDLIN( 212)		int countafter;
HXDLIN( 212)		if (hx::IsNull( _node1 )) {
HXLINE( 212)			countafter = (int)0;
            		}
            		else {
HXLINE( 212)			countafter = _node1->nodecount;
            		}
HXLINE( 214)		bool _hx_tmp = (countbefore == countafter);
HXLINE( 219)		this->tree_changed = true;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Batcher_obj,remove,(void))

void Batcher_obj::batch(hx::Null< bool >  __o_persist_immediate){
bool persist_immediate = __o_persist_immediate.Default(false);
            	HX_GC_STACKFRAME(&_hx_pos_8831ea6108d72700_228_batch)
HXLINE( 231)		this->dynamic_batched_count = (int)0;
HXLINE( 232)		this->static_batched_count = (int)0;
HXLINE( 233)		this->visible_count = (int)0;
HXLINE( 235)		this->pos_floats = (int)0;
HXLINE( 236)		this->tcoord_floats = (int)0;
HXLINE( 237)		this->color_floats = (int)0;
HXLINE( 238)		this->normal_floats = (int)0;
HXLINE( 241)		this->state =  ::phoenix::BatchState_obj::__alloc( HX_CTX ,hx::ObjectPtr<OBJ_>(this));
HXLINE( 243)		 ::phoenix::geometry::Geometry geom = null();
HXLINE( 246)		{
HXLINE( 246)			 ::luxe::structural::BalancedBSTIterator_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _g = this->geometry->iterator();
HXDLIN( 246)			while(true){
HXLINE( 246)				bool _hx_tmp;
HXDLIN( 246)				bool _hx_tmp1;
HXDLIN( 246)				if (hx::IsNotNull( _g->current )) {
HXLINE( 246)					_hx_tmp1 = hx::IsNull( _g->rightest );
            				}
            				else {
HXLINE( 246)					_hx_tmp1 = true;
            				}
HXDLIN( 246)				if (_hx_tmp1) {
HXLINE( 246)					_hx_tmp = false;
            				}
            				else {
HXLINE( 246)					_hx_tmp = (( (int)(_g->tree->compare(_g->current->key,_g->rightest->key)) ) <= (int)0);
            				}
HXDLIN( 246)				if (!(_hx_tmp)) {
HXLINE( 246)					goto _hx_goto_13;
            				}
HXDLIN( 246)				 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _temp = _g->current;
HXDLIN( 246)				 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _hx_tmp2;
HXDLIN( 246)				bool _hx_tmp3;
HXDLIN( 246)				bool _hx_tmp4;
HXDLIN( 246)				if (hx::IsNotNull( _g->current )) {
HXLINE( 246)					_hx_tmp4 = hx::IsNull( _g->rightest );
            				}
            				else {
HXLINE( 246)					_hx_tmp4 = true;
            				}
HXDLIN( 246)				if (_hx_tmp4) {
HXLINE( 246)					_hx_tmp3 = false;
            				}
            				else {
HXLINE( 246)					_hx_tmp3 = (( (int)(_g->tree->compare(_g->current->key,_g->rightest->key)) ) <= (int)0);
            				}
HXDLIN( 246)				if (!(_hx_tmp3)) {
HXLINE( 246)					_hx_tmp2 = null();
            				}
            				else {
HXLINE( 246)					if (hx::IsNotNull( _g->current->right )) {
HXLINE( 246)						 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _node = _g->current->right;
HXDLIN( 246)						while(hx::IsNotNull( _node->left )){
HXLINE( 246)							_node = _node->left;
            						}
HXDLIN( 246)						_hx_tmp2 = _node;
            					}
            					else {
HXLINE( 246)						 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _next = null();
HXDLIN( 246)						 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _temp1 = _g->tree->root;
HXDLIN( 246)						while(hx::IsNotNull( _temp1 )){
HXLINE( 246)							int _comp = ( (int)(_g->tree->compare(_g->current->key,_temp1->key)) );
HXDLIN( 246)							if ((_comp < (int)0)) {
HXLINE( 246)								_next = _temp1;
HXDLIN( 246)								_temp1 = _temp1->left;
            							}
            							else {
HXLINE( 246)								if ((_comp > (int)0)) {
HXLINE( 246)									_temp1 = _temp1->right;
            								}
            								else {
HXLINE( 246)									_g->current = _next;
HXDLIN( 246)									goto _hx_goto_15;
            								}
            							}
            						}
            						_hx_goto_15:;
HXDLIN( 246)						_hx_tmp2 = _next;
            					}
            				}
HXDLIN( 246)				_g->current = _hx_tmp2;
HXDLIN( 246)				 ::phoenix::geometry::Geometry _geom = _temp->value;
HXLINE( 249)				geom = _geom;
HXLINE( 252)				bool _hx_tmp5;
HXDLIN( 252)				if (hx::IsNotNull( geom )) {
HXLINE( 252)					_hx_tmp5 = !(geom->dropped);
            				}
            				else {
HXLINE( 252)					_hx_tmp5 = false;
            				}
HXDLIN( 252)				if (_hx_tmp5) {
HXLINE( 255)					if (this->state->update(geom)) {
HXLINE( 259)						int type = this->state->last_geom_state->primitive_type;
HXDLIN( 259)						if ((this->pos_floats != (int)0)) {
HXLINE( 259)							if ((this->pos_floats > this->max_floats)) {
HXLINE( 259)								HX_STACK_DO_THROW(HX_("uh oh, somehow too many floats are being submitted (max:$max_floats, attempt:$pos_floats).",4e,e8,8c,4a));
            							}
HXDLIN( 259)							::Array< unsigned char > _buffer = this->pos_list->buffer;
HXDLIN( 259)							int _byteLength = (this->pos_floats * (int)4);
HXDLIN( 259)							 ::snow::api::buffers::ArrayBufferView _view =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 259)							int _bytes_per_elem = _view->bytesPerElement;
HXDLIN( 259)							if ((hx::Mod((int)0,_bytes_per_elem) != (int)0)) {
HXLINE( 259)								HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            							}
HXDLIN( 259)							int _src_bytelen = _buffer->length;
HXDLIN( 259)							int _new_range = _byteLength;
HXDLIN( 259)							if ((_new_range > _src_bytelen)) {
HXLINE( 259)								HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            							}
HXDLIN( 259)							_view->buffer = _buffer;
HXDLIN( 259)							_view->byteOffset = (int)0;
HXDLIN( 259)							_view->byteLength = _byteLength;
HXDLIN( 259)							_view->length = ::Std_obj::_hx_int(((Float)_byteLength / (Float)_bytes_per_elem));
HXDLIN( 259)							 ::snow::api::buffers::ArrayBufferView _pos = _view;
HXDLIN( 259)							::Array< unsigned char > _buffer1 = this->tcoord_list->buffer;
HXDLIN( 259)							int _byteLength1 = (this->tcoord_floats * (int)4);
HXDLIN( 259)							 ::snow::api::buffers::ArrayBufferView _view1 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 259)							int _bytes_per_elem1 = _view1->bytesPerElement;
HXDLIN( 259)							if ((hx::Mod((int)0,_bytes_per_elem1) != (int)0)) {
HXLINE( 259)								HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            							}
HXDLIN( 259)							int _src_bytelen1 = _buffer1->length;
HXDLIN( 259)							int _new_range1 = _byteLength1;
HXDLIN( 259)							if ((_new_range1 > _src_bytelen1)) {
HXLINE( 259)								HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            							}
HXDLIN( 259)							_view1->buffer = _buffer1;
HXDLIN( 259)							_view1->byteOffset = (int)0;
HXDLIN( 259)							_view1->byteLength = _byteLength1;
HXDLIN( 259)							_view1->length = ::Std_obj::_hx_int(((Float)_byteLength1 / (Float)_bytes_per_elem1));
HXDLIN( 259)							 ::snow::api::buffers::ArrayBufferView _tcoords = _view1;
HXDLIN( 259)							::Array< unsigned char > _buffer2 = this->color_list->buffer;
HXDLIN( 259)							int _byteLength2 = (this->color_floats * (int)4);
HXDLIN( 259)							 ::snow::api::buffers::ArrayBufferView _view2 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 259)							int _bytes_per_elem2 = _view2->bytesPerElement;
HXDLIN( 259)							if ((hx::Mod((int)0,_bytes_per_elem2) != (int)0)) {
HXLINE( 259)								HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            							}
HXDLIN( 259)							int _src_bytelen2 = _buffer2->length;
HXDLIN( 259)							int _new_range2 = _byteLength2;
HXDLIN( 259)							if ((_new_range2 > _src_bytelen2)) {
HXLINE( 259)								HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            							}
HXDLIN( 259)							_view2->buffer = _buffer2;
HXDLIN( 259)							_view2->byteOffset = (int)0;
HXDLIN( 259)							_view2->byteLength = _byteLength2;
HXDLIN( 259)							_view2->length = ::Std_obj::_hx_int(((Float)_byteLength2 / (Float)_bytes_per_elem2));
HXDLIN( 259)							 ::snow::api::buffers::ArrayBufferView _colors = _view2;
HXDLIN( 259)							 ::snow::api::buffers::ArrayBufferView _normals = null();
HXDLIN( 259)							this->submit_buffers(type,_pos,_tcoords,_colors,_normals);
HXDLIN( 259)							_pos = null();
HXDLIN( 259)							_tcoords = null();
HXDLIN( 259)							_colors = null();
HXDLIN( 259)							_normals = null();
HXDLIN( 259)							this->pos_floats = (int)0;
HXDLIN( 259)							this->tcoord_floats = (int)0;
HXDLIN( 259)							this->color_floats = (int)0;
HXDLIN( 259)							this->normal_floats = (int)0;
            						}
            					}
HXLINE( 264)					{
HXLINE( 264)						 ::phoenix::BatchState _this = this->state;
HXDLIN( 264)						if (_this->geom_state->dirty) {
HXLINE( 264)							if (hx::IsNotNull( _this->geom_state->texture )) {
HXLINE( 264)								if (hx::IsNotEq( _this->last_texture_id,_this->geom_state->texture->id )) {
HXLINE( 264)									_this->last_texture_id = _this->geom_state->texture->id;
HXDLIN( 264)									if (hx::IsNotNull( _this->geom_state->texture->texture )) {
HXLINE( 264)										_this->geom_state->texture->bind();
            									}
            								}
            							}
            							else {
HXLINE( 264)								::Luxe_obj::renderer->state->bindTexture2D(null());
HXDLIN( 264)								_this->last_texture_id = null();
            							}
HXDLIN( 264)							 ::phoenix::Shader _shader;
HXDLIN( 264)							if (hx::IsNull( this->shader )) {
HXLINE( 264)								_shader = _this->geom_state->shader;
            							}
            							else {
HXLINE( 264)								_shader = this->shader;
            							}
HXDLIN( 264)							if (hx::IsNull( _shader )) {
HXLINE( 264)								if (hx::IsNotNull( _this->geom_state->texture )) {
HXLINE( 264)									_shader = ( ( ::phoenix::Shader)( ::Dynamic(this->renderer->shaders->__Field(HX_("textured",29,f7,ce,65),hx::paccDynamic))->__Field(HX_("shader",25,bf,20,1d),hx::paccDynamic)) );
            								}
            								else {
HXLINE( 264)									_shader = ( ( ::phoenix::Shader)( ::Dynamic(this->renderer->shaders->__Field(HX_("plain",0a,fa,8d,c4),hx::paccDynamic))->__Field(HX_("shader",25,bf,20,1d),hx::paccDynamic)) );
            								}
            							}
HXDLIN( 264)							 ::opengl::GLObject this1 =  ::opengl::GLObject_obj::__alloc( HX_CTX ,( (int)(_this->last_shader_id) ));
HXDLIN( 264)							if (hx::IsNotEq( this1,_shader->program )) {
HXLINE( 264)								if (!(_shader->no_default_uniforms)) {
HXLINE( 264)									{
HXLINE( 264)										 ::snow::api::buffers::ArrayBufferView _value = this->view->proj_arr;
HXDLIN( 264)										{
HXLINE( 264)											 ::phoenix::Uniforms _this1 = _shader->uniforms;
HXDLIN( 264)											 ::opengl::GLObject program = _shader->program;
HXDLIN( 264)											int _id;
HXDLIN( 264)											if (hx::IsNull( program )) {
HXLINE( 264)												_id = (int)0;
            											}
            											else {
HXLINE( 264)												_id = program->id;
            											}
HXDLIN( 264)											 ::opengl::GLObject this2 =  ::opengl::GLObject_obj::__alloc( HX_CTX ,glGetUniformLocation(_id,HX_("projectionMatrix",30,88,bb,d0)));
HXDLIN( 264)											 ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array _matrix4 = ( ( ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array)(::haxe::IMap_obj::get(_this1->matrix4arrs,HX_("projectionMatrix",30,88,bb,d0))) );
HXDLIN( 264)											if (hx::IsNotNull( _matrix4 )) {
HXLINE( 264)												_matrix4->value = _value;
            											}
            											else {
HXLINE( 264)												_matrix4 =  ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array_obj::__alloc( HX_CTX ,HX_("projectionMatrix",30,88,bb,d0),_value,this2);
HXDLIN( 264)												::haxe::IMap_obj::set(_this1->matrix4arrs,HX_("projectionMatrix",30,88,bb,d0),_matrix4);
            											}
HXDLIN( 264)											_this1->dirty_matrix4arrs->push(_matrix4);
            										}
            									}
HXDLIN( 264)									{
HXLINE( 264)										 ::snow::api::buffers::ArrayBufferView _value1 = this->view->view_inverse_arr;
HXDLIN( 264)										{
HXLINE( 264)											 ::phoenix::Uniforms _this2 = _shader->uniforms;
HXDLIN( 264)											 ::opengl::GLObject program1 = _shader->program;
HXDLIN( 264)											int _id1;
HXDLIN( 264)											if (hx::IsNull( program1 )) {
HXLINE( 264)												_id1 = (int)0;
            											}
            											else {
HXLINE( 264)												_id1 = program1->id;
            											}
HXDLIN( 264)											 ::opengl::GLObject this3 =  ::opengl::GLObject_obj::__alloc( HX_CTX ,glGetUniformLocation(_id1,HX_("modelViewMatrix",8f,eb,9c,59)));
HXDLIN( 264)											 ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array _matrix41 = ( ( ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array)(::haxe::IMap_obj::get(_this2->matrix4arrs,HX_("modelViewMatrix",8f,eb,9c,59))) );
HXDLIN( 264)											if (hx::IsNotNull( _matrix41 )) {
HXLINE( 264)												_matrix41->value = _value1;
            											}
            											else {
HXLINE( 264)												_matrix41 =  ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array_obj::__alloc( HX_CTX ,HX_("modelViewMatrix",8f,eb,9c,59),_value1,this3);
HXDLIN( 264)												::haxe::IMap_obj::set(_this2->matrix4arrs,HX_("modelViewMatrix",8f,eb,9c,59),_matrix41);
            											}
HXDLIN( 264)											_this2->dirty_matrix4arrs->push(_matrix41);
            										}
            									}
            								}
HXDLIN( 264)								{
HXLINE( 264)									_shader->use();
HXDLIN( 264)									_shader->uniforms->apply();
HXDLIN( 264)									::Luxe_obj::renderer->state->activeTexture((int)33984);
            								}
HXDLIN( 264)								 ::opengl::GLObject this4 = _shader->program;
HXDLIN( 264)								 ::Dynamic _hx_tmp6;
HXDLIN( 264)								if (hx::IsNull( this4 )) {
HXLINE( 264)									_hx_tmp6 = (int)0;
            								}
            								else {
HXLINE( 264)									_hx_tmp6 = this4->id;
            								}
HXDLIN( 264)								_this->last_shader_id = _hx_tmp6;
            							}
HXDLIN( 264)							bool blend_dirty = (_this->last_blend_src_rgb != _this->geom_state->blend_src_rgb);
HXDLIN( 264)							if (!(blend_dirty)) {
HXLINE( 264)								blend_dirty = (_this->last_blend_disabled != _this->geom_state->blend_disabled);
            							}
            							else {
HXLINE( 264)								blend_dirty = true;
            							}
HXDLIN( 264)							if (!(blend_dirty)) {
HXLINE( 264)								blend_dirty = (_this->last_blend_src_alpha != _this->geom_state->blend_src_alpha);
            							}
            							else {
HXLINE( 264)								blend_dirty = true;
            							}
HXDLIN( 264)							if (!(blend_dirty)) {
HXLINE( 264)								blend_dirty = (_this->last_blend_dest_rgb != _this->geom_state->blend_dest_rgb);
            							}
            							else {
HXLINE( 264)								blend_dirty = true;
            							}
HXDLIN( 264)							if (!(blend_dirty)) {
HXLINE( 264)								blend_dirty = (_this->last_blend_dest_alpha != _this->geom_state->blend_dest_alpha);
            							}
            							else {
HXLINE( 264)								blend_dirty = true;
            							}
HXDLIN( 264)							bool _hx_tmp7;
HXDLIN( 264)							if (blend_dirty) {
HXLINE( 264)								_hx_tmp7 = !(_this->geom_state->ignore_blend);
            							}
            							else {
HXLINE( 264)								_hx_tmp7 = false;
            							}
HXDLIN( 264)							if (_hx_tmp7) {
HXLINE( 264)								_this->last_blend_disabled = _this->geom_state->blend_disabled;
HXDLIN( 264)								if (_this->last_blend_disabled) {
HXLINE( 264)									this->renderer->state->disable((int)3042);
            								}
            								else {
HXLINE( 264)									this->renderer->state->enable((int)3042);
            								}
HXDLIN( 264)								_this->last_blend_src_rgb = _this->geom_state->blend_src_rgb;
HXDLIN( 264)								_this->last_blend_src_alpha = _this->geom_state->blend_src_alpha;
HXDLIN( 264)								_this->last_blend_dest_rgb = _this->geom_state->blend_dest_rgb;
HXDLIN( 264)								_this->last_blend_dest_alpha = _this->geom_state->blend_dest_alpha;
HXDLIN( 264)								glBlendFuncSeparate(_this->last_blend_src_rgb,_this->last_blend_dest_rgb,_this->last_blend_src_alpha,_this->last_blend_dest_alpha);
            							}
            						}
HXDLIN( 264)						if (_this->geom_state->clip) {
HXLINE( 264)							if (!(_this->is_clipping)) {
HXLINE( 264)								glEnable((int)3089);
HXDLIN( 264)								_this->is_clipping = true;
            							}
HXDLIN( 264)							if (hx::IsNotNull( _this->clip_rect )) {
HXLINE( 264)								if (!(_this->clip_rect->equal(_this->last_clip_rect))) {
HXLINE( 264)									this->renderer->state->scissor(_this->clip_rect->x,_this->clip_rect->y,_this->clip_rect->w,_this->clip_rect->h);
            								}
            							}
            						}
            						else {
HXLINE( 264)							if (_this->is_clipping) {
HXLINE( 264)								glDisable((int)3089);
HXDLIN( 264)								_this->is_clipping = false;
            							}
            						}
HXDLIN( 264)						_this->geom_state->dirty = false;
            					}
HXLINE( 266)					if (geom->visible) {
HXLINE( 269)						this->visible_count++;
HXLINE( 272)						if (geom->buffer_based) {
HXLINE( 273)							this->visible_count--;
HXLINE( 274)							continue;
            						}
HXLINE( 278)						if (geom->locked) {
HXLINE( 281)							{
HXLINE( 281)								int type1 = this->state->last_geom_state->primitive_type;
HXDLIN( 281)								if ((this->pos_floats != (int)0)) {
HXLINE( 281)									if ((this->pos_floats > this->max_floats)) {
HXLINE( 281)										HX_STACK_DO_THROW(HX_("uh oh, somehow too many floats are being submitted (max:$max_floats, attempt:$pos_floats).",4e,e8,8c,4a));
            									}
HXDLIN( 281)									::Array< unsigned char > _buffer3 = this->pos_list->buffer;
HXDLIN( 281)									int _byteLength3 = (this->pos_floats * (int)4);
HXDLIN( 281)									 ::snow::api::buffers::ArrayBufferView _view3 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 281)									int _bytes_per_elem3 = _view3->bytesPerElement;
HXDLIN( 281)									if ((hx::Mod((int)0,_bytes_per_elem3) != (int)0)) {
HXLINE( 281)										HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            									}
HXDLIN( 281)									int _src_bytelen3 = _buffer3->length;
HXDLIN( 281)									int _new_range3 = _byteLength3;
HXDLIN( 281)									if ((_new_range3 > _src_bytelen3)) {
HXLINE( 281)										HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            									}
HXDLIN( 281)									_view3->buffer = _buffer3;
HXDLIN( 281)									_view3->byteOffset = (int)0;
HXDLIN( 281)									_view3->byteLength = _byteLength3;
HXDLIN( 281)									_view3->length = ::Std_obj::_hx_int(((Float)_byteLength3 / (Float)_bytes_per_elem3));
HXDLIN( 281)									 ::snow::api::buffers::ArrayBufferView _pos1 = _view3;
HXDLIN( 281)									::Array< unsigned char > _buffer4 = this->tcoord_list->buffer;
HXDLIN( 281)									int _byteLength4 = (this->tcoord_floats * (int)4);
HXDLIN( 281)									 ::snow::api::buffers::ArrayBufferView _view4 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 281)									int _bytes_per_elem4 = _view4->bytesPerElement;
HXDLIN( 281)									if ((hx::Mod((int)0,_bytes_per_elem4) != (int)0)) {
HXLINE( 281)										HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            									}
HXDLIN( 281)									int _src_bytelen4 = _buffer4->length;
HXDLIN( 281)									int _new_range4 = _byteLength4;
HXDLIN( 281)									if ((_new_range4 > _src_bytelen4)) {
HXLINE( 281)										HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            									}
HXDLIN( 281)									_view4->buffer = _buffer4;
HXDLIN( 281)									_view4->byteOffset = (int)0;
HXDLIN( 281)									_view4->byteLength = _byteLength4;
HXDLIN( 281)									_view4->length = ::Std_obj::_hx_int(((Float)_byteLength4 / (Float)_bytes_per_elem4));
HXDLIN( 281)									 ::snow::api::buffers::ArrayBufferView _tcoords1 = _view4;
HXDLIN( 281)									::Array< unsigned char > _buffer5 = this->color_list->buffer;
HXDLIN( 281)									int _byteLength5 = (this->color_floats * (int)4);
HXDLIN( 281)									 ::snow::api::buffers::ArrayBufferView _view5 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 281)									int _bytes_per_elem5 = _view5->bytesPerElement;
HXDLIN( 281)									if ((hx::Mod((int)0,_bytes_per_elem5) != (int)0)) {
HXLINE( 281)										HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            									}
HXDLIN( 281)									int _src_bytelen5 = _buffer5->length;
HXDLIN( 281)									int _new_range5 = _byteLength5;
HXDLIN( 281)									if ((_new_range5 > _src_bytelen5)) {
HXLINE( 281)										HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            									}
HXDLIN( 281)									_view5->buffer = _buffer5;
HXDLIN( 281)									_view5->byteOffset = (int)0;
HXDLIN( 281)									_view5->byteLength = _byteLength5;
HXDLIN( 281)									_view5->length = ::Std_obj::_hx_int(((Float)_byteLength5 / (Float)_bytes_per_elem5));
HXDLIN( 281)									 ::snow::api::buffers::ArrayBufferView _colors1 = _view5;
HXDLIN( 281)									 ::snow::api::buffers::ArrayBufferView _normals1 = null();
HXDLIN( 281)									this->submit_buffers(type1,_pos1,_tcoords1,_colors1,_normals1);
HXDLIN( 281)									_pos1 = null();
HXDLIN( 281)									_tcoords1 = null();
HXDLIN( 281)									_colors1 = null();
HXDLIN( 281)									_normals1 = null();
HXDLIN( 281)									this->pos_floats = (int)0;
HXDLIN( 281)									this->tcoord_floats = (int)0;
HXDLIN( 281)									this->color_floats = (int)0;
HXDLIN( 281)									this->normal_floats = (int)0;
            								}
            							}
HXLINE( 283)							{
HXLINE( 283)								int _length = geom->vertices->length;
HXDLIN( 283)								if ((_length != (int)0)) {
HXLINE( 283)									bool _updated = geom->update_buffers();
HXDLIN( 283)									if (_updated) {
HXLINE( 283)										{
HXLINE( 283)											{
HXLINE( 283)												 ::opengl::GLObject buffer = geom->vb_pos;
HXDLIN( 283)												int _hx_tmp8;
HXDLIN( 283)												if (hx::IsNull( buffer )) {
HXLINE( 283)													_hx_tmp8 = (int)0;
            												}
            												else {
HXLINE( 283)													_hx_tmp8 = buffer->id;
            												}
HXDLIN( 283)												glBindBuffer((int)34962,_hx_tmp8);
            											}
HXDLIN( 283)											glVertexAttribPointer((int)0, (int)4, (int)5126, false, (int)0, (void *)(intptr_t)(int)0);
            										}
HXDLIN( 283)										{
HXLINE( 283)											 ::snow::api::buffers::ArrayBufferView data = geom->buffer_pos;
HXDLIN( 283)											int usage = geom->buffer_type;
HXDLIN( 283)											glBufferData((int)34962, data->byteLength, (GLvoid*)(&data->buffer[0] + data->byteOffset), usage);
            										}
HXDLIN( 283)										{
HXLINE( 283)											{
HXLINE( 283)												 ::opengl::GLObject buffer1 = geom->vb_tcoords;
HXDLIN( 283)												int _hx_tmp9;
HXDLIN( 283)												if (hx::IsNull( buffer1 )) {
HXLINE( 283)													_hx_tmp9 = (int)0;
            												}
            												else {
HXLINE( 283)													_hx_tmp9 = buffer1->id;
            												}
HXDLIN( 283)												glBindBuffer((int)34962,_hx_tmp9);
            											}
HXDLIN( 283)											glVertexAttribPointer((int)1, (int)4, (int)5126, false, (int)0, (void *)(intptr_t)(int)0);
            										}
HXDLIN( 283)										{
HXLINE( 283)											 ::snow::api::buffers::ArrayBufferView data1 = geom->buffer_tcoords;
HXDLIN( 283)											int usage1 = geom->buffer_type;
HXDLIN( 283)											glBufferData((int)34962, data1->byteLength, (GLvoid*)(&data1->buffer[0] + data1->byteOffset), usage1);
            										}
HXDLIN( 283)										{
HXLINE( 283)											{
HXLINE( 283)												 ::opengl::GLObject buffer2 = geom->vb_colors;
HXDLIN( 283)												int _hx_tmp10;
HXDLIN( 283)												if (hx::IsNull( buffer2 )) {
HXLINE( 283)													_hx_tmp10 = (int)0;
            												}
            												else {
HXLINE( 283)													_hx_tmp10 = buffer2->id;
            												}
HXDLIN( 283)												glBindBuffer((int)34962,_hx_tmp10);
            											}
HXDLIN( 283)											glVertexAttribPointer((int)2, (int)4, (int)5126, false, (int)0, (void *)(intptr_t)(int)0);
            										}
HXDLIN( 283)										{
HXLINE( 283)											 ::snow::api::buffers::ArrayBufferView data2 = geom->buffer_colors;
HXDLIN( 283)											int usage2 = geom->buffer_type;
HXDLIN( 283)											glBufferData((int)34962, data2->byteLength, (GLvoid*)(&data2->buffer[0] + data2->byteOffset), usage2);
            										}
            									}
            									else {
HXLINE( 283)										{
HXLINE( 283)											{
HXLINE( 283)												 ::opengl::GLObject buffer3 = geom->vb_pos;
HXDLIN( 283)												int _hx_tmp11;
HXDLIN( 283)												if (hx::IsNull( buffer3 )) {
HXLINE( 283)													_hx_tmp11 = (int)0;
            												}
            												else {
HXLINE( 283)													_hx_tmp11 = buffer3->id;
            												}
HXDLIN( 283)												glBindBuffer((int)34962,_hx_tmp11);
            											}
HXDLIN( 283)											glVertexAttribPointer((int)0, (int)4, (int)5126, false, (int)0, (void *)(intptr_t)(int)0);
            										}
HXDLIN( 283)										{
HXLINE( 283)											{
HXLINE( 283)												 ::opengl::GLObject buffer4 = geom->vb_tcoords;
HXDLIN( 283)												int _hx_tmp12;
HXDLIN( 283)												if (hx::IsNull( buffer4 )) {
HXLINE( 283)													_hx_tmp12 = (int)0;
            												}
            												else {
HXLINE( 283)													_hx_tmp12 = buffer4->id;
            												}
HXDLIN( 283)												glBindBuffer((int)34962,_hx_tmp12);
            											}
HXDLIN( 283)											glVertexAttribPointer((int)1, (int)4, (int)5126, false, (int)0, (void *)(intptr_t)(int)0);
            										}
HXDLIN( 283)										{
HXLINE( 283)											{
HXLINE( 283)												 ::opengl::GLObject buffer5 = geom->vb_colors;
HXDLIN( 283)												int _hx_tmp13;
HXDLIN( 283)												if (hx::IsNull( buffer5 )) {
HXLINE( 283)													_hx_tmp13 = (int)0;
            												}
            												else {
HXLINE( 283)													_hx_tmp13 = buffer5->id;
            												}
HXDLIN( 283)												glBindBuffer((int)34962,_hx_tmp13);
            											}
HXDLIN( 283)											glVertexAttribPointer((int)2, (int)4, (int)5126, false, (int)0, (void *)(intptr_t)(int)0);
            										}
            									}
HXDLIN( 283)									{
HXLINE( 283)										int mode = geom->state->primitive_type;
HXDLIN( 283)										glDrawArrays(mode,(int)0,::Std_obj::_hx_int(((Float)geom->buffer_pos->length / (Float)(int)4)));
            									}
HXDLIN( 283)									this->static_batched_count++;
HXDLIN( 283)									this->draw_calls++;
HXDLIN( 283)									geom->set_dirty(false);
            								}
            							}
HXLINE( 284)							 ::phoenix::Batcher _hx_tmp14 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 284)							_hx_tmp14->vert_count = (_hx_tmp14->vert_count + geom->vertices->length);
            						}
            						else {
HXLINE( 288)							bool _hx_tmp15;
HXDLIN( 288)							bool _hx_tmp16;
HXDLIN( 288)							bool _hx_tmp17;
HXDLIN( 288)							if ((geom->state->primitive_type != (int)3)) {
HXLINE( 288)								_hx_tmp17 = (geom->state->primitive_type == (int)2);
            							}
            							else {
HXLINE( 288)								_hx_tmp17 = true;
            							}
HXDLIN( 288)							if (!(_hx_tmp17)) {
HXLINE( 288)								_hx_tmp16 = (geom->state->primitive_type == (int)5);
            							}
            							else {
HXLINE( 288)								_hx_tmp16 = true;
            							}
HXDLIN( 288)							if (!(_hx_tmp16)) {
HXLINE( 288)								_hx_tmp15 = (geom->state->primitive_type == (int)6);
            							}
            							else {
HXLINE( 288)								_hx_tmp15 = true;
            							}
HXDLIN( 288)							if (_hx_tmp15) {
HXLINE( 295)								if ((geom->vertices->length > this->max_verts)) {
HXLINE( 295)									geom->set_locked(true);
HXDLIN( 295)									geom->dirty_based = false;
HXDLIN( 295)									 ::Dynamic _hx_tmp18 = ::haxe::Log_obj::trace;
HXDLIN( 295)									_hx_tmp18((HX_("  i / batcher / ",52,b7,3e,d6) + ((((((((HX_("WARNING batcher `",c3,c3,10,cf) + this->name) + HX_("` trying to batch a geometry `",e3,ef,1f,81)) + geom->id) + HX_("` that has more verts than the batcher has preallocated, (",2d,aa,5e,9c)) + geom->vertices->length) + HX_(" vs max of ",ea,ab,b3,51)) + this->max_verts) + HX_(")",29,00,00,00))),hx::SourceInfo(HX_("Batcher.hx",97,06,68,88),573,HX_("phoenix.Batcher",a8,b2,34,67),HX_("geometry_batch",2d,43,e5,75)));
HXDLIN( 295)									 ::Dynamic _hx_tmp19 = ::haxe::Log_obj::trace;
HXDLIN( 295)									_hx_tmp19((HX_("  i / batcher / ",52,b7,3e,d6) + HX_("WARNING geometry has been marked as direct submit, and will be submitted independently!",1c,f5,10,a5)),hx::SourceInfo(HX_("Batcher.hx",97,06,68,88),574,HX_("phoenix.Batcher",a8,b2,34,67),HX_("geometry_batch",2d,43,e5,75)));
            								}
            								else {
HXLINE( 295)									int geom1 = geom->vertices->length;
HXDLIN( 295)									Float _count_after = (geom1 + ((Float)this->pos_floats / (Float)(int)4));
HXDLIN( 295)									if ((_count_after > this->max_verts)) {
HXLINE( 295)										int type2 = geom->state->primitive_type;
HXDLIN( 295)										if ((this->pos_floats != (int)0)) {
HXLINE( 295)											if ((this->pos_floats > this->max_floats)) {
HXLINE( 295)												HX_STACK_DO_THROW(HX_("uh oh, somehow too many floats are being submitted (max:$max_floats, attempt:$pos_floats).",4e,e8,8c,4a));
            											}
HXDLIN( 295)											::Array< unsigned char > _buffer6 = this->pos_list->buffer;
HXDLIN( 295)											int _byteLength6 = (this->pos_floats * (int)4);
HXDLIN( 295)											 ::snow::api::buffers::ArrayBufferView _view6 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 295)											int _bytes_per_elem6 = _view6->bytesPerElement;
HXDLIN( 295)											if ((hx::Mod((int)0,_bytes_per_elem6) != (int)0)) {
HXLINE( 295)												HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            											}
HXDLIN( 295)											int _src_bytelen6 = _buffer6->length;
HXDLIN( 295)											int _new_range6 = _byteLength6;
HXDLIN( 295)											if ((_new_range6 > _src_bytelen6)) {
HXLINE( 295)												HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            											}
HXDLIN( 295)											_view6->buffer = _buffer6;
HXDLIN( 295)											_view6->byteOffset = (int)0;
HXDLIN( 295)											_view6->byteLength = _byteLength6;
HXDLIN( 295)											_view6->length = ::Std_obj::_hx_int(((Float)_byteLength6 / (Float)_bytes_per_elem6));
HXDLIN( 295)											 ::snow::api::buffers::ArrayBufferView _pos2 = _view6;
HXDLIN( 295)											::Array< unsigned char > _buffer7 = this->tcoord_list->buffer;
HXDLIN( 295)											int _byteLength7 = (this->tcoord_floats * (int)4);
HXDLIN( 295)											 ::snow::api::buffers::ArrayBufferView _view7 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 295)											int _bytes_per_elem7 = _view7->bytesPerElement;
HXDLIN( 295)											if ((hx::Mod((int)0,_bytes_per_elem7) != (int)0)) {
HXLINE( 295)												HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            											}
HXDLIN( 295)											int _src_bytelen7 = _buffer7->length;
HXDLIN( 295)											int _new_range7 = _byteLength7;
HXDLIN( 295)											if ((_new_range7 > _src_bytelen7)) {
HXLINE( 295)												HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            											}
HXDLIN( 295)											_view7->buffer = _buffer7;
HXDLIN( 295)											_view7->byteOffset = (int)0;
HXDLIN( 295)											_view7->byteLength = _byteLength7;
HXDLIN( 295)											_view7->length = ::Std_obj::_hx_int(((Float)_byteLength7 / (Float)_bytes_per_elem7));
HXDLIN( 295)											 ::snow::api::buffers::ArrayBufferView _tcoords2 = _view7;
HXDLIN( 295)											::Array< unsigned char > _buffer8 = this->color_list->buffer;
HXDLIN( 295)											int _byteLength8 = (this->color_floats * (int)4);
HXDLIN( 295)											 ::snow::api::buffers::ArrayBufferView _view8 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 295)											int _bytes_per_elem8 = _view8->bytesPerElement;
HXDLIN( 295)											if ((hx::Mod((int)0,_bytes_per_elem8) != (int)0)) {
HXLINE( 295)												HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            											}
HXDLIN( 295)											int _src_bytelen8 = _buffer8->length;
HXDLIN( 295)											int _new_range8 = _byteLength8;
HXDLIN( 295)											if ((_new_range8 > _src_bytelen8)) {
HXLINE( 295)												HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            											}
HXDLIN( 295)											_view8->buffer = _buffer8;
HXDLIN( 295)											_view8->byteOffset = (int)0;
HXDLIN( 295)											_view8->byteLength = _byteLength8;
HXDLIN( 295)											_view8->length = ::Std_obj::_hx_int(((Float)_byteLength8 / (Float)_bytes_per_elem8));
HXDLIN( 295)											 ::snow::api::buffers::ArrayBufferView _colors2 = _view8;
HXDLIN( 295)											 ::snow::api::buffers::ArrayBufferView _normals2 = null();
HXDLIN( 295)											this->submit_buffers(type2,_pos2,_tcoords2,_colors2,_normals2);
HXDLIN( 295)											_pos2 = null();
HXDLIN( 295)											_tcoords2 = null();
HXDLIN( 295)											_colors2 = null();
HXDLIN( 295)											_normals2 = null();
HXDLIN( 295)											this->pos_floats = (int)0;
HXDLIN( 295)											this->tcoord_floats = (int)0;
HXDLIN( 295)											this->color_floats = (int)0;
HXDLIN( 295)											this->normal_floats = (int)0;
            										}
            									}
HXDLIN( 295)									{
HXLINE( 295)										int vert_index = this->pos_floats;
HXDLIN( 295)										int tcoord_index = this->tcoord_floats;
HXDLIN( 295)										int color_index = this->color_floats;
HXDLIN( 295)										int normal_index = this->normal_floats;
HXDLIN( 295)										 ::snow::api::buffers::ArrayBufferView vertlist = this->pos_list;
HXDLIN( 295)										 ::snow::api::buffers::ArrayBufferView tcoordlist = this->tcoord_list;
HXDLIN( 295)										 ::snow::api::buffers::ArrayBufferView colorlist = this->color_list;
HXDLIN( 295)										 ::snow::api::buffers::ArrayBufferView normallist = this->normal_list;
HXDLIN( 295)										 ::phoenix::Transform _this3 = geom->transform;
HXDLIN( 295)										if (!(_this3->_destroying)) {
HXLINE( 295)											bool _hx_tmp20;
HXDLIN( 295)											if (hx::IsNotNull( _this3->parent )) {
HXLINE( 295)												_hx_tmp20 = _this3->parent->dirty;
            											}
            											else {
HXLINE( 295)												_hx_tmp20 = false;
            											}
HXDLIN( 295)											if (_hx_tmp20) {
HXLINE( 295)												_this3->parent->clean_check();
            											}
HXDLIN( 295)											bool _hx_tmp21;
HXDLIN( 295)											bool _hx_tmp22;
HXDLIN( 295)											if (_this3->dirty) {
HXLINE( 295)												_hx_tmp22 = !(_this3->_cleaning);
            											}
            											else {
HXLINE( 295)												_hx_tmp22 = false;
            											}
HXDLIN( 295)											if (_hx_tmp22) {
HXLINE( 295)												_hx_tmp21 = !(_this3->manual_update);
            											}
            											else {
HXLINE( 295)												_hx_tmp21 = false;
            											}
HXDLIN( 295)											if (_hx_tmp21) {
HXLINE( 295)												_this3->clean();
            											}
            										}
HXDLIN( 295)										 ::phoenix::Matrix _mat = _this3->world->matrix;
HXDLIN( 295)										::Array< Float > _el = _mat->elements;
HXDLIN( 295)										int _count = geom->vertices->length;
HXDLIN( 295)										int _idx = (int)0;
HXDLIN( 295)										while((_idx < _count)){
HXLINE( 295)											 ::phoenix::geometry::Vertex v = geom->vertices->__get(_idx).StaticCast<  ::phoenix::geometry::Vertex >();
HXDLIN( 295)											Float _vx = v->pos->x;
HXDLIN( 295)											Float _vy = v->pos->y;
HXDLIN( 295)											Float _vz = v->pos->z;
HXDLIN( 295)											Float _tvx = (( (Float)(_hx_array_unsafe_get(_el,(int)0)) ) * _vx);
HXDLIN( 295)											Float _tvx1 = (_tvx + (( (Float)(_hx_array_unsafe_get(_el,(int)4)) ) * _vy));
HXDLIN( 295)											Float _tvx2 = (_tvx1 + (( (Float)(_hx_array_unsafe_get(_el,(int)8)) ) * _vz));
HXDLIN( 295)											Float _tvx3 = (_tvx2 + ( (Float)(_hx_array_unsafe_get(_el,(int)12)) ));
HXDLIN( 295)											Float _tvy = (( (Float)(_hx_array_unsafe_get(_el,(int)1)) ) * _vx);
HXDLIN( 295)											Float _tvy1 = (_tvy + (( (Float)(_hx_array_unsafe_get(_el,(int)5)) ) * _vy));
HXDLIN( 295)											Float _tvy2 = (_tvy1 + (( (Float)(_hx_array_unsafe_get(_el,(int)9)) ) * _vz));
HXDLIN( 295)											Float _tvy3 = (_tvy2 + ( (Float)(_hx_array_unsafe_get(_el,(int)13)) ));
HXDLIN( 295)											Float _tvz = (( (Float)(_hx_array_unsafe_get(_el,(int)2)) ) * _vx);
HXDLIN( 295)											Float _tvz1 = (_tvz + (( (Float)(_hx_array_unsafe_get(_el,(int)6)) ) * _vy));
HXDLIN( 295)											Float _tvz2 = (_tvz1 + (( (Float)(_hx_array_unsafe_get(_el,(int)10)) ) * _vz));
HXDLIN( 295)											Float _tvz3 = (_tvz2 + ( (Float)(_hx_array_unsafe_get(_el,(int)14)) ));
HXDLIN( 295)											{
HXLINE( 295)												int vertlist1 = vertlist->byteOffset;
HXDLIN( 295)												::__hxcpp_memory_set_float(vertlist->buffer,(vertlist1 + (vert_index * (int)4)),_tvx3);
            											}
HXDLIN( 295)											{
HXLINE( 295)												int vertlist2 = vertlist->byteOffset;
HXDLIN( 295)												::__hxcpp_memory_set_float(vertlist->buffer,(vertlist2 + ((vert_index + (int)1) * (int)4)),_tvy3);
            											}
HXDLIN( 295)											{
HXLINE( 295)												int vertlist3 = vertlist->byteOffset;
HXDLIN( 295)												::__hxcpp_memory_set_float(vertlist->buffer,(vertlist3 + ((vert_index + (int)2) * (int)4)),_tvz3);
            											}
HXDLIN( 295)											{
HXLINE( 295)												int vertlist4 = vertlist->byteOffset;
HXDLIN( 295)												::__hxcpp_memory_set_float(vertlist->buffer,(vertlist4 + ((vert_index + (int)3) * (int)4)),v->pos->w);
            											}
HXDLIN( 295)											vert_index = (vert_index + (int)4);
HXDLIN( 295)											 ::phoenix::geometry::TextureCoord _vuv = v->uv->uv0;
HXDLIN( 295)											{
HXLINE( 295)												int tcoordlist1 = tcoordlist->byteOffset;
HXDLIN( 295)												::__hxcpp_memory_set_float(tcoordlist->buffer,(tcoordlist1 + (tcoord_index * (int)4)),_vuv->u);
            											}
HXDLIN( 295)											{
HXLINE( 295)												int tcoordlist2 = tcoordlist->byteOffset;
HXDLIN( 295)												::__hxcpp_memory_set_float(tcoordlist->buffer,(tcoordlist2 + ((tcoord_index + (int)1) * (int)4)),_vuv->v);
            											}
HXDLIN( 295)											{
HXLINE( 295)												int tcoordlist3 = tcoordlist->byteOffset;
HXDLIN( 295)												::__hxcpp_memory_set_float(tcoordlist->buffer,(tcoordlist3 + ((tcoord_index + (int)2) * (int)4)),_vuv->w);
            											}
HXDLIN( 295)											{
HXLINE( 295)												int tcoordlist4 = tcoordlist->byteOffset;
HXDLIN( 295)												::__hxcpp_memory_set_float(tcoordlist->buffer,(tcoordlist4 + ((tcoord_index + (int)3) * (int)4)),_vuv->t);
            											}
HXDLIN( 295)											tcoord_index = (tcoord_index + (int)4);
HXDLIN( 295)											{
HXLINE( 295)												int colorlist1 = colorlist->byteOffset;
HXDLIN( 295)												::__hxcpp_memory_set_float(colorlist->buffer,(colorlist1 + (color_index * (int)4)),v->color->r);
            											}
HXDLIN( 295)											{
HXLINE( 295)												int colorlist2 = colorlist->byteOffset;
HXDLIN( 295)												::__hxcpp_memory_set_float(colorlist->buffer,(colorlist2 + ((color_index + (int)1) * (int)4)),v->color->g);
            											}
HXDLIN( 295)											{
HXLINE( 295)												int colorlist3 = colorlist->byteOffset;
HXDLIN( 295)												::__hxcpp_memory_set_float(colorlist->buffer,(colorlist3 + ((color_index + (int)2) * (int)4)),v->color->b);
            											}
HXDLIN( 295)											{
HXLINE( 295)												int colorlist4 = colorlist->byteOffset;
HXDLIN( 295)												::__hxcpp_memory_set_float(colorlist->buffer,(colorlist4 + ((color_index + (int)3) * (int)4)),v->color->a);
            											}
HXDLIN( 295)											color_index = (color_index + (int)4);
HXDLIN( 295)											normal_index = (normal_index + (int)4);
HXDLIN( 295)											_idx = (_idx + (int)1);
            										}
            									}
HXDLIN( 295)									int _length1 = (geom->vertices->length * (int)4);
HXDLIN( 295)									 ::phoenix::Batcher _hx_tmp23 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 295)									_hx_tmp23->pos_floats = (_hx_tmp23->pos_floats + _length1);
HXDLIN( 295)									 ::phoenix::Batcher _hx_tmp24 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 295)									_hx_tmp24->tcoord_floats = (_hx_tmp24->tcoord_floats + _length1);
HXDLIN( 295)									 ::phoenix::Batcher _hx_tmp25 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 295)									_hx_tmp25->color_floats = (_hx_tmp25->color_floats + _length1);
HXDLIN( 295)									 ::phoenix::Batcher _hx_tmp26 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 295)									_hx_tmp26->normal_floats = (_hx_tmp26->normal_floats + _length1);
            								}
HXLINE( 297)								{
HXLINE( 297)									int type3 = geom->state->primitive_type;
HXDLIN( 297)									if ((this->pos_floats != (int)0)) {
HXLINE( 297)										if ((this->pos_floats > this->max_floats)) {
HXLINE( 297)											HX_STACK_DO_THROW(HX_("uh oh, somehow too many floats are being submitted (max:$max_floats, attempt:$pos_floats).",4e,e8,8c,4a));
            										}
HXDLIN( 297)										::Array< unsigned char > _buffer9 = this->pos_list->buffer;
HXDLIN( 297)										int _byteLength9 = (this->pos_floats * (int)4);
HXDLIN( 297)										 ::snow::api::buffers::ArrayBufferView _view9 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 297)										int _bytes_per_elem9 = _view9->bytesPerElement;
HXDLIN( 297)										if ((hx::Mod((int)0,_bytes_per_elem9) != (int)0)) {
HXLINE( 297)											HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            										}
HXDLIN( 297)										int _src_bytelen9 = _buffer9->length;
HXDLIN( 297)										int _new_range9 = _byteLength9;
HXDLIN( 297)										if ((_new_range9 > _src_bytelen9)) {
HXLINE( 297)											HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            										}
HXDLIN( 297)										_view9->buffer = _buffer9;
HXDLIN( 297)										_view9->byteOffset = (int)0;
HXDLIN( 297)										_view9->byteLength = _byteLength9;
HXDLIN( 297)										_view9->length = ::Std_obj::_hx_int(((Float)_byteLength9 / (Float)_bytes_per_elem9));
HXDLIN( 297)										 ::snow::api::buffers::ArrayBufferView _pos3 = _view9;
HXDLIN( 297)										::Array< unsigned char > _buffer10 = this->tcoord_list->buffer;
HXDLIN( 297)										int _byteLength10 = (this->tcoord_floats * (int)4);
HXDLIN( 297)										 ::snow::api::buffers::ArrayBufferView _view10 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 297)										int _bytes_per_elem10 = _view10->bytesPerElement;
HXDLIN( 297)										if ((hx::Mod((int)0,_bytes_per_elem10) != (int)0)) {
HXLINE( 297)											HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            										}
HXDLIN( 297)										int _src_bytelen10 = _buffer10->length;
HXDLIN( 297)										int _new_range10 = _byteLength10;
HXDLIN( 297)										if ((_new_range10 > _src_bytelen10)) {
HXLINE( 297)											HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            										}
HXDLIN( 297)										_view10->buffer = _buffer10;
HXDLIN( 297)										_view10->byteOffset = (int)0;
HXDLIN( 297)										_view10->byteLength = _byteLength10;
HXDLIN( 297)										_view10->length = ::Std_obj::_hx_int(((Float)_byteLength10 / (Float)_bytes_per_elem10));
HXDLIN( 297)										 ::snow::api::buffers::ArrayBufferView _tcoords3 = _view10;
HXDLIN( 297)										::Array< unsigned char > _buffer11 = this->color_list->buffer;
HXDLIN( 297)										int _byteLength11 = (this->color_floats * (int)4);
HXDLIN( 297)										 ::snow::api::buffers::ArrayBufferView _view11 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 297)										int _bytes_per_elem11 = _view11->bytesPerElement;
HXDLIN( 297)										if ((hx::Mod((int)0,_bytes_per_elem11) != (int)0)) {
HXLINE( 297)											HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            										}
HXDLIN( 297)										int _src_bytelen11 = _buffer11->length;
HXDLIN( 297)										int _new_range11 = _byteLength11;
HXDLIN( 297)										if ((_new_range11 > _src_bytelen11)) {
HXLINE( 297)											HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            										}
HXDLIN( 297)										_view11->buffer = _buffer11;
HXDLIN( 297)										_view11->byteOffset = (int)0;
HXDLIN( 297)										_view11->byteLength = _byteLength11;
HXDLIN( 297)										_view11->length = ::Std_obj::_hx_int(((Float)_byteLength11 / (Float)_bytes_per_elem11));
HXDLIN( 297)										 ::snow::api::buffers::ArrayBufferView _colors3 = _view11;
HXDLIN( 297)										 ::snow::api::buffers::ArrayBufferView _normals3 = null();
HXDLIN( 297)										this->submit_buffers(type3,_pos3,_tcoords3,_colors3,_normals3);
HXDLIN( 297)										_pos3 = null();
HXDLIN( 297)										_tcoords3 = null();
HXDLIN( 297)										_colors3 = null();
HXDLIN( 297)										_normals3 = null();
HXDLIN( 297)										this->pos_floats = (int)0;
HXDLIN( 297)										this->tcoord_floats = (int)0;
HXDLIN( 297)										this->color_floats = (int)0;
HXDLIN( 297)										this->normal_floats = (int)0;
            									}
            								}
HXLINE( 299)								 ::phoenix::Batcher _hx_tmp27 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 299)								_hx_tmp27->vert_count = (_hx_tmp27->vert_count + geom->vertices->length);
            							}
            							else {
HXLINE( 306)								if ((geom->vertices->length > this->max_verts)) {
HXLINE( 306)									geom->set_locked(true);
HXDLIN( 306)									geom->dirty_based = false;
HXDLIN( 306)									 ::Dynamic _hx_tmp28 = ::haxe::Log_obj::trace;
HXDLIN( 306)									_hx_tmp28((HX_("  i / batcher / ",52,b7,3e,d6) + ((((((((HX_("WARNING batcher `",c3,c3,10,cf) + this->name) + HX_("` trying to batch a geometry `",e3,ef,1f,81)) + geom->id) + HX_("` that has more verts than the batcher has preallocated, (",2d,aa,5e,9c)) + geom->vertices->length) + HX_(" vs max of ",ea,ab,b3,51)) + this->max_verts) + HX_(")",29,00,00,00))),hx::SourceInfo(HX_("Batcher.hx",97,06,68,88),573,HX_("phoenix.Batcher",a8,b2,34,67),HX_("geometry_batch",2d,43,e5,75)));
HXDLIN( 306)									 ::Dynamic _hx_tmp29 = ::haxe::Log_obj::trace;
HXDLIN( 306)									_hx_tmp29((HX_("  i / batcher / ",52,b7,3e,d6) + HX_("WARNING geometry has been marked as direct submit, and will be submitted independently!",1c,f5,10,a5)),hx::SourceInfo(HX_("Batcher.hx",97,06,68,88),574,HX_("phoenix.Batcher",a8,b2,34,67),HX_("geometry_batch",2d,43,e5,75)));
            								}
            								else {
HXLINE( 306)									int geom2 = geom->vertices->length;
HXDLIN( 306)									Float _count_after1 = (geom2 + ((Float)this->pos_floats / (Float)(int)4));
HXDLIN( 306)									if ((_count_after1 > this->max_verts)) {
HXLINE( 306)										int type4 = geom->state->primitive_type;
HXDLIN( 306)										if ((this->pos_floats != (int)0)) {
HXLINE( 306)											if ((this->pos_floats > this->max_floats)) {
HXLINE( 306)												HX_STACK_DO_THROW(HX_("uh oh, somehow too many floats are being submitted (max:$max_floats, attempt:$pos_floats).",4e,e8,8c,4a));
            											}
HXDLIN( 306)											::Array< unsigned char > _buffer12 = this->pos_list->buffer;
HXDLIN( 306)											int _byteLength12 = (this->pos_floats * (int)4);
HXDLIN( 306)											 ::snow::api::buffers::ArrayBufferView _view12 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 306)											int _bytes_per_elem12 = _view12->bytesPerElement;
HXDLIN( 306)											if ((hx::Mod((int)0,_bytes_per_elem12) != (int)0)) {
HXLINE( 306)												HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            											}
HXDLIN( 306)											int _src_bytelen12 = _buffer12->length;
HXDLIN( 306)											int _new_range12 = _byteLength12;
HXDLIN( 306)											if ((_new_range12 > _src_bytelen12)) {
HXLINE( 306)												HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            											}
HXDLIN( 306)											_view12->buffer = _buffer12;
HXDLIN( 306)											_view12->byteOffset = (int)0;
HXDLIN( 306)											_view12->byteLength = _byteLength12;
HXDLIN( 306)											_view12->length = ::Std_obj::_hx_int(((Float)_byteLength12 / (Float)_bytes_per_elem12));
HXDLIN( 306)											 ::snow::api::buffers::ArrayBufferView _pos4 = _view12;
HXDLIN( 306)											::Array< unsigned char > _buffer13 = this->tcoord_list->buffer;
HXDLIN( 306)											int _byteLength13 = (this->tcoord_floats * (int)4);
HXDLIN( 306)											 ::snow::api::buffers::ArrayBufferView _view13 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 306)											int _bytes_per_elem13 = _view13->bytesPerElement;
HXDLIN( 306)											if ((hx::Mod((int)0,_bytes_per_elem13) != (int)0)) {
HXLINE( 306)												HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            											}
HXDLIN( 306)											int _src_bytelen13 = _buffer13->length;
HXDLIN( 306)											int _new_range13 = _byteLength13;
HXDLIN( 306)											if ((_new_range13 > _src_bytelen13)) {
HXLINE( 306)												HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            											}
HXDLIN( 306)											_view13->buffer = _buffer13;
HXDLIN( 306)											_view13->byteOffset = (int)0;
HXDLIN( 306)											_view13->byteLength = _byteLength13;
HXDLIN( 306)											_view13->length = ::Std_obj::_hx_int(((Float)_byteLength13 / (Float)_bytes_per_elem13));
HXDLIN( 306)											 ::snow::api::buffers::ArrayBufferView _tcoords4 = _view13;
HXDLIN( 306)											::Array< unsigned char > _buffer14 = this->color_list->buffer;
HXDLIN( 306)											int _byteLength14 = (this->color_floats * (int)4);
HXDLIN( 306)											 ::snow::api::buffers::ArrayBufferView _view14 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 306)											int _bytes_per_elem14 = _view14->bytesPerElement;
HXDLIN( 306)											if ((hx::Mod((int)0,_bytes_per_elem14) != (int)0)) {
HXLINE( 306)												HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            											}
HXDLIN( 306)											int _src_bytelen14 = _buffer14->length;
HXDLIN( 306)											int _new_range14 = _byteLength14;
HXDLIN( 306)											if ((_new_range14 > _src_bytelen14)) {
HXLINE( 306)												HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            											}
HXDLIN( 306)											_view14->buffer = _buffer14;
HXDLIN( 306)											_view14->byteOffset = (int)0;
HXDLIN( 306)											_view14->byteLength = _byteLength14;
HXDLIN( 306)											_view14->length = ::Std_obj::_hx_int(((Float)_byteLength14 / (Float)_bytes_per_elem14));
HXDLIN( 306)											 ::snow::api::buffers::ArrayBufferView _colors4 = _view14;
HXDLIN( 306)											 ::snow::api::buffers::ArrayBufferView _normals4 = null();
HXDLIN( 306)											this->submit_buffers(type4,_pos4,_tcoords4,_colors4,_normals4);
HXDLIN( 306)											_pos4 = null();
HXDLIN( 306)											_tcoords4 = null();
HXDLIN( 306)											_colors4 = null();
HXDLIN( 306)											_normals4 = null();
HXDLIN( 306)											this->pos_floats = (int)0;
HXDLIN( 306)											this->tcoord_floats = (int)0;
HXDLIN( 306)											this->color_floats = (int)0;
HXDLIN( 306)											this->normal_floats = (int)0;
            										}
            									}
HXDLIN( 306)									{
HXLINE( 306)										int vert_index1 = this->pos_floats;
HXDLIN( 306)										int tcoord_index1 = this->tcoord_floats;
HXDLIN( 306)										int color_index1 = this->color_floats;
HXDLIN( 306)										int normal_index1 = this->normal_floats;
HXDLIN( 306)										 ::snow::api::buffers::ArrayBufferView vertlist5 = this->pos_list;
HXDLIN( 306)										 ::snow::api::buffers::ArrayBufferView tcoordlist5 = this->tcoord_list;
HXDLIN( 306)										 ::snow::api::buffers::ArrayBufferView colorlist5 = this->color_list;
HXDLIN( 306)										 ::snow::api::buffers::ArrayBufferView normallist1 = this->normal_list;
HXDLIN( 306)										 ::phoenix::Transform _this4 = geom->transform;
HXDLIN( 306)										if (!(_this4->_destroying)) {
HXLINE( 306)											bool _hx_tmp30;
HXDLIN( 306)											if (hx::IsNotNull( _this4->parent )) {
HXLINE( 306)												_hx_tmp30 = _this4->parent->dirty;
            											}
            											else {
HXLINE( 306)												_hx_tmp30 = false;
            											}
HXDLIN( 306)											if (_hx_tmp30) {
HXLINE( 306)												_this4->parent->clean_check();
            											}
HXDLIN( 306)											bool _hx_tmp31;
HXDLIN( 306)											bool _hx_tmp32;
HXDLIN( 306)											if (_this4->dirty) {
HXLINE( 306)												_hx_tmp32 = !(_this4->_cleaning);
            											}
            											else {
HXLINE( 306)												_hx_tmp32 = false;
            											}
HXDLIN( 306)											if (_hx_tmp32) {
HXLINE( 306)												_hx_tmp31 = !(_this4->manual_update);
            											}
            											else {
HXLINE( 306)												_hx_tmp31 = false;
            											}
HXDLIN( 306)											if (_hx_tmp31) {
HXLINE( 306)												_this4->clean();
            											}
            										}
HXDLIN( 306)										 ::phoenix::Matrix _mat1 = _this4->world->matrix;
HXDLIN( 306)										::Array< Float > _el1 = _mat1->elements;
HXDLIN( 306)										int _count1 = geom->vertices->length;
HXDLIN( 306)										int _idx1 = (int)0;
HXDLIN( 306)										while((_idx1 < _count1)){
HXLINE( 306)											 ::phoenix::geometry::Vertex v1 = geom->vertices->__get(_idx1).StaticCast<  ::phoenix::geometry::Vertex >();
HXDLIN( 306)											Float _vx1 = v1->pos->x;
HXDLIN( 306)											Float _vy1 = v1->pos->y;
HXDLIN( 306)											Float _vz1 = v1->pos->z;
HXDLIN( 306)											Float _tvx4 = (( (Float)(_hx_array_unsafe_get(_el1,(int)0)) ) * _vx1);
HXDLIN( 306)											Float _tvx5 = (_tvx4 + (( (Float)(_hx_array_unsafe_get(_el1,(int)4)) ) * _vy1));
HXDLIN( 306)											Float _tvx6 = (_tvx5 + (( (Float)(_hx_array_unsafe_get(_el1,(int)8)) ) * _vz1));
HXDLIN( 306)											Float _tvx7 = (_tvx6 + ( (Float)(_hx_array_unsafe_get(_el1,(int)12)) ));
HXDLIN( 306)											Float _tvy4 = (( (Float)(_hx_array_unsafe_get(_el1,(int)1)) ) * _vx1);
HXDLIN( 306)											Float _tvy5 = (_tvy4 + (( (Float)(_hx_array_unsafe_get(_el1,(int)5)) ) * _vy1));
HXDLIN( 306)											Float _tvy6 = (_tvy5 + (( (Float)(_hx_array_unsafe_get(_el1,(int)9)) ) * _vz1));
HXDLIN( 306)											Float _tvy7 = (_tvy6 + ( (Float)(_hx_array_unsafe_get(_el1,(int)13)) ));
HXDLIN( 306)											Float _tvz4 = (( (Float)(_hx_array_unsafe_get(_el1,(int)2)) ) * _vx1);
HXDLIN( 306)											Float _tvz5 = (_tvz4 + (( (Float)(_hx_array_unsafe_get(_el1,(int)6)) ) * _vy1));
HXDLIN( 306)											Float _tvz6 = (_tvz5 + (( (Float)(_hx_array_unsafe_get(_el1,(int)10)) ) * _vz1));
HXDLIN( 306)											Float _tvz7 = (_tvz6 + ( (Float)(_hx_array_unsafe_get(_el1,(int)14)) ));
HXDLIN( 306)											{
HXLINE( 306)												int vertlist6 = vertlist5->byteOffset;
HXDLIN( 306)												::__hxcpp_memory_set_float(vertlist5->buffer,(vertlist6 + (vert_index1 * (int)4)),_tvx7);
            											}
HXDLIN( 306)											{
HXLINE( 306)												int vertlist7 = vertlist5->byteOffset;
HXDLIN( 306)												::__hxcpp_memory_set_float(vertlist5->buffer,(vertlist7 + ((vert_index1 + (int)1) * (int)4)),_tvy7);
            											}
HXDLIN( 306)											{
HXLINE( 306)												int vertlist8 = vertlist5->byteOffset;
HXDLIN( 306)												::__hxcpp_memory_set_float(vertlist5->buffer,(vertlist8 + ((vert_index1 + (int)2) * (int)4)),_tvz7);
            											}
HXDLIN( 306)											{
HXLINE( 306)												int vertlist9 = vertlist5->byteOffset;
HXDLIN( 306)												::__hxcpp_memory_set_float(vertlist5->buffer,(vertlist9 + ((vert_index1 + (int)3) * (int)4)),v1->pos->w);
            											}
HXDLIN( 306)											vert_index1 = (vert_index1 + (int)4);
HXDLIN( 306)											 ::phoenix::geometry::TextureCoord _vuv1 = v1->uv->uv0;
HXDLIN( 306)											{
HXLINE( 306)												int tcoordlist6 = tcoordlist5->byteOffset;
HXDLIN( 306)												::__hxcpp_memory_set_float(tcoordlist5->buffer,(tcoordlist6 + (tcoord_index1 * (int)4)),_vuv1->u);
            											}
HXDLIN( 306)											{
HXLINE( 306)												int tcoordlist7 = tcoordlist5->byteOffset;
HXDLIN( 306)												::__hxcpp_memory_set_float(tcoordlist5->buffer,(tcoordlist7 + ((tcoord_index1 + (int)1) * (int)4)),_vuv1->v);
            											}
HXDLIN( 306)											{
HXLINE( 306)												int tcoordlist8 = tcoordlist5->byteOffset;
HXDLIN( 306)												::__hxcpp_memory_set_float(tcoordlist5->buffer,(tcoordlist8 + ((tcoord_index1 + (int)2) * (int)4)),_vuv1->w);
            											}
HXDLIN( 306)											{
HXLINE( 306)												int tcoordlist9 = tcoordlist5->byteOffset;
HXDLIN( 306)												::__hxcpp_memory_set_float(tcoordlist5->buffer,(tcoordlist9 + ((tcoord_index1 + (int)3) * (int)4)),_vuv1->t);
            											}
HXDLIN( 306)											tcoord_index1 = (tcoord_index1 + (int)4);
HXDLIN( 306)											{
HXLINE( 306)												int colorlist6 = colorlist5->byteOffset;
HXDLIN( 306)												::__hxcpp_memory_set_float(colorlist5->buffer,(colorlist6 + (color_index1 * (int)4)),v1->color->r);
            											}
HXDLIN( 306)											{
HXLINE( 306)												int colorlist7 = colorlist5->byteOffset;
HXDLIN( 306)												::__hxcpp_memory_set_float(colorlist5->buffer,(colorlist7 + ((color_index1 + (int)1) * (int)4)),v1->color->g);
            											}
HXDLIN( 306)											{
HXLINE( 306)												int colorlist8 = colorlist5->byteOffset;
HXDLIN( 306)												::__hxcpp_memory_set_float(colorlist5->buffer,(colorlist8 + ((color_index1 + (int)2) * (int)4)),v1->color->b);
            											}
HXDLIN( 306)											{
HXLINE( 306)												int colorlist9 = colorlist5->byteOffset;
HXDLIN( 306)												::__hxcpp_memory_set_float(colorlist5->buffer,(colorlist9 + ((color_index1 + (int)3) * (int)4)),v1->color->a);
            											}
HXDLIN( 306)											color_index1 = (color_index1 + (int)4);
HXDLIN( 306)											normal_index1 = (normal_index1 + (int)4);
HXDLIN( 306)											_idx1 = (_idx1 + (int)1);
            										}
            									}
HXDLIN( 306)									int _length2 = (geom->vertices->length * (int)4);
HXDLIN( 306)									 ::phoenix::Batcher _hx_tmp33 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 306)									_hx_tmp33->pos_floats = (_hx_tmp33->pos_floats + _length2);
HXDLIN( 306)									 ::phoenix::Batcher _hx_tmp34 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 306)									_hx_tmp34->tcoord_floats = (_hx_tmp34->tcoord_floats + _length2);
HXDLIN( 306)									 ::phoenix::Batcher _hx_tmp35 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 306)									_hx_tmp35->color_floats = (_hx_tmp35->color_floats + _length2);
HXDLIN( 306)									 ::phoenix::Batcher _hx_tmp36 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 306)									_hx_tmp36->normal_floats = (_hx_tmp36->normal_floats + _length2);
            								}
HXLINE( 309)								this->dynamic_batched_count++;
HXLINE( 310)								 ::phoenix::Batcher _hx_tmp37 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 310)								_hx_tmp37->vert_count = (_hx_tmp37->vert_count + geom->vertices->length);
            							}
            						}
HXLINE( 317)						bool _hx_tmp38;
HXDLIN( 317)						if (!(persist_immediate)) {
HXLINE( 317)							_hx_tmp38 = geom->immediate;
            						}
            						else {
HXLINE( 317)							_hx_tmp38 = false;
            						}
HXDLIN( 317)						if (_hx_tmp38) {
HXLINE( 319)							geom->dropped = true;
HXLINE( 321)							this->_dropped->push(geom);
            						}
            					}
            				}
            			}
            			_hx_goto_13:;
            		}
HXLINE( 331)		bool _hx_tmp39;
HXDLIN( 331)		if ((this->pos_floats > (int)0)) {
HXLINE( 331)			_hx_tmp39 = hx::IsNotNull( geom );
            		}
            		else {
HXLINE( 331)			_hx_tmp39 = false;
            		}
HXDLIN( 331)		if (_hx_tmp39) {
HXLINE( 334)			this->state->update(geom);
HXLINE( 336)			{
HXLINE( 336)				 ::phoenix::BatchState _this5 = this->state;
HXDLIN( 336)				if (_this5->geom_state->dirty) {
HXLINE( 336)					if (hx::IsNotNull( _this5->geom_state->texture )) {
HXLINE( 336)						if (hx::IsNotEq( _this5->last_texture_id,_this5->geom_state->texture->id )) {
HXLINE( 336)							_this5->last_texture_id = _this5->geom_state->texture->id;
HXDLIN( 336)							if (hx::IsNotNull( _this5->geom_state->texture->texture )) {
HXLINE( 336)								_this5->geom_state->texture->bind();
            							}
            						}
            					}
            					else {
HXLINE( 336)						::Luxe_obj::renderer->state->bindTexture2D(null());
HXDLIN( 336)						_this5->last_texture_id = null();
            					}
HXDLIN( 336)					 ::phoenix::Shader _shader1;
HXDLIN( 336)					if (hx::IsNull( this->shader )) {
HXLINE( 336)						_shader1 = _this5->geom_state->shader;
            					}
            					else {
HXLINE( 336)						_shader1 = this->shader;
            					}
HXDLIN( 336)					if (hx::IsNull( _shader1 )) {
HXLINE( 336)						if (hx::IsNotNull( _this5->geom_state->texture )) {
HXLINE( 336)							_shader1 = ( ( ::phoenix::Shader)( ::Dynamic(this->renderer->shaders->__Field(HX_("textured",29,f7,ce,65),hx::paccDynamic))->__Field(HX_("shader",25,bf,20,1d),hx::paccDynamic)) );
            						}
            						else {
HXLINE( 336)							_shader1 = ( ( ::phoenix::Shader)( ::Dynamic(this->renderer->shaders->__Field(HX_("plain",0a,fa,8d,c4),hx::paccDynamic))->__Field(HX_("shader",25,bf,20,1d),hx::paccDynamic)) );
            						}
            					}
HXDLIN( 336)					 ::opengl::GLObject this5 =  ::opengl::GLObject_obj::__alloc( HX_CTX ,( (int)(_this5->last_shader_id) ));
HXDLIN( 336)					if (hx::IsNotEq( this5,_shader1->program )) {
HXLINE( 336)						if (!(_shader1->no_default_uniforms)) {
HXLINE( 336)							{
HXLINE( 336)								 ::snow::api::buffers::ArrayBufferView _value2 = this->view->proj_arr;
HXDLIN( 336)								{
HXLINE( 336)									 ::phoenix::Uniforms _this6 = _shader1->uniforms;
HXDLIN( 336)									 ::opengl::GLObject program2 = _shader1->program;
HXDLIN( 336)									int _id2;
HXDLIN( 336)									if (hx::IsNull( program2 )) {
HXLINE( 336)										_id2 = (int)0;
            									}
            									else {
HXLINE( 336)										_id2 = program2->id;
            									}
HXDLIN( 336)									 ::opengl::GLObject this6 =  ::opengl::GLObject_obj::__alloc( HX_CTX ,glGetUniformLocation(_id2,HX_("projectionMatrix",30,88,bb,d0)));
HXDLIN( 336)									 ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array _matrix42 = ( ( ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array)(::haxe::IMap_obj::get(_this6->matrix4arrs,HX_("projectionMatrix",30,88,bb,d0))) );
HXDLIN( 336)									if (hx::IsNotNull( _matrix42 )) {
HXLINE( 336)										_matrix42->value = _value2;
            									}
            									else {
HXLINE( 336)										_matrix42 =  ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array_obj::__alloc( HX_CTX ,HX_("projectionMatrix",30,88,bb,d0),_value2,this6);
HXDLIN( 336)										::haxe::IMap_obj::set(_this6->matrix4arrs,HX_("projectionMatrix",30,88,bb,d0),_matrix42);
            									}
HXDLIN( 336)									_this6->dirty_matrix4arrs->push(_matrix42);
            								}
            							}
HXDLIN( 336)							{
HXLINE( 336)								 ::snow::api::buffers::ArrayBufferView _value3 = this->view->view_inverse_arr;
HXDLIN( 336)								{
HXLINE( 336)									 ::phoenix::Uniforms _this7 = _shader1->uniforms;
HXDLIN( 336)									 ::opengl::GLObject program3 = _shader1->program;
HXDLIN( 336)									int _id3;
HXDLIN( 336)									if (hx::IsNull( program3 )) {
HXLINE( 336)										_id3 = (int)0;
            									}
            									else {
HXLINE( 336)										_id3 = program3->id;
            									}
HXDLIN( 336)									 ::opengl::GLObject this7 =  ::opengl::GLObject_obj::__alloc( HX_CTX ,glGetUniformLocation(_id3,HX_("modelViewMatrix",8f,eb,9c,59)));
HXDLIN( 336)									 ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array _matrix43 = ( ( ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array)(::haxe::IMap_obj::get(_this7->matrix4arrs,HX_("modelViewMatrix",8f,eb,9c,59))) );
HXDLIN( 336)									if (hx::IsNotNull( _matrix43 )) {
HXLINE( 336)										_matrix43->value = _value3;
            									}
            									else {
HXLINE( 336)										_matrix43 =  ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array_obj::__alloc( HX_CTX ,HX_("modelViewMatrix",8f,eb,9c,59),_value3,this7);
HXDLIN( 336)										::haxe::IMap_obj::set(_this7->matrix4arrs,HX_("modelViewMatrix",8f,eb,9c,59),_matrix43);
            									}
HXDLIN( 336)									_this7->dirty_matrix4arrs->push(_matrix43);
            								}
            							}
            						}
HXDLIN( 336)						{
HXLINE( 336)							_shader1->use();
HXDLIN( 336)							_shader1->uniforms->apply();
HXDLIN( 336)							::Luxe_obj::renderer->state->activeTexture((int)33984);
            						}
HXDLIN( 336)						 ::opengl::GLObject this8 = _shader1->program;
HXDLIN( 336)						 ::Dynamic _hx_tmp40;
HXDLIN( 336)						if (hx::IsNull( this8 )) {
HXLINE( 336)							_hx_tmp40 = (int)0;
            						}
            						else {
HXLINE( 336)							_hx_tmp40 = this8->id;
            						}
HXDLIN( 336)						_this5->last_shader_id = _hx_tmp40;
            					}
HXDLIN( 336)					bool blend_dirty1 = (_this5->last_blend_src_rgb != _this5->geom_state->blend_src_rgb);
HXDLIN( 336)					if (!(blend_dirty1)) {
HXLINE( 336)						blend_dirty1 = (_this5->last_blend_disabled != _this5->geom_state->blend_disabled);
            					}
            					else {
HXLINE( 336)						blend_dirty1 = true;
            					}
HXDLIN( 336)					if (!(blend_dirty1)) {
HXLINE( 336)						blend_dirty1 = (_this5->last_blend_src_alpha != _this5->geom_state->blend_src_alpha);
            					}
            					else {
HXLINE( 336)						blend_dirty1 = true;
            					}
HXDLIN( 336)					if (!(blend_dirty1)) {
HXLINE( 336)						blend_dirty1 = (_this5->last_blend_dest_rgb != _this5->geom_state->blend_dest_rgb);
            					}
            					else {
HXLINE( 336)						blend_dirty1 = true;
            					}
HXDLIN( 336)					if (!(blend_dirty1)) {
HXLINE( 336)						blend_dirty1 = (_this5->last_blend_dest_alpha != _this5->geom_state->blend_dest_alpha);
            					}
            					else {
HXLINE( 336)						blend_dirty1 = true;
            					}
HXDLIN( 336)					bool _hx_tmp41;
HXDLIN( 336)					if (blend_dirty1) {
HXLINE( 336)						_hx_tmp41 = !(_this5->geom_state->ignore_blend);
            					}
            					else {
HXLINE( 336)						_hx_tmp41 = false;
            					}
HXDLIN( 336)					if (_hx_tmp41) {
HXLINE( 336)						_this5->last_blend_disabled = _this5->geom_state->blend_disabled;
HXDLIN( 336)						if (_this5->last_blend_disabled) {
HXLINE( 336)							this->renderer->state->disable((int)3042);
            						}
            						else {
HXLINE( 336)							this->renderer->state->enable((int)3042);
            						}
HXDLIN( 336)						_this5->last_blend_src_rgb = _this5->geom_state->blend_src_rgb;
HXDLIN( 336)						_this5->last_blend_src_alpha = _this5->geom_state->blend_src_alpha;
HXDLIN( 336)						_this5->last_blend_dest_rgb = _this5->geom_state->blend_dest_rgb;
HXDLIN( 336)						_this5->last_blend_dest_alpha = _this5->geom_state->blend_dest_alpha;
HXDLIN( 336)						glBlendFuncSeparate(_this5->last_blend_src_rgb,_this5->last_blend_dest_rgb,_this5->last_blend_src_alpha,_this5->last_blend_dest_alpha);
            					}
            				}
HXDLIN( 336)				if (_this5->geom_state->clip) {
HXLINE( 336)					if (!(_this5->is_clipping)) {
HXLINE( 336)						glEnable((int)3089);
HXDLIN( 336)						_this5->is_clipping = true;
            					}
HXDLIN( 336)					if (hx::IsNotNull( _this5->clip_rect )) {
HXLINE( 336)						if (!(_this5->clip_rect->equal(_this5->last_clip_rect))) {
HXLINE( 336)							this->renderer->state->scissor(_this5->clip_rect->x,_this5->clip_rect->y,_this5->clip_rect->w,_this5->clip_rect->h);
            						}
            					}
            				}
            				else {
HXLINE( 336)					if (_this5->is_clipping) {
HXLINE( 336)						glDisable((int)3089);
HXDLIN( 336)						_this5->is_clipping = false;
            					}
            				}
HXDLIN( 336)				_this5->geom_state->dirty = false;
            			}
HXLINE( 338)			{
HXLINE( 338)				int type5 = this->state->last_geom_state->primitive_type;
HXDLIN( 338)				if ((this->pos_floats != (int)0)) {
HXLINE( 338)					if ((this->pos_floats > this->max_floats)) {
HXLINE( 338)						HX_STACK_DO_THROW(HX_("uh oh, somehow too many floats are being submitted (max:$max_floats, attempt:$pos_floats).",4e,e8,8c,4a));
            					}
HXDLIN( 338)					::Array< unsigned char > _buffer15 = this->pos_list->buffer;
HXDLIN( 338)					int _byteLength15 = (this->pos_floats * (int)4);
HXDLIN( 338)					 ::snow::api::buffers::ArrayBufferView _view15 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 338)					int _bytes_per_elem15 = _view15->bytesPerElement;
HXDLIN( 338)					if ((hx::Mod((int)0,_bytes_per_elem15) != (int)0)) {
HXLINE( 338)						HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            					}
HXDLIN( 338)					int _src_bytelen15 = _buffer15->length;
HXDLIN( 338)					int _new_range15 = _byteLength15;
HXDLIN( 338)					if ((_new_range15 > _src_bytelen15)) {
HXLINE( 338)						HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            					}
HXDLIN( 338)					_view15->buffer = _buffer15;
HXDLIN( 338)					_view15->byteOffset = (int)0;
HXDLIN( 338)					_view15->byteLength = _byteLength15;
HXDLIN( 338)					_view15->length = ::Std_obj::_hx_int(((Float)_byteLength15 / (Float)_bytes_per_elem15));
HXDLIN( 338)					 ::snow::api::buffers::ArrayBufferView _pos5 = _view15;
HXDLIN( 338)					::Array< unsigned char > _buffer16 = this->tcoord_list->buffer;
HXDLIN( 338)					int _byteLength16 = (this->tcoord_floats * (int)4);
HXDLIN( 338)					 ::snow::api::buffers::ArrayBufferView _view16 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 338)					int _bytes_per_elem16 = _view16->bytesPerElement;
HXDLIN( 338)					if ((hx::Mod((int)0,_bytes_per_elem16) != (int)0)) {
HXLINE( 338)						HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            					}
HXDLIN( 338)					int _src_bytelen16 = _buffer16->length;
HXDLIN( 338)					int _new_range16 = _byteLength16;
HXDLIN( 338)					if ((_new_range16 > _src_bytelen16)) {
HXLINE( 338)						HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            					}
HXDLIN( 338)					_view16->buffer = _buffer16;
HXDLIN( 338)					_view16->byteOffset = (int)0;
HXDLIN( 338)					_view16->byteLength = _byteLength16;
HXDLIN( 338)					_view16->length = ::Std_obj::_hx_int(((Float)_byteLength16 / (Float)_bytes_per_elem16));
HXDLIN( 338)					 ::snow::api::buffers::ArrayBufferView _tcoords5 = _view16;
HXDLIN( 338)					::Array< unsigned char > _buffer17 = this->color_list->buffer;
HXDLIN( 338)					int _byteLength17 = (this->color_floats * (int)4);
HXDLIN( 338)					 ::snow::api::buffers::ArrayBufferView _view17 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 338)					int _bytes_per_elem17 = _view17->bytesPerElement;
HXDLIN( 338)					if ((hx::Mod((int)0,_bytes_per_elem17) != (int)0)) {
HXLINE( 338)						HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            					}
HXDLIN( 338)					int _src_bytelen17 = _buffer17->length;
HXDLIN( 338)					int _new_range17 = _byteLength17;
HXDLIN( 338)					if ((_new_range17 > _src_bytelen17)) {
HXLINE( 338)						HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            					}
HXDLIN( 338)					_view17->buffer = _buffer17;
HXDLIN( 338)					_view17->byteOffset = (int)0;
HXDLIN( 338)					_view17->byteLength = _byteLength17;
HXDLIN( 338)					_view17->length = ::Std_obj::_hx_int(((Float)_byteLength17 / (Float)_bytes_per_elem17));
HXDLIN( 338)					 ::snow::api::buffers::ArrayBufferView _colors5 = _view17;
HXDLIN( 338)					 ::snow::api::buffers::ArrayBufferView _normals5 = null();
HXDLIN( 338)					this->submit_buffers(type5,_pos5,_tcoords5,_colors5,_normals5);
HXDLIN( 338)					_pos5 = null();
HXDLIN( 338)					_tcoords5 = null();
HXDLIN( 338)					_colors5 = null();
HXDLIN( 338)					_normals5 = null();
HXDLIN( 338)					this->pos_floats = (int)0;
HXDLIN( 338)					this->tcoord_floats = (int)0;
HXDLIN( 338)					this->color_floats = (int)0;
HXDLIN( 338)					this->normal_floats = (int)0;
            				}
            			}
            		}
HXLINE( 343)		this->state->deactivate(hx::ObjectPtr<OBJ_>(this));
HXLINE( 345)		this->state = null();
HXLINE( 347)		if ((this->_dropped->length > (int)0)) {
HXLINE( 347)			{
HXLINE( 347)				int _g1 = (int)0;
HXDLIN( 347)				::Array< ::Dynamic> _g11 = this->_dropped;
HXDLIN( 347)				while((_g1 < _g11->length)){
HXLINE( 347)					 ::phoenix::geometry::Geometry geom3 = _g11->__get(_g1).StaticCast<  ::phoenix::geometry::Geometry >();
HXDLIN( 347)					_g1 = (_g1 + (int)1);
HXDLIN( 347)					geom3->drop(null());
HXDLIN( 347)					geom3 = null();
            				}
            			}
HXDLIN( 347)			this->_dropped = null();
HXDLIN( 347)			this->_dropped = ::Array_obj< ::Dynamic>::__new(0);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Batcher_obj,batch,(void))

void Batcher_obj::prune(){
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_354_prune)
HXDLIN( 354)		if ((this->_dropped->length > (int)0)) {
HXLINE( 355)			{
HXLINE( 355)				int _g = (int)0;
HXDLIN( 355)				::Array< ::Dynamic> _g1 = this->_dropped;
HXDLIN( 355)				while((_g < _g1->length)){
HXLINE( 355)					 ::phoenix::geometry::Geometry geom = _g1->__get(_g).StaticCast<  ::phoenix::geometry::Geometry >();
HXDLIN( 355)					_g = (_g + (int)1);
HXLINE( 356)					geom->drop(null());
HXLINE( 357)					geom = null();
            				}
            			}
HXLINE( 359)			this->_dropped = null();
HXLINE( 360)			this->_dropped = ::Array_obj< ::Dynamic>::__new(0);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Batcher_obj,prune,(void))

void Batcher_obj::draw( ::Dynamic __o_persist_immediate){
 ::Dynamic persist_immediate = __o_persist_immediate.Default(false);
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_366_draw)
HXLINE( 368)		if ((this->name != HX_("",00,00,00,00))) {
HXLINE( 368)			::Luxe_obj::debug->start(this->name,null());
            		}
HXLINE( 371)		this->draw_calls = (int)0;
HXLINE( 372)		this->vert_count = (int)0;
HXLINE( 374)		this->emitter->emit((int)1,hx::ObjectPtr<OBJ_>(this));
HXLINE( 376)		{
HXLINE( 376)			this->view->process();
HXDLIN( 376)			this->renderer->state->viewport(this->view->viewport->x,this->view->viewport->y,this->view->viewport->w,this->view->viewport->h);
            		}
HXLINE( 378)		this->batch(persist_immediate);
HXLINE( 380)		this->emitter->emit((int)2,hx::ObjectPtr<OBJ_>(this));
HXLINE( 382)		 ::phoenix::RendererStats _stats = this->renderer->stats;
HXLINE( 383)		 ::phoenix::RendererStats _stats1 = _stats;
HXDLIN( 383)		 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _node = this->geometry->root;
HXDLIN( 383)		int _hx_tmp;
HXDLIN( 383)		if (hx::IsNull( _node )) {
HXLINE( 383)			_hx_tmp = (int)0;
            		}
            		else {
HXLINE( 383)			_hx_tmp = _node->nodecount;
            		}
HXDLIN( 383)		_stats1->geometry_count = (_stats1->geometry_count + (_hx_tmp * this->show_stats));
HXLINE( 384)		 ::phoenix::RendererStats _stats2 = _stats;
HXDLIN( 384)		_stats2->dynamic_batched_count = (_stats2->dynamic_batched_count + (this->dynamic_batched_count * this->show_stats));
HXLINE( 385)		 ::phoenix::RendererStats _stats3 = _stats;
HXDLIN( 385)		_stats3->static_batched_count = (_stats3->static_batched_count + (this->static_batched_count * this->show_stats));
HXLINE( 386)		 ::phoenix::RendererStats _stats4 = _stats;
HXDLIN( 386)		_stats4->visible_count = (_stats4->visible_count + (this->visible_count * this->show_stats));
HXLINE( 387)		 ::phoenix::RendererStats _stats5 = _stats;
HXDLIN( 387)		_stats5->draw_calls = (_stats5->draw_calls + (this->draw_calls * this->show_stats));
HXLINE( 388)		 ::phoenix::RendererStats _stats6 = _stats;
HXDLIN( 388)		_stats6->vert_count = (_stats6->vert_count + (this->vert_count * this->show_stats));
HXLINE( 390)		if ((this->name != HX_("",00,00,00,00))) {
HXLINE( 390)			::Luxe_obj::debug->end(this->name);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Batcher_obj,draw,(void))

void Batcher_obj::update_view(){
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_396_update_view)
HXLINE( 399)		this->view->process();
HXLINE( 404)		this->renderer->state->viewport(this->view->viewport->x,this->view->viewport->y,this->view->viewport->w,this->view->viewport->h);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Batcher_obj,update_view,(void))

void Batcher_obj::apply_default_uniforms( ::phoenix::Shader _shader){
            	HX_GC_STACKFRAME(&_hx_pos_8831ea6108d72700_411_apply_default_uniforms)
HXDLIN( 411)		if (!(_shader->no_default_uniforms)) {
HXLINE( 412)			{
HXLINE( 412)				 ::snow::api::buffers::ArrayBufferView _value = this->view->proj_arr;
HXDLIN( 412)				{
HXLINE( 412)					 ::phoenix::Uniforms _this = _shader->uniforms;
HXDLIN( 412)					 ::opengl::GLObject program = _shader->program;
HXDLIN( 412)					int _id;
HXDLIN( 412)					if (hx::IsNull( program )) {
HXLINE( 412)						_id = (int)0;
            					}
            					else {
HXLINE( 412)						_id = program->id;
            					}
HXDLIN( 412)					 ::opengl::GLObject this1 =  ::opengl::GLObject_obj::__alloc( HX_CTX ,glGetUniformLocation(_id,HX_("projectionMatrix",30,88,bb,d0)));
HXDLIN( 412)					 ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array _matrix4 = ( ( ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array)(::haxe::IMap_obj::get(_this->matrix4arrs,HX_("projectionMatrix",30,88,bb,d0))) );
HXDLIN( 412)					if (hx::IsNotNull( _matrix4 )) {
HXLINE( 412)						_matrix4->value = _value;
            					}
            					else {
HXLINE( 412)						_matrix4 =  ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array_obj::__alloc( HX_CTX ,HX_("projectionMatrix",30,88,bb,d0),_value,this1);
HXDLIN( 412)						::haxe::IMap_obj::set(_this->matrix4arrs,HX_("projectionMatrix",30,88,bb,d0),_matrix4);
            					}
HXDLIN( 412)					_this->dirty_matrix4arrs->push(_matrix4);
            				}
            			}
HXLINE( 413)			{
HXLINE( 413)				 ::snow::api::buffers::ArrayBufferView _value1 = this->view->view_inverse_arr;
HXDLIN( 413)				{
HXLINE( 413)					 ::phoenix::Uniforms _this1 = _shader->uniforms;
HXDLIN( 413)					 ::opengl::GLObject program1 = _shader->program;
HXDLIN( 413)					int _id1;
HXDLIN( 413)					if (hx::IsNull( program1 )) {
HXLINE( 413)						_id1 = (int)0;
            					}
            					else {
HXLINE( 413)						_id1 = program1->id;
            					}
HXDLIN( 413)					 ::opengl::GLObject this2 =  ::opengl::GLObject_obj::__alloc( HX_CTX ,glGetUniformLocation(_id1,HX_("modelViewMatrix",8f,eb,9c,59)));
HXDLIN( 413)					 ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array _matrix41 = ( ( ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array)(::haxe::IMap_obj::get(_this1->matrix4arrs,HX_("modelViewMatrix",8f,eb,9c,59))) );
HXDLIN( 413)					if (hx::IsNotNull( _matrix41 )) {
HXLINE( 413)						_matrix41->value = _value1;
            					}
            					else {
HXLINE( 413)						_matrix41 =  ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array_obj::__alloc( HX_CTX ,HX_("modelViewMatrix",8f,eb,9c,59),_value1,this2);
HXDLIN( 413)						::haxe::IMap_obj::set(_this1->matrix4arrs,HX_("modelViewMatrix",8f,eb,9c,59),_matrix41);
            					}
HXDLIN( 413)					_this1->dirty_matrix4arrs->push(_matrix41);
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Batcher_obj,apply_default_uniforms,(void))

void Batcher_obj::submit_geometry( ::phoenix::geometry::Geometry _geom, ::phoenix::Shader _shader){
            	HX_GC_STACKFRAME(&_hx_pos_8831ea6108d72700_421_submit_geometry)
HXLINE( 423)		if (!(_geom->buffer_based)) {
HXLINE( 423)			HX_STACK_DO_THROW(::luxe::DebugError_obj::assertion((HX_("_geom.buffer_based",27,99,8e,98) + ((HX_(" ( ",18,6b,18,00) + HX_("Only buffer based geometry can be submitted directly",93,42,d4,d6)) + HX_(" )",09,1c,00,00)))));
            		}
HXLINE( 425)		if (!(_geom->visible)) {
HXLINE( 425)			return;
            		}
HXLINE( 426)		if (hx::IsNull( _shader )) {
HXLINE( 426)			_shader = _geom->state->shader;
            		}
HXLINE( 427)		if (hx::IsNotNull( this->shader )) {
HXLINE( 427)			_shader = this->shader;
            		}
HXLINE( 429)		{
HXLINE( 429)			_shader->use();
HXDLIN( 429)			_shader->uniforms->apply();
HXDLIN( 429)			::Luxe_obj::renderer->state->activeTexture((int)33984);
            		}
HXLINE( 430)		if (!(_shader->no_default_uniforms)) {
HXLINE( 430)			{
HXLINE( 430)				 ::snow::api::buffers::ArrayBufferView _value = this->view->proj_arr;
HXDLIN( 430)				{
HXLINE( 430)					 ::phoenix::Uniforms _this = _shader->uniforms;
HXDLIN( 430)					 ::opengl::GLObject program = _shader->program;
HXDLIN( 430)					int _id;
HXDLIN( 430)					if (hx::IsNull( program )) {
HXLINE( 430)						_id = (int)0;
            					}
            					else {
HXLINE( 430)						_id = program->id;
            					}
HXDLIN( 430)					 ::opengl::GLObject this1 =  ::opengl::GLObject_obj::__alloc( HX_CTX ,glGetUniformLocation(_id,HX_("projectionMatrix",30,88,bb,d0)));
HXDLIN( 430)					 ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array _matrix4 = ( ( ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array)(::haxe::IMap_obj::get(_this->matrix4arrs,HX_("projectionMatrix",30,88,bb,d0))) );
HXDLIN( 430)					if (hx::IsNotNull( _matrix4 )) {
HXLINE( 430)						_matrix4->value = _value;
            					}
            					else {
HXLINE( 430)						_matrix4 =  ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array_obj::__alloc( HX_CTX ,HX_("projectionMatrix",30,88,bb,d0),_value,this1);
HXDLIN( 430)						::haxe::IMap_obj::set(_this->matrix4arrs,HX_("projectionMatrix",30,88,bb,d0),_matrix4);
            					}
HXDLIN( 430)					_this->dirty_matrix4arrs->push(_matrix4);
            				}
            			}
HXDLIN( 430)			{
HXLINE( 430)				 ::snow::api::buffers::ArrayBufferView _value1 = this->view->view_inverse_arr;
HXDLIN( 430)				{
HXLINE( 430)					 ::phoenix::Uniforms _this1 = _shader->uniforms;
HXDLIN( 430)					 ::opengl::GLObject program1 = _shader->program;
HXDLIN( 430)					int _id1;
HXDLIN( 430)					if (hx::IsNull( program1 )) {
HXLINE( 430)						_id1 = (int)0;
            					}
            					else {
HXLINE( 430)						_id1 = program1->id;
            					}
HXDLIN( 430)					 ::opengl::GLObject this2 =  ::opengl::GLObject_obj::__alloc( HX_CTX ,glGetUniformLocation(_id1,HX_("modelViewMatrix",8f,eb,9c,59)));
HXDLIN( 430)					 ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array _matrix41 = ( ( ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array)(::haxe::IMap_obj::get(_this1->matrix4arrs,HX_("modelViewMatrix",8f,eb,9c,59))) );
HXDLIN( 430)					if (hx::IsNotNull( _matrix41 )) {
HXLINE( 430)						_matrix41->value = _value1;
            					}
            					else {
HXLINE( 430)						_matrix41 =  ::phoenix::_Shader::Uniform_snow_api_buffers_Float32Array_obj::__alloc( HX_CTX ,HX_("modelViewMatrix",8f,eb,9c,59),_value1,this2);
HXDLIN( 430)						::haxe::IMap_obj::set(_this1->matrix4arrs,HX_("modelViewMatrix",8f,eb,9c,59),_matrix41);
            					}
HXDLIN( 430)					_this1->dirty_matrix4arrs->push(_matrix41);
            				}
            			}
            		}
HXLINE( 431)		_geom->uniforms->apply();
HXLINE( 433)		int _length = _geom->vertices->length;
HXLINE( 434)		int _length4 = (_length * (int)4);
HXLINE( 435)		bool _updated = _geom->update_buffers();
HXLINE( 437)		if (_updated) {
HXLINE( 438)			{
HXLINE( 438)				{
HXLINE( 438)					 ::opengl::GLObject buffer = _geom->vb_pos;
HXDLIN( 438)					int _hx_tmp;
HXDLIN( 438)					if (hx::IsNull( buffer )) {
HXLINE( 438)						_hx_tmp = (int)0;
            					}
            					else {
HXLINE( 438)						_hx_tmp = buffer->id;
            					}
HXDLIN( 438)					glBindBuffer((int)34962,_hx_tmp);
            				}
HXDLIN( 438)				glVertexAttribPointer((int)0, (int)4, (int)5126, false, (int)0, (void *)(intptr_t)(int)0);
            			}
HXDLIN( 438)			{
HXLINE( 438)				 ::snow::api::buffers::ArrayBufferView data = _geom->buffer_pos;
HXDLIN( 438)				int usage = _geom->buffer_type;
HXDLIN( 438)				glBufferData((int)34962, data->byteLength, (GLvoid*)(&data->buffer[0] + data->byteOffset), usage);
            			}
HXDLIN( 438)			{
HXLINE( 438)				{
HXLINE( 438)					 ::opengl::GLObject buffer1 = _geom->vb_tcoords;
HXDLIN( 438)					int _hx_tmp1;
HXDLIN( 438)					if (hx::IsNull( buffer1 )) {
HXLINE( 438)						_hx_tmp1 = (int)0;
            					}
            					else {
HXLINE( 438)						_hx_tmp1 = buffer1->id;
            					}
HXDLIN( 438)					glBindBuffer((int)34962,_hx_tmp1);
            				}
HXDLIN( 438)				glVertexAttribPointer((int)1, (int)4, (int)5126, false, (int)0, (void *)(intptr_t)(int)0);
            			}
HXDLIN( 438)			{
HXLINE( 438)				 ::snow::api::buffers::ArrayBufferView data1 = _geom->buffer_tcoords;
HXDLIN( 438)				int usage1 = _geom->buffer_type;
HXDLIN( 438)				glBufferData((int)34962, data1->byteLength, (GLvoid*)(&data1->buffer[0] + data1->byteOffset), usage1);
            			}
HXDLIN( 438)			{
HXLINE( 438)				{
HXLINE( 438)					 ::opengl::GLObject buffer2 = _geom->vb_colors;
HXDLIN( 438)					int _hx_tmp2;
HXDLIN( 438)					if (hx::IsNull( buffer2 )) {
HXLINE( 438)						_hx_tmp2 = (int)0;
            					}
            					else {
HXLINE( 438)						_hx_tmp2 = buffer2->id;
            					}
HXDLIN( 438)					glBindBuffer((int)34962,_hx_tmp2);
            				}
HXDLIN( 438)				glVertexAttribPointer((int)2, (int)4, (int)5126, false, (int)0, (void *)(intptr_t)(int)0);
            			}
HXDLIN( 438)			{
HXLINE( 438)				 ::snow::api::buffers::ArrayBufferView data2 = _geom->buffer_colors;
HXDLIN( 438)				int usage2 = _geom->buffer_type;
HXDLIN( 438)				glBufferData((int)34962, data2->byteLength, (GLvoid*)(&data2->buffer[0] + data2->byteOffset), usage2);
            			}
            		}
            		else {
HXLINE( 440)			{
HXLINE( 440)				{
HXLINE( 440)					 ::opengl::GLObject buffer3 = _geom->vb_pos;
HXDLIN( 440)					int _hx_tmp3;
HXDLIN( 440)					if (hx::IsNull( buffer3 )) {
HXLINE( 440)						_hx_tmp3 = (int)0;
            					}
            					else {
HXLINE( 440)						_hx_tmp3 = buffer3->id;
            					}
HXDLIN( 440)					glBindBuffer((int)34962,_hx_tmp3);
            				}
HXDLIN( 440)				glVertexAttribPointer((int)0, (int)4, (int)5126, false, (int)0, (void *)(intptr_t)(int)0);
            			}
HXDLIN( 440)			{
HXLINE( 440)				{
HXLINE( 440)					 ::opengl::GLObject buffer4 = _geom->vb_tcoords;
HXDLIN( 440)					int _hx_tmp4;
HXDLIN( 440)					if (hx::IsNull( buffer4 )) {
HXLINE( 440)						_hx_tmp4 = (int)0;
            					}
            					else {
HXLINE( 440)						_hx_tmp4 = buffer4->id;
            					}
HXDLIN( 440)					glBindBuffer((int)34962,_hx_tmp4);
            				}
HXDLIN( 440)				glVertexAttribPointer((int)1, (int)4, (int)5126, false, (int)0, (void *)(intptr_t)(int)0);
            			}
HXDLIN( 440)			{
HXLINE( 440)				{
HXLINE( 440)					 ::opengl::GLObject buffer5 = _geom->vb_colors;
HXDLIN( 440)					int _hx_tmp5;
HXDLIN( 440)					if (hx::IsNull( buffer5 )) {
HXLINE( 440)						_hx_tmp5 = (int)0;
            					}
            					else {
HXLINE( 440)						_hx_tmp5 = buffer5->id;
            					}
HXDLIN( 440)					glBindBuffer((int)34962,_hx_tmp5);
            				}
HXDLIN( 440)				glVertexAttribPointer((int)2, (int)4, (int)5126, false, (int)0, (void *)(intptr_t)(int)0);
            			}
            		}
HXLINE( 443)		{
HXLINE( 443)			int mode = _geom->state->primitive_type;
HXDLIN( 443)			glDrawArrays(mode,(int)0,::Std_obj::_hx_int(((Float)_geom->buffer_pos->length / (Float)(int)4)));
            		}
HXLINE( 445)		 ::phoenix::RendererStats _stats = this->renderer->stats;
HXLINE( 446)		_stats->geometry_count++;
HXLINE( 447)		_stats->visible_count++;
HXLINE( 448)		_stats->draw_calls++;
HXLINE( 449)		 ::phoenix::RendererStats _stats1 = _stats;
HXDLIN( 449)		_stats1->vert_count = (_stats1->vert_count + _length);
            	}


HX_DEFINE_DYNAMIC_FUNC2(Batcher_obj,submit_geometry,(void))

void Batcher_obj::submit_buffers(int type, ::snow::api::buffers::ArrayBufferView _pos, ::snow::api::buffers::ArrayBufferView _tcoords, ::snow::api::buffers::ArrayBufferView _colors, ::snow::api::buffers::ArrayBufferView _normals){
            	HX_GC_STACKFRAME(&_hx_pos_8831ea6108d72700_455_submit_buffers)
HXLINE( 457)		int _id = linc::opengl::webgl::createBuffer();
HXDLIN( 457)		 ::opengl::GLObject this1 =  ::opengl::GLObject_obj::__alloc( HX_CTX ,_id);
HXDLIN( 457)		 ::opengl::GLObject pb = this1;
HXLINE( 458)		int _id1 = linc::opengl::webgl::createBuffer();
HXDLIN( 458)		 ::opengl::GLObject this2 =  ::opengl::GLObject_obj::__alloc( HX_CTX ,_id1);
HXDLIN( 458)		 ::opengl::GLObject cb = this2;
HXLINE( 459)		int _id2 = linc::opengl::webgl::createBuffer();
HXDLIN( 459)		 ::opengl::GLObject this3 =  ::opengl::GLObject_obj::__alloc( HX_CTX ,_id2);
HXDLIN( 459)		 ::opengl::GLObject tb = this3;
HXLINE( 464)		int _hx_tmp;
HXDLIN( 464)		if (hx::IsNull( pb )) {
HXLINE( 464)			_hx_tmp = (int)0;
            		}
            		else {
HXLINE( 464)			_hx_tmp = pb->id;
            		}
HXDLIN( 464)		glBindBuffer((int)34962,_hx_tmp);
HXLINE( 465)		glVertexAttribPointer((int)0, (int)4, (int)5126, false, (int)0, (void *)(intptr_t)(int)0);
HXLINE( 466)		glBufferData((int)34962, _pos->byteLength, (GLvoid*)(&_pos->buffer[0] + _pos->byteOffset), (int)35040);
HXLINE( 468)		int _hx_tmp1;
HXDLIN( 468)		if (hx::IsNull( tb )) {
HXLINE( 468)			_hx_tmp1 = (int)0;
            		}
            		else {
HXLINE( 468)			_hx_tmp1 = tb->id;
            		}
HXDLIN( 468)		glBindBuffer((int)34962,_hx_tmp1);
HXLINE( 469)		glVertexAttribPointer((int)1, (int)4, (int)5126, false, (int)0, (void *)(intptr_t)(int)0);
HXLINE( 470)		glBufferData((int)34962, _tcoords->byteLength, (GLvoid*)(&_tcoords->buffer[0] + _tcoords->byteOffset), (int)35040);
HXLINE( 472)		int _hx_tmp2;
HXDLIN( 472)		if (hx::IsNull( cb )) {
HXLINE( 472)			_hx_tmp2 = (int)0;
            		}
            		else {
HXLINE( 472)			_hx_tmp2 = cb->id;
            		}
HXDLIN( 472)		glBindBuffer((int)34962,_hx_tmp2);
HXLINE( 473)		glVertexAttribPointer((int)2, (int)4, (int)5126, false, (int)0, (void *)(intptr_t)(int)0);
HXLINE( 474)		glBufferData((int)34962, _colors->byteLength, (GLvoid*)(&_colors->buffer[0] + _colors->byteOffset), (int)35040);
HXLINE( 483)		glDrawArrays(type,(int)0,::Std_obj::_hx_int(((Float)_pos->length / (Float)(int)4)));
HXLINE( 485)		int _hx_tmp3;
HXDLIN( 485)		if (hx::IsNull( pb )) {
HXLINE( 485)			_hx_tmp3 = (int)0;
            		}
            		else {
HXLINE( 485)			_hx_tmp3 = pb->id;
            		}
HXDLIN( 485)		linc::opengl::webgl::deleteBuffer(_hx_tmp3);
HXLINE( 486)		int _hx_tmp4;
HXDLIN( 486)		if (hx::IsNull( cb )) {
HXLINE( 486)			_hx_tmp4 = (int)0;
            		}
            		else {
HXLINE( 486)			_hx_tmp4 = cb->id;
            		}
HXDLIN( 486)		linc::opengl::webgl::deleteBuffer(_hx_tmp4);
HXLINE( 487)		int _hx_tmp5;
HXDLIN( 487)		if (hx::IsNull( tb )) {
HXLINE( 487)			_hx_tmp5 = (int)0;
            		}
            		else {
HXLINE( 487)			_hx_tmp5 = tb->id;
            		}
HXDLIN( 487)		linc::opengl::webgl::deleteBuffer(_hx_tmp5);
HXLINE( 492)		this->draw_calls++;
            	}


HX_DEFINE_DYNAMIC_FUNC5(Batcher_obj,submit_buffers,(void))

bool Batcher_obj::submit_static_geometry( ::phoenix::geometry::Geometry geom){
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_498_submit_static_geometry)
HXLINE( 500)		int _length = geom->vertices->length;
HXLINE( 502)		if ((_length == (int)0)) {
HXLINE( 503)			return false;
            		}
HXLINE( 506)		bool _updated = geom->update_buffers();
HXLINE( 508)		if (_updated) {
HXLINE( 509)			{
HXLINE( 509)				{
HXLINE( 509)					 ::opengl::GLObject buffer = geom->vb_pos;
HXDLIN( 509)					int _hx_tmp;
HXDLIN( 509)					if (hx::IsNull( buffer )) {
HXLINE( 509)						_hx_tmp = (int)0;
            					}
            					else {
HXLINE( 509)						_hx_tmp = buffer->id;
            					}
HXDLIN( 509)					glBindBuffer((int)34962,_hx_tmp);
            				}
HXDLIN( 509)				glVertexAttribPointer((int)0, (int)4, (int)5126, false, (int)0, (void *)(intptr_t)(int)0);
            			}
HXDLIN( 509)			{
HXLINE( 509)				 ::snow::api::buffers::ArrayBufferView data = geom->buffer_pos;
HXDLIN( 509)				int usage = geom->buffer_type;
HXDLIN( 509)				glBufferData((int)34962, data->byteLength, (GLvoid*)(&data->buffer[0] + data->byteOffset), usage);
            			}
HXDLIN( 509)			{
HXLINE( 509)				{
HXLINE( 509)					 ::opengl::GLObject buffer1 = geom->vb_tcoords;
HXDLIN( 509)					int _hx_tmp1;
HXDLIN( 509)					if (hx::IsNull( buffer1 )) {
HXLINE( 509)						_hx_tmp1 = (int)0;
            					}
            					else {
HXLINE( 509)						_hx_tmp1 = buffer1->id;
            					}
HXDLIN( 509)					glBindBuffer((int)34962,_hx_tmp1);
            				}
HXDLIN( 509)				glVertexAttribPointer((int)1, (int)4, (int)5126, false, (int)0, (void *)(intptr_t)(int)0);
            			}
HXDLIN( 509)			{
HXLINE( 509)				 ::snow::api::buffers::ArrayBufferView data1 = geom->buffer_tcoords;
HXDLIN( 509)				int usage1 = geom->buffer_type;
HXDLIN( 509)				glBufferData((int)34962, data1->byteLength, (GLvoid*)(&data1->buffer[0] + data1->byteOffset), usage1);
            			}
HXDLIN( 509)			{
HXLINE( 509)				{
HXLINE( 509)					 ::opengl::GLObject buffer2 = geom->vb_colors;
HXDLIN( 509)					int _hx_tmp2;
HXDLIN( 509)					if (hx::IsNull( buffer2 )) {
HXLINE( 509)						_hx_tmp2 = (int)0;
            					}
            					else {
HXLINE( 509)						_hx_tmp2 = buffer2->id;
            					}
HXDLIN( 509)					glBindBuffer((int)34962,_hx_tmp2);
            				}
HXDLIN( 509)				glVertexAttribPointer((int)2, (int)4, (int)5126, false, (int)0, (void *)(intptr_t)(int)0);
            			}
HXDLIN( 509)			{
HXLINE( 509)				 ::snow::api::buffers::ArrayBufferView data2 = geom->buffer_colors;
HXDLIN( 509)				int usage2 = geom->buffer_type;
HXDLIN( 509)				glBufferData((int)34962, data2->byteLength, (GLvoid*)(&data2->buffer[0] + data2->byteOffset), usage2);
            			}
            		}
            		else {
HXLINE( 511)			{
HXLINE( 511)				{
HXLINE( 511)					 ::opengl::GLObject buffer3 = geom->vb_pos;
HXDLIN( 511)					int _hx_tmp3;
HXDLIN( 511)					if (hx::IsNull( buffer3 )) {
HXLINE( 511)						_hx_tmp3 = (int)0;
            					}
            					else {
HXLINE( 511)						_hx_tmp3 = buffer3->id;
            					}
HXDLIN( 511)					glBindBuffer((int)34962,_hx_tmp3);
            				}
HXDLIN( 511)				glVertexAttribPointer((int)0, (int)4, (int)5126, false, (int)0, (void *)(intptr_t)(int)0);
            			}
HXDLIN( 511)			{
HXLINE( 511)				{
HXLINE( 511)					 ::opengl::GLObject buffer4 = geom->vb_tcoords;
HXDLIN( 511)					int _hx_tmp4;
HXDLIN( 511)					if (hx::IsNull( buffer4 )) {
HXLINE( 511)						_hx_tmp4 = (int)0;
            					}
            					else {
HXLINE( 511)						_hx_tmp4 = buffer4->id;
            					}
HXDLIN( 511)					glBindBuffer((int)34962,_hx_tmp4);
            				}
HXDLIN( 511)				glVertexAttribPointer((int)1, (int)4, (int)5126, false, (int)0, (void *)(intptr_t)(int)0);
            			}
HXDLIN( 511)			{
HXLINE( 511)				{
HXLINE( 511)					 ::opengl::GLObject buffer5 = geom->vb_colors;
HXDLIN( 511)					int _hx_tmp5;
HXDLIN( 511)					if (hx::IsNull( buffer5 )) {
HXLINE( 511)						_hx_tmp5 = (int)0;
            					}
            					else {
HXLINE( 511)						_hx_tmp5 = buffer5->id;
            					}
HXDLIN( 511)					glBindBuffer((int)34962,_hx_tmp5);
            				}
HXDLIN( 511)				glVertexAttribPointer((int)2, (int)4, (int)5126, false, (int)0, (void *)(intptr_t)(int)0);
            			}
            		}
HXLINE( 514)		{
HXLINE( 514)			int mode = geom->state->primitive_type;
HXDLIN( 514)			glDrawArrays(mode,(int)0,::Std_obj::_hx_int(((Float)geom->buffer_pos->length / (Float)(int)4)));
            		}
HXLINE( 517)		this->static_batched_count++;
HXLINE( 518)		this->draw_calls++;
HXLINE( 521)		geom->set_dirty(false);
HXLINE( 523)		return true;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Batcher_obj,submit_static_geometry,return )

bool Batcher_obj::submit_current_vertex_list(int type){
            	HX_GC_STACKFRAME(&_hx_pos_8831ea6108d72700_529_submit_current_vertex_list)
HXLINE( 531)		if ((this->pos_floats == (int)0)) {
HXLINE( 532)			return false;
            		}
HXLINE( 535)		if ((this->pos_floats > this->max_floats)) {
HXLINE( 536)			HX_STACK_DO_THROW(HX_("uh oh, somehow too many floats are being submitted (max:$max_floats, attempt:$pos_floats).",4e,e8,8c,4a));
            		}
HXLINE( 540)		::Array< unsigned char > _buffer = this->pos_list->buffer;
HXDLIN( 540)		int _byteLength = (this->pos_floats * (int)4);
HXDLIN( 540)		 ::snow::api::buffers::ArrayBufferView _view =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 540)		int _bytes_per_elem = _view->bytesPerElement;
HXDLIN( 540)		if ((hx::Mod((int)0,_bytes_per_elem) != (int)0)) {
HXLINE( 540)			HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            		}
HXDLIN( 540)		int _src_bytelen = _buffer->length;
HXDLIN( 540)		int _new_range = _byteLength;
HXDLIN( 540)		if ((_new_range > _src_bytelen)) {
HXLINE( 540)			HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            		}
HXDLIN( 540)		_view->buffer = _buffer;
HXDLIN( 540)		_view->byteOffset = (int)0;
HXDLIN( 540)		_view->byteLength = _byteLength;
HXDLIN( 540)		_view->length = ::Std_obj::_hx_int(((Float)_byteLength / (Float)_bytes_per_elem));
HXDLIN( 540)		 ::snow::api::buffers::ArrayBufferView _pos = _view;
HXLINE( 541)		::Array< unsigned char > _buffer1 = this->tcoord_list->buffer;
HXDLIN( 541)		int _byteLength1 = (this->tcoord_floats * (int)4);
HXDLIN( 541)		 ::snow::api::buffers::ArrayBufferView _view1 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 541)		int _bytes_per_elem1 = _view1->bytesPerElement;
HXDLIN( 541)		if ((hx::Mod((int)0,_bytes_per_elem1) != (int)0)) {
HXLINE( 541)			HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            		}
HXDLIN( 541)		int _src_bytelen1 = _buffer1->length;
HXDLIN( 541)		int _new_range1 = _byteLength1;
HXDLIN( 541)		if ((_new_range1 > _src_bytelen1)) {
HXLINE( 541)			HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            		}
HXDLIN( 541)		_view1->buffer = _buffer1;
HXDLIN( 541)		_view1->byteOffset = (int)0;
HXDLIN( 541)		_view1->byteLength = _byteLength1;
HXDLIN( 541)		_view1->length = ::Std_obj::_hx_int(((Float)_byteLength1 / (Float)_bytes_per_elem1));
HXDLIN( 541)		 ::snow::api::buffers::ArrayBufferView _tcoords = _view1;
HXLINE( 542)		::Array< unsigned char > _buffer2 = this->color_list->buffer;
HXDLIN( 542)		int _byteLength2 = (this->color_floats * (int)4);
HXDLIN( 542)		 ::snow::api::buffers::ArrayBufferView _view2 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 542)		int _bytes_per_elem2 = _view2->bytesPerElement;
HXDLIN( 542)		if ((hx::Mod((int)0,_bytes_per_elem2) != (int)0)) {
HXLINE( 542)			HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            		}
HXDLIN( 542)		int _src_bytelen2 = _buffer2->length;
HXDLIN( 542)		int _new_range2 = _byteLength2;
HXDLIN( 542)		if ((_new_range2 > _src_bytelen2)) {
HXLINE( 542)			HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            		}
HXDLIN( 542)		_view2->buffer = _buffer2;
HXDLIN( 542)		_view2->byteOffset = (int)0;
HXDLIN( 542)		_view2->byteLength = _byteLength2;
HXDLIN( 542)		_view2->length = ::Std_obj::_hx_int(((Float)_byteLength2 / (Float)_bytes_per_elem2));
HXDLIN( 542)		 ::snow::api::buffers::ArrayBufferView _colors = _view2;
HXLINE( 543)		 ::snow::api::buffers::ArrayBufferView _normals = null();
HXLINE( 549)		this->submit_buffers(type,_pos,_tcoords,_colors,_normals);
HXLINE( 551)		_pos = null();
HXLINE( 552)		_tcoords = null();
HXLINE( 553)		_colors = null();
HXLINE( 554)		_normals = null();
HXLINE( 556)		this->pos_floats = (int)0;
HXLINE( 557)		this->tcoord_floats = (int)0;
HXLINE( 558)		this->color_floats = (int)0;
HXLINE( 559)		this->normal_floats = (int)0;
HXLINE( 561)		return true;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Batcher_obj,submit_current_vertex_list,return )

void Batcher_obj::geometry_batch( ::phoenix::geometry::Geometry geom){
            	HX_GC_STACKFRAME(&_hx_pos_8831ea6108d72700_568_geometry_batch)
HXLINE( 570)		if ((geom->vertices->length > this->max_verts)) {
HXLINE( 571)			geom->set_locked(true);
HXLINE( 572)			geom->dirty_based = false;
HXLINE( 573)			 ::Dynamic _hx_tmp = ::haxe::Log_obj::trace;
HXDLIN( 573)			_hx_tmp((HX_("  i / batcher / ",52,b7,3e,d6) + ((((((((HX_("WARNING batcher `",c3,c3,10,cf) + this->name) + HX_("` trying to batch a geometry `",e3,ef,1f,81)) + geom->id) + HX_("` that has more verts than the batcher has preallocated, (",2d,aa,5e,9c)) + geom->vertices->length) + HX_(" vs max of ",ea,ab,b3,51)) + this->max_verts) + HX_(")",29,00,00,00))),hx::SourceInfo(HX_("Batcher.hx",97,06,68,88),573,HX_("phoenix.Batcher",a8,b2,34,67),HX_("geometry_batch",2d,43,e5,75)));
HXLINE( 574)			 ::Dynamic _hx_tmp1 = ::haxe::Log_obj::trace;
HXDLIN( 574)			_hx_tmp1((HX_("  i / batcher / ",52,b7,3e,d6) + HX_("WARNING geometry has been marked as direct submit, and will be submitted independently!",1c,f5,10,a5)),hx::SourceInfo(HX_("Batcher.hx",97,06,68,88),574,HX_("phoenix.Batcher",a8,b2,34,67),HX_("geometry_batch",2d,43,e5,75)));
HXLINE( 575)			return;
            		}
HXLINE( 579)		int geom1 = geom->vertices->length;
HXDLIN( 579)		Float _count_after = (geom1 + ((Float)this->pos_floats / (Float)(int)4));
HXLINE( 582)		if ((_count_after > this->max_verts)) {
HXLINE( 583)			int type = geom->state->primitive_type;
HXDLIN( 583)			if ((this->pos_floats != (int)0)) {
HXLINE( 583)				if ((this->pos_floats > this->max_floats)) {
HXLINE( 583)					HX_STACK_DO_THROW(HX_("uh oh, somehow too many floats are being submitted (max:$max_floats, attempt:$pos_floats).",4e,e8,8c,4a));
            				}
HXDLIN( 583)				::Array< unsigned char > _buffer = this->pos_list->buffer;
HXDLIN( 583)				int _byteLength = (this->pos_floats * (int)4);
HXDLIN( 583)				 ::snow::api::buffers::ArrayBufferView _view =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 583)				int _bytes_per_elem = _view->bytesPerElement;
HXDLIN( 583)				if ((hx::Mod((int)0,_bytes_per_elem) != (int)0)) {
HXLINE( 583)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 583)				int _src_bytelen = _buffer->length;
HXDLIN( 583)				int _new_range = _byteLength;
HXDLIN( 583)				if ((_new_range > _src_bytelen)) {
HXLINE( 583)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 583)				_view->buffer = _buffer;
HXDLIN( 583)				_view->byteOffset = (int)0;
HXDLIN( 583)				_view->byteLength = _byteLength;
HXDLIN( 583)				_view->length = ::Std_obj::_hx_int(((Float)_byteLength / (Float)_bytes_per_elem));
HXDLIN( 583)				 ::snow::api::buffers::ArrayBufferView _pos = _view;
HXDLIN( 583)				::Array< unsigned char > _buffer1 = this->tcoord_list->buffer;
HXDLIN( 583)				int _byteLength1 = (this->tcoord_floats * (int)4);
HXDLIN( 583)				 ::snow::api::buffers::ArrayBufferView _view1 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 583)				int _bytes_per_elem1 = _view1->bytesPerElement;
HXDLIN( 583)				if ((hx::Mod((int)0,_bytes_per_elem1) != (int)0)) {
HXLINE( 583)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 583)				int _src_bytelen1 = _buffer1->length;
HXDLIN( 583)				int _new_range1 = _byteLength1;
HXDLIN( 583)				if ((_new_range1 > _src_bytelen1)) {
HXLINE( 583)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 583)				_view1->buffer = _buffer1;
HXDLIN( 583)				_view1->byteOffset = (int)0;
HXDLIN( 583)				_view1->byteLength = _byteLength1;
HXDLIN( 583)				_view1->length = ::Std_obj::_hx_int(((Float)_byteLength1 / (Float)_bytes_per_elem1));
HXDLIN( 583)				 ::snow::api::buffers::ArrayBufferView _tcoords = _view1;
HXDLIN( 583)				::Array< unsigned char > _buffer2 = this->color_list->buffer;
HXDLIN( 583)				int _byteLength2 = (this->color_floats * (int)4);
HXDLIN( 583)				 ::snow::api::buffers::ArrayBufferView _view2 =  ::snow::api::buffers::ArrayBufferView_obj::__alloc( HX_CTX ,(int)8);
HXDLIN( 583)				int _bytes_per_elem2 = _view2->bytesPerElement;
HXDLIN( 583)				if ((hx::Mod((int)0,_bytes_per_elem2) != (int)0)) {
HXLINE( 583)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: byte offset must be aligned with the bytes per element",e2,98,67,08)));
            				}
HXDLIN( 583)				int _src_bytelen2 = _buffer2->length;
HXDLIN( 583)				int _new_range2 = _byteLength2;
HXDLIN( 583)				if ((_new_range2 > _src_bytelen2)) {
HXLINE( 583)					HX_STACK_DO_THROW(::snow::api::buffers::TAError_obj::RangeError(HX_("fromBuffer: specified range would exceed the source buffer",98,6f,a0,be)));
            				}
HXDLIN( 583)				_view2->buffer = _buffer2;
HXDLIN( 583)				_view2->byteOffset = (int)0;
HXDLIN( 583)				_view2->byteLength = _byteLength2;
HXDLIN( 583)				_view2->length = ::Std_obj::_hx_int(((Float)_byteLength2 / (Float)_bytes_per_elem2));
HXDLIN( 583)				 ::snow::api::buffers::ArrayBufferView _colors = _view2;
HXDLIN( 583)				 ::snow::api::buffers::ArrayBufferView _normals = null();
HXDLIN( 583)				this->submit_buffers(type,_pos,_tcoords,_colors,_normals);
HXDLIN( 583)				_pos = null();
HXDLIN( 583)				_tcoords = null();
HXDLIN( 583)				_colors = null();
HXDLIN( 583)				_normals = null();
HXDLIN( 583)				this->pos_floats = (int)0;
HXDLIN( 583)				this->tcoord_floats = (int)0;
HXDLIN( 583)				this->color_floats = (int)0;
HXDLIN( 583)				this->normal_floats = (int)0;
            			}
            		}
HXLINE( 586)		{
HXLINE( 586)			int vert_index = this->pos_floats;
HXDLIN( 586)			int tcoord_index = this->tcoord_floats;
HXDLIN( 586)			int color_index = this->color_floats;
HXDLIN( 586)			int normal_index = this->normal_floats;
HXDLIN( 586)			 ::snow::api::buffers::ArrayBufferView vertlist = this->pos_list;
HXDLIN( 586)			 ::snow::api::buffers::ArrayBufferView tcoordlist = this->tcoord_list;
HXDLIN( 586)			 ::snow::api::buffers::ArrayBufferView colorlist = this->color_list;
HXDLIN( 586)			 ::snow::api::buffers::ArrayBufferView normallist = this->normal_list;
HXDLIN( 586)			 ::phoenix::Transform _this = geom->transform;
HXDLIN( 586)			if (!(_this->_destroying)) {
HXLINE( 586)				bool _hx_tmp2;
HXDLIN( 586)				if (hx::IsNotNull( _this->parent )) {
HXLINE( 586)					_hx_tmp2 = _this->parent->dirty;
            				}
            				else {
HXLINE( 586)					_hx_tmp2 = false;
            				}
HXDLIN( 586)				if (_hx_tmp2) {
HXLINE( 586)					_this->parent->clean_check();
            				}
HXDLIN( 586)				bool _hx_tmp3;
HXDLIN( 586)				bool _hx_tmp4;
HXDLIN( 586)				if (_this->dirty) {
HXLINE( 586)					_hx_tmp4 = !(_this->_cleaning);
            				}
            				else {
HXLINE( 586)					_hx_tmp4 = false;
            				}
HXDLIN( 586)				if (_hx_tmp4) {
HXLINE( 586)					_hx_tmp3 = !(_this->manual_update);
            				}
            				else {
HXLINE( 586)					_hx_tmp3 = false;
            				}
HXDLIN( 586)				if (_hx_tmp3) {
HXLINE( 586)					_this->clean();
            				}
            			}
HXDLIN( 586)			 ::phoenix::Matrix _mat = _this->world->matrix;
HXDLIN( 586)			::Array< Float > _el = _mat->elements;
HXDLIN( 586)			int _count = geom->vertices->length;
HXDLIN( 586)			int _idx = (int)0;
HXDLIN( 586)			while((_idx < _count)){
HXLINE( 586)				 ::phoenix::geometry::Vertex v = geom->vertices->__get(_idx).StaticCast<  ::phoenix::geometry::Vertex >();
HXDLIN( 586)				Float _vx = v->pos->x;
HXDLIN( 586)				Float _vy = v->pos->y;
HXDLIN( 586)				Float _vz = v->pos->z;
HXDLIN( 586)				Float _tvx = (( (Float)(_hx_array_unsafe_get(_el,(int)0)) ) * _vx);
HXDLIN( 586)				Float _tvx1 = (_tvx + (( (Float)(_hx_array_unsafe_get(_el,(int)4)) ) * _vy));
HXDLIN( 586)				Float _tvx2 = (_tvx1 + (( (Float)(_hx_array_unsafe_get(_el,(int)8)) ) * _vz));
HXDLIN( 586)				Float _tvx3 = (_tvx2 + ( (Float)(_hx_array_unsafe_get(_el,(int)12)) ));
HXDLIN( 586)				Float _tvy = (( (Float)(_hx_array_unsafe_get(_el,(int)1)) ) * _vx);
HXDLIN( 586)				Float _tvy1 = (_tvy + (( (Float)(_hx_array_unsafe_get(_el,(int)5)) ) * _vy));
HXDLIN( 586)				Float _tvy2 = (_tvy1 + (( (Float)(_hx_array_unsafe_get(_el,(int)9)) ) * _vz));
HXDLIN( 586)				Float _tvy3 = (_tvy2 + ( (Float)(_hx_array_unsafe_get(_el,(int)13)) ));
HXDLIN( 586)				Float _tvz = (( (Float)(_hx_array_unsafe_get(_el,(int)2)) ) * _vx);
HXDLIN( 586)				Float _tvz1 = (_tvz + (( (Float)(_hx_array_unsafe_get(_el,(int)6)) ) * _vy));
HXDLIN( 586)				Float _tvz2 = (_tvz1 + (( (Float)(_hx_array_unsafe_get(_el,(int)10)) ) * _vz));
HXDLIN( 586)				Float _tvz3 = (_tvz2 + ( (Float)(_hx_array_unsafe_get(_el,(int)14)) ));
HXDLIN( 586)				{
HXLINE( 586)					int vertlist1 = vertlist->byteOffset;
HXDLIN( 586)					::__hxcpp_memory_set_float(vertlist->buffer,(vertlist1 + (vert_index * (int)4)),_tvx3);
            				}
HXDLIN( 586)				{
HXLINE( 586)					int vertlist2 = vertlist->byteOffset;
HXDLIN( 586)					::__hxcpp_memory_set_float(vertlist->buffer,(vertlist2 + ((vert_index + (int)1) * (int)4)),_tvy3);
            				}
HXDLIN( 586)				{
HXLINE( 586)					int vertlist3 = vertlist->byteOffset;
HXDLIN( 586)					::__hxcpp_memory_set_float(vertlist->buffer,(vertlist3 + ((vert_index + (int)2) * (int)4)),_tvz3);
            				}
HXDLIN( 586)				{
HXLINE( 586)					int vertlist4 = vertlist->byteOffset;
HXDLIN( 586)					::__hxcpp_memory_set_float(vertlist->buffer,(vertlist4 + ((vert_index + (int)3) * (int)4)),v->pos->w);
            				}
HXDLIN( 586)				vert_index = (vert_index + (int)4);
HXDLIN( 586)				 ::phoenix::geometry::TextureCoord _vuv = v->uv->uv0;
HXDLIN( 586)				{
HXLINE( 586)					int tcoordlist1 = tcoordlist->byteOffset;
HXDLIN( 586)					::__hxcpp_memory_set_float(tcoordlist->buffer,(tcoordlist1 + (tcoord_index * (int)4)),_vuv->u);
            				}
HXDLIN( 586)				{
HXLINE( 586)					int tcoordlist2 = tcoordlist->byteOffset;
HXDLIN( 586)					::__hxcpp_memory_set_float(tcoordlist->buffer,(tcoordlist2 + ((tcoord_index + (int)1) * (int)4)),_vuv->v);
            				}
HXDLIN( 586)				{
HXLINE( 586)					int tcoordlist3 = tcoordlist->byteOffset;
HXDLIN( 586)					::__hxcpp_memory_set_float(tcoordlist->buffer,(tcoordlist3 + ((tcoord_index + (int)2) * (int)4)),_vuv->w);
            				}
HXDLIN( 586)				{
HXLINE( 586)					int tcoordlist4 = tcoordlist->byteOffset;
HXDLIN( 586)					::__hxcpp_memory_set_float(tcoordlist->buffer,(tcoordlist4 + ((tcoord_index + (int)3) * (int)4)),_vuv->t);
            				}
HXDLIN( 586)				tcoord_index = (tcoord_index + (int)4);
HXDLIN( 586)				{
HXLINE( 586)					int colorlist1 = colorlist->byteOffset;
HXDLIN( 586)					::__hxcpp_memory_set_float(colorlist->buffer,(colorlist1 + (color_index * (int)4)),v->color->r);
            				}
HXDLIN( 586)				{
HXLINE( 586)					int colorlist2 = colorlist->byteOffset;
HXDLIN( 586)					::__hxcpp_memory_set_float(colorlist->buffer,(colorlist2 + ((color_index + (int)1) * (int)4)),v->color->g);
            				}
HXDLIN( 586)				{
HXLINE( 586)					int colorlist3 = colorlist->byteOffset;
HXDLIN( 586)					::__hxcpp_memory_set_float(colorlist->buffer,(colorlist3 + ((color_index + (int)2) * (int)4)),v->color->b);
            				}
HXDLIN( 586)				{
HXLINE( 586)					int colorlist4 = colorlist->byteOffset;
HXDLIN( 586)					::__hxcpp_memory_set_float(colorlist->buffer,(colorlist4 + ((color_index + (int)3) * (int)4)),v->color->a);
            				}
HXDLIN( 586)				color_index = (color_index + (int)4);
HXDLIN( 586)				normal_index = (normal_index + (int)4);
HXDLIN( 586)				_idx = (_idx + (int)1);
            			}
            		}
HXLINE( 591)		int _length = (geom->vertices->length * (int)4);
HXLINE( 593)		 ::phoenix::Batcher _hx_tmp5 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 593)		_hx_tmp5->pos_floats = (_hx_tmp5->pos_floats + _length);
HXLINE( 594)		 ::phoenix::Batcher _hx_tmp6 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 594)		_hx_tmp6->tcoord_floats = (_hx_tmp6->tcoord_floats + _length);
HXLINE( 595)		 ::phoenix::Batcher _hx_tmp7 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 595)		_hx_tmp7->color_floats = (_hx_tmp7->color_floats + _length);
HXLINE( 596)		 ::phoenix::Batcher _hx_tmp8 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 596)		_hx_tmp8->normal_floats = (_hx_tmp8->normal_floats + _length);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Batcher_obj,geometry_batch,(void))

int Batcher_obj::set_layer(int _layer){
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_603_set_layer)
HXLINE( 606)		this->layer = _layer;
HXLINE( 608)		this->renderer->batchers->sort(this->renderer->sort_batchers_dyn());
HXLINE( 611)		return this->layer;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Batcher_obj,set_layer,return )

::String Batcher_obj::toString(){
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_617_toString)
HXDLIN( 617)		return ((HX_("Batcher(",c1,eb,bf,27) + this->name) + HX_(")",29,00,00,00));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Batcher_obj,toString,return )

int Batcher_obj::compare( ::phoenix::Batcher other){
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_622_compare)
HXLINE( 624)		if ((this->layer == other->layer)) {
HXLINE( 624)			return (int)0;
            		}
HXLINE( 625)		if ((this->layer < other->layer)) {
HXLINE( 625)			return (int)-1;
            		}
HXLINE( 627)		return (int)1;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Batcher_obj,compare,return )

::String Batcher_obj::compare_rule_to_string(int r){
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_632_compare_rule_to_string)
HXDLIN( 632)		switch((int)(r)){
            			case (int)0: {
HXLINE( 634)				return HX_("same",66,83,4d,4c);
            			}
            			break;
            			case (int)1: {
HXLINE( 635)				return HX_("depth <",df,93,4a,6a);
            			}
            			break;
            			case (int)2: {
HXLINE( 636)				return HX_("depth >",e1,93,4a,6a);
            			}
            			break;
            			case (int)3: {
HXLINE( 638)				return HX_("shader <",81,ae,2a,36);
            			}
            			break;
            			case (int)4: {
HXLINE( 639)				return HX_("shader >",83,ae,2a,36);
            			}
            			break;
            			case (int)5: {
HXLINE( 640)				return HX_("shader s._ >",87,6d,84,5c);
            			}
            			break;
            			case (int)6: {
HXLINE( 641)				return HX_("shader _.s <",85,00,90,d8);
            			}
            			break;
            			case (int)7: {
HXLINE( 643)				return HX_("texture <",b7,11,49,af);
            			}
            			break;
            			case (int)8: {
HXLINE( 644)				return HX_("texture >",b9,11,49,af);
            			}
            			break;
            			case (int)9: {
HXLINE( 645)				return HX_("texture t._ >",3e,38,1a,13);
            			}
            			break;
            			case (int)10: {
HXLINE( 646)				return HX_("texture _.t <",fc,f8,bf,fb);
            			}
            			break;
            			case (int)11: {
HXLINE( 648)				return HX_("primitive <",83,5c,09,15);
            			}
            			break;
            			case (int)12: {
HXLINE( 649)				return HX_("primitive >",85,5c,09,15);
            			}
            			break;
            			case (int)13: {
HXLINE( 650)				return HX_("unclipped",c6,0e,ca,fe);
            			}
            			break;
            			case (int)14: {
HXLINE( 651)				return HX_("clipped",ff,07,c8,02);
            			}
            			break;
            			case (int)15: {
HXLINE( 652)				return HX_("timestamp <",72,52,ce,d6);
            			}
            			break;
            			case (int)16: {
HXLINE( 653)				return HX_("timestamp >",74,52,ce,d6);
            			}
            			break;
            			case (int)17: {
HXLINE( 654)				return HX_("timestamp ==",6a,d2,b9,1d);
            			}
            			break;
            			case (int)18: {
HXLINE( 655)				return HX_("sequence <",9d,0c,22,d5);
            			}
            			break;
            			case (int)19: {
HXLINE( 656)				return HX_("sequence >",9f,0c,22,d5);
            			}
            			break;
            			case (int)20: {
HXLINE( 657)				return HX_("fallback",22,f0,9d,2a);
            			}
            			break;
            			default:{
HXLINE( 658)				return HX_("unknown",8a,23,7b,e1);
            			}
            		}
HXLINE( 632)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Batcher_obj,compare_rule_to_string,return )

int Batcher_obj::compare_rule( ::phoenix::geometry::GeometryKey a, ::phoenix::geometry::GeometryKey b){
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_664_compare_rule)
HXLINE( 666)		if ((a->uuid == b->uuid)) {
HXLINE( 667)			return (int)0;
            		}
HXLINE( 670)		if ((a->depth < b->depth)) {
HXLINE( 671)			return (int)1;
            		}
HXLINE( 672)		if ((a->depth > b->depth)) {
HXLINE( 673)			return (int)2;
            		}
HXLINE( 678)		bool _hx_tmp;
HXDLIN( 678)		if (hx::IsNotNull( a->shader )) {
HXLINE( 678)			_hx_tmp = hx::IsNotNull( b->shader );
            		}
            		else {
HXLINE( 678)			_hx_tmp = false;
            		}
HXDLIN( 678)		if (_hx_tmp) {
HXLINE( 681)			if ((a->shader->id < b->shader->id)) {
HXLINE( 682)				return (int)3;
            			}
HXLINE( 683)			if ((a->shader->id > b->shader->id)) {
HXLINE( 684)				return (int)4;
            			}
            		}
            		else {
HXLINE( 687)			bool _hx_tmp1;
HXDLIN( 687)			if (hx::IsNotNull( a->shader )) {
HXLINE( 687)				_hx_tmp1 = hx::IsNull( b->shader );
            			}
            			else {
HXLINE( 687)				_hx_tmp1 = false;
            			}
HXDLIN( 687)			if (_hx_tmp1) {
HXLINE( 688)				return (int)5;
            			}
            			else {
HXLINE( 690)				bool _hx_tmp2;
HXDLIN( 690)				if (hx::IsNull( a->shader )) {
HXLINE( 690)					_hx_tmp2 = hx::IsNotNull( b->shader );
            				}
            				else {
HXLINE( 690)					_hx_tmp2 = false;
            				}
HXDLIN( 690)				if (_hx_tmp2) {
HXLINE( 691)					return (int)6;
            				}
            			}
            		}
HXLINE( 695)		bool _hx_tmp3;
HXDLIN( 695)		if (hx::IsNotNull( a->texture )) {
HXLINE( 695)			_hx_tmp3 = hx::IsNotNull( b->texture );
            		}
            		else {
HXLINE( 695)			_hx_tmp3 = false;
            		}
HXDLIN( 695)		if (_hx_tmp3) {
HXLINE( 698)			if ((a->texture->id < b->texture->id)) {
HXLINE( 699)				return (int)7;
            			}
HXLINE( 700)			if ((a->texture->id > b->texture->id)) {
HXLINE( 701)				return (int)8;
            			}
            		}
            		else {
HXLINE( 704)			bool _hx_tmp4;
HXDLIN( 704)			if (hx::IsNotNull( a->texture )) {
HXLINE( 704)				_hx_tmp4 = hx::IsNull( b->texture );
            			}
            			else {
HXLINE( 704)				_hx_tmp4 = false;
            			}
HXDLIN( 704)			if (_hx_tmp4) {
HXLINE( 705)				return (int)9;
            			}
            			else {
HXLINE( 707)				bool _hx_tmp5;
HXDLIN( 707)				if (hx::IsNull( a->texture )) {
HXLINE( 707)					_hx_tmp5 = hx::IsNotNull( b->texture );
            				}
            				else {
HXLINE( 707)					_hx_tmp5 = false;
            				}
HXDLIN( 707)				if (_hx_tmp5) {
HXLINE( 708)					return (int)10;
            				}
            			}
            		}
HXLINE( 714)		int a_primitive_index = a->primitive_type;
HXLINE( 715)		int b_primitive_index = b->primitive_type;
HXLINE( 717)		if ((a_primitive_index < b_primitive_index)) {
HXLINE( 718)			return (int)11;
            		}
HXLINE( 719)		if ((a_primitive_index > b_primitive_index)) {
HXLINE( 720)			return (int)12;
            		}
HXLINE( 723)		if ((a->clip != b->clip)) {
HXLINE( 725)			bool _hx_tmp6;
HXDLIN( 725)			if ((a->clip == false)) {
HXLINE( 725)				_hx_tmp6 = (b->clip == true);
            			}
            			else {
HXLINE( 725)				_hx_tmp6 = false;
            			}
HXDLIN( 725)			if (_hx_tmp6) {
HXLINE( 726)				return (int)13;
            			}
            			else {
HXLINE( 729)				bool _hx_tmp7;
HXDLIN( 729)				if ((a->clip == true)) {
HXLINE( 729)					_hx_tmp7 = (b->clip == false);
            				}
            				else {
HXLINE( 729)					_hx_tmp7 = false;
            				}
HXDLIN( 729)				if (_hx_tmp7) {
HXLINE( 730)					return (int)14;
            				}
            			}
            		}
HXLINE( 738)		if ((a->timestamp < b->timestamp)) {
HXLINE( 739)			return (int)15;
            		}
HXLINE( 740)		if ((a->timestamp > b->timestamp)) {
HXLINE( 741)			return (int)16;
            		}
HXLINE( 742)		if ((a->timestamp == b->timestamp)) {
HXLINE( 743)			return (int)17;
            		}
HXLINE( 745)		if ((a->sequence < b->sequence)) {
HXLINE( 746)			return (int)18;
            		}
HXLINE( 747)		if ((a->sequence > b->sequence)) {
HXLINE( 748)			return (int)19;
            		}
HXLINE( 751)		return (int)20;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Batcher_obj,compare_rule,return )

int Batcher_obj::geometry_compare( ::phoenix::geometry::GeometryKey a, ::phoenix::geometry::GeometryKey b){
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_755_geometry_compare)
HXLINE( 767)		if ((a->uuid == b->uuid)) {
HXLINE( 768)			return (int)0;
            		}
HXLINE( 771)		if ((a->depth < b->depth)) {
HXLINE( 772)			return (int)-1;
            		}
HXLINE( 773)		if ((a->depth > b->depth)) {
HXLINE( 774)			return (int)1;
            		}
HXLINE( 778)		bool _hx_tmp;
HXDLIN( 778)		if (hx::IsNotNull( a->shader )) {
HXLINE( 778)			_hx_tmp = hx::IsNotNull( b->shader );
            		}
            		else {
HXLINE( 778)			_hx_tmp = false;
            		}
HXDLIN( 778)		if (_hx_tmp) {
HXLINE( 781)			if ((a->shader->id < b->shader->id)) {
HXLINE( 782)				return (int)-1;
            			}
HXLINE( 783)			if ((a->shader->id > b->shader->id)) {
HXLINE( 784)				return (int)1;
            			}
            		}
            		else {
HXLINE( 787)			bool _hx_tmp1;
HXDLIN( 787)			if (hx::IsNotNull( a->shader )) {
HXLINE( 787)				_hx_tmp1 = hx::IsNull( b->shader );
            			}
            			else {
HXLINE( 787)				_hx_tmp1 = false;
            			}
HXDLIN( 787)			if (_hx_tmp1) {
HXLINE( 788)				return (int)1;
            			}
            			else {
HXLINE( 790)				bool _hx_tmp2;
HXDLIN( 790)				if (hx::IsNull( a->shader )) {
HXLINE( 790)					_hx_tmp2 = hx::IsNotNull( b->shader );
            				}
            				else {
HXLINE( 790)					_hx_tmp2 = false;
            				}
HXDLIN( 790)				if (_hx_tmp2) {
HXLINE( 791)					return (int)-1;
            				}
            			}
            		}
HXLINE( 795)		bool _hx_tmp3;
HXDLIN( 795)		if (hx::IsNotNull( a->texture )) {
HXLINE( 795)			_hx_tmp3 = hx::IsNotNull( b->texture );
            		}
            		else {
HXLINE( 795)			_hx_tmp3 = false;
            		}
HXDLIN( 795)		if (_hx_tmp3) {
HXLINE( 798)			if ((a->texture->id < b->texture->id)) {
HXLINE( 799)				return (int)-1;
            			}
HXLINE( 800)			if ((a->texture->id > b->texture->id)) {
HXLINE( 801)				return (int)1;
            			}
            		}
            		else {
HXLINE( 804)			bool _hx_tmp4;
HXDLIN( 804)			if (hx::IsNotNull( a->texture )) {
HXLINE( 804)				_hx_tmp4 = hx::IsNull( b->texture );
            			}
            			else {
HXLINE( 804)				_hx_tmp4 = false;
            			}
HXDLIN( 804)			if (_hx_tmp4) {
HXLINE( 805)				return (int)1;
            			}
            			else {
HXLINE( 807)				bool _hx_tmp5;
HXDLIN( 807)				if (hx::IsNull( a->texture )) {
HXLINE( 807)					_hx_tmp5 = hx::IsNotNull( b->texture );
            				}
            				else {
HXLINE( 807)					_hx_tmp5 = false;
            				}
HXDLIN( 807)				if (_hx_tmp5) {
HXLINE( 808)					return (int)-1;
            				}
            			}
            		}
HXLINE( 813)		int a_primitive_index = a->primitive_type;
HXLINE( 814)		int b_primitive_index = b->primitive_type;
HXLINE( 816)		if ((a_primitive_index < b_primitive_index)) {
HXLINE( 817)			return (int)-1;
            		}
HXLINE( 818)		if ((a_primitive_index > b_primitive_index)) {
HXLINE( 819)			return (int)1;
            		}
HXLINE( 822)		if ((a->clip != b->clip)) {
HXLINE( 824)			bool _hx_tmp6;
HXDLIN( 824)			if ((a->clip == false)) {
HXLINE( 824)				_hx_tmp6 = (b->clip == true);
            			}
            			else {
HXLINE( 824)				_hx_tmp6 = false;
            			}
HXDLIN( 824)			if (_hx_tmp6) {
HXLINE( 825)				return (int)1;
            			}
            			else {
HXLINE( 828)				bool _hx_tmp7;
HXDLIN( 828)				if ((a->clip == true)) {
HXLINE( 828)					_hx_tmp7 = (b->clip == false);
            				}
            				else {
HXLINE( 828)					_hx_tmp7 = false;
            				}
HXDLIN( 828)				if (_hx_tmp7) {
HXLINE( 829)					return (int)-1;
            				}
            			}
            		}
HXLINE( 837)		if ((a->timestamp < b->timestamp)) {
HXLINE( 838)			return (int)-1;
            		}
HXLINE( 839)		if ((a->timestamp > b->timestamp)) {
HXLINE( 840)			return (int)1;
            		}
HXLINE( 841)		if ((a->sequence < b->sequence)) {
HXLINE( 842)			return (int)-1;
            		}
HXLINE( 843)		if ((a->sequence > b->sequence)) {
HXLINE( 844)			return (int)1;
            		}
HXLINE( 847)		return (int)1;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Batcher_obj,geometry_compare,return )

void Batcher_obj::list_geometry(){
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_852_list_geometry)
HXDLIN( 852)		 ::luxe::structural::BalancedBSTIterator_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _g = this->geometry->iterator();
HXDLIN( 852)		while(true){
HXDLIN( 852)			bool _hx_tmp;
HXDLIN( 852)			bool _hx_tmp1;
HXDLIN( 852)			if (hx::IsNotNull( _g->current )) {
HXDLIN( 852)				_hx_tmp1 = hx::IsNull( _g->rightest );
            			}
            			else {
HXDLIN( 852)				_hx_tmp1 = true;
            			}
HXDLIN( 852)			if (_hx_tmp1) {
HXDLIN( 852)				_hx_tmp = false;
            			}
            			else {
HXDLIN( 852)				_hx_tmp = (( (int)(_g->tree->compare(_g->current->key,_g->rightest->key)) ) <= (int)0);
            			}
HXDLIN( 852)			if (!(_hx_tmp)) {
HXDLIN( 852)				goto _hx_goto_37;
            			}
HXDLIN( 852)			 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _temp = _g->current;
HXDLIN( 852)			 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _hx_tmp2;
HXDLIN( 852)			bool _hx_tmp3;
HXDLIN( 852)			bool _hx_tmp4;
HXDLIN( 852)			if (hx::IsNotNull( _g->current )) {
HXDLIN( 852)				_hx_tmp4 = hx::IsNull( _g->rightest );
            			}
            			else {
HXDLIN( 852)				_hx_tmp4 = true;
            			}
HXDLIN( 852)			if (_hx_tmp4) {
HXDLIN( 852)				_hx_tmp3 = false;
            			}
            			else {
HXDLIN( 852)				_hx_tmp3 = (( (int)(_g->tree->compare(_g->current->key,_g->rightest->key)) ) <= (int)0);
            			}
HXDLIN( 852)			if (!(_hx_tmp3)) {
HXDLIN( 852)				_hx_tmp2 = null();
            			}
            			else {
HXDLIN( 852)				if (hx::IsNotNull( _g->current->right )) {
HXDLIN( 852)					 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _node = _g->current->right;
HXDLIN( 852)					while(hx::IsNotNull( _node->left )){
HXDLIN( 852)						_node = _node->left;
            					}
HXDLIN( 852)					_hx_tmp2 = _node;
            				}
            				else {
HXDLIN( 852)					 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _next = null();
HXDLIN( 852)					 ::luxe::structural::BalancedBSTNode_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry _temp1 = _g->tree->root;
HXDLIN( 852)					while(hx::IsNotNull( _temp1 )){
HXDLIN( 852)						int _comp = ( (int)(_g->tree->compare(_g->current->key,_temp1->key)) );
HXDLIN( 852)						if ((_comp < (int)0)) {
HXDLIN( 852)							_next = _temp1;
HXDLIN( 852)							_temp1 = _temp1->left;
            						}
            						else {
HXDLIN( 852)							if ((_comp > (int)0)) {
HXDLIN( 852)								_temp1 = _temp1->right;
            							}
            							else {
HXDLIN( 852)								_g->current = _next;
HXDLIN( 852)								goto _hx_goto_39;
            							}
            						}
            					}
            					_hx_goto_39:;
HXDLIN( 852)					_hx_tmp2 = _next;
            				}
            			}
HXDLIN( 852)			_g->current = _hx_tmp2;
HXDLIN( 852)			 ::phoenix::geometry::Geometry geom = _temp->value;
            		}
            		_hx_goto_37:;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Batcher_obj,list_geometry,(void))

int Batcher_obj::set_show_stats(int _value){
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_858_set_show_stats)
HXLINE( 859)		if ((_value == (int)0)) {
HXLINE( 860)			this->renderer->stats->batchers--;
            		}
            		else {
HXLINE( 862)			this->renderer->stats->batchers++;
            		}
HXLINE( 864)		return (this->show_stats = _value);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Batcher_obj,set_show_stats,return )

int Batcher_obj::_sequence_key;

::Array< ::Dynamic> Batcher_obj::all;

int Batcher_obj::vert_attribute;

int Batcher_obj::tcoord_attribute;

int Batcher_obj::color_attribute;

int Batcher_obj::normal_attribute;


hx::ObjectPtr< Batcher_obj > Batcher_obj::__new( ::phoenix::Renderer _r,::String __o__name, ::Dynamic __o__max_verts) {
	hx::ObjectPtr< Batcher_obj > __this = new Batcher_obj();
	__this->__construct(_r,__o__name,__o__max_verts);
	return __this;
}

hx::ObjectPtr< Batcher_obj > Batcher_obj::__alloc(hx::Ctx *_hx_ctx, ::phoenix::Renderer _r,::String __o__name, ::Dynamic __o__max_verts) {
	Batcher_obj *__this = (Batcher_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Batcher_obj), true, "phoenix.Batcher"));
	*(void **)__this = Batcher_obj::_hx_vtable;
	__this->__construct(_r,__o__name,__o__max_verts);
	return __this;
}

Batcher_obj::Batcher_obj()
{
}

void Batcher_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Batcher);
	HX_MARK_MEMBER_NAME(id,"id");
	HX_MARK_MEMBER_NAME(enabled,"enabled");
	HX_MARK_MEMBER_NAME(layer,"layer");
	HX_MARK_MEMBER_NAME(geometry,"geometry");
	HX_MARK_MEMBER_NAME(emitter,"emitter");
	HX_MARK_MEMBER_NAME(tree_changed,"tree_changed");
	HX_MARK_MEMBER_NAME(pos_list,"pos_list");
	HX_MARK_MEMBER_NAME(tcoord_list,"tcoord_list");
	HX_MARK_MEMBER_NAME(color_list,"color_list");
	HX_MARK_MEMBER_NAME(normal_list,"normal_list");
	HX_MARK_MEMBER_NAME(max_verts,"max_verts");
	HX_MARK_MEMBER_NAME(max_floats,"max_floats");
	HX_MARK_MEMBER_NAME(vert_count,"vert_count");
	HX_MARK_MEMBER_NAME(renderer,"renderer");
	HX_MARK_MEMBER_NAME(view,"view");
	HX_MARK_MEMBER_NAME(shader,"shader");
	HX_MARK_MEMBER_NAME(draw_calls,"draw_calls");
	HX_MARK_MEMBER_NAME(dynamic_batched_count,"dynamic_batched_count");
	HX_MARK_MEMBER_NAME(static_batched_count,"static_batched_count");
	HX_MARK_MEMBER_NAME(visible_count,"visible_count");
	HX_MARK_MEMBER_NAME(log,"log");
	HX_MARK_MEMBER_NAME(name,"name");
	HX_MARK_MEMBER_NAME(show_stats,"show_stats");
	HX_MARK_MEMBER_NAME(sequence,"sequence");
	HX_MARK_MEMBER_NAME(pos_floats,"pos_floats");
	HX_MARK_MEMBER_NAME(tcoord_floats,"tcoord_floats");
	HX_MARK_MEMBER_NAME(color_floats,"color_floats");
	HX_MARK_MEMBER_NAME(normal_floats,"normal_floats");
	HX_MARK_MEMBER_NAME(state,"state");
	HX_MARK_MEMBER_NAME(_dropped,"_dropped");
	HX_MARK_END_CLASS();
}

void Batcher_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(id,"id");
	HX_VISIT_MEMBER_NAME(enabled,"enabled");
	HX_VISIT_MEMBER_NAME(layer,"layer");
	HX_VISIT_MEMBER_NAME(geometry,"geometry");
	HX_VISIT_MEMBER_NAME(emitter,"emitter");
	HX_VISIT_MEMBER_NAME(tree_changed,"tree_changed");
	HX_VISIT_MEMBER_NAME(pos_list,"pos_list");
	HX_VISIT_MEMBER_NAME(tcoord_list,"tcoord_list");
	HX_VISIT_MEMBER_NAME(color_list,"color_list");
	HX_VISIT_MEMBER_NAME(normal_list,"normal_list");
	HX_VISIT_MEMBER_NAME(max_verts,"max_verts");
	HX_VISIT_MEMBER_NAME(max_floats,"max_floats");
	HX_VISIT_MEMBER_NAME(vert_count,"vert_count");
	HX_VISIT_MEMBER_NAME(renderer,"renderer");
	HX_VISIT_MEMBER_NAME(view,"view");
	HX_VISIT_MEMBER_NAME(shader,"shader");
	HX_VISIT_MEMBER_NAME(draw_calls,"draw_calls");
	HX_VISIT_MEMBER_NAME(dynamic_batched_count,"dynamic_batched_count");
	HX_VISIT_MEMBER_NAME(static_batched_count,"static_batched_count");
	HX_VISIT_MEMBER_NAME(visible_count,"visible_count");
	HX_VISIT_MEMBER_NAME(log,"log");
	HX_VISIT_MEMBER_NAME(name,"name");
	HX_VISIT_MEMBER_NAME(show_stats,"show_stats");
	HX_VISIT_MEMBER_NAME(sequence,"sequence");
	HX_VISIT_MEMBER_NAME(pos_floats,"pos_floats");
	HX_VISIT_MEMBER_NAME(tcoord_floats,"tcoord_floats");
	HX_VISIT_MEMBER_NAME(color_floats,"color_floats");
	HX_VISIT_MEMBER_NAME(normal_floats,"normal_floats");
	HX_VISIT_MEMBER_NAME(state,"state");
	HX_VISIT_MEMBER_NAME(_dropped,"_dropped");
}

hx::Val Batcher_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"id") ) { return hx::Val( id ); }
		if (HX_FIELD_EQ(inName,"on") ) { return hx::Val( on_dyn() ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"log") ) { return hx::Val( log ); }
		if (HX_FIELD_EQ(inName,"off") ) { return hx::Val( off_dyn() ); }
		if (HX_FIELD_EQ(inName,"add") ) { return hx::Val( add_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"view") ) { return hx::Val( view ); }
		if (HX_FIELD_EQ(inName,"name") ) { return hx::Val( name ); }
		if (HX_FIELD_EQ(inName,"draw") ) { return hx::Val( draw_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"layer") ) { return hx::Val( layer ); }
		if (HX_FIELD_EQ(inName,"empty") ) { return hx::Val( empty_dyn() ); }
		if (HX_FIELD_EQ(inName,"state") ) { return hx::Val( state ); }
		if (HX_FIELD_EQ(inName,"batch") ) { return hx::Val( batch_dyn() ); }
		if (HX_FIELD_EQ(inName,"prune") ) { return hx::Val( prune_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"shader") ) { return hx::Val( shader ); }
		if (HX_FIELD_EQ(inName,"remove") ) { return hx::Val( remove_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"enabled") ) { return hx::Val( enabled ); }
		if (HX_FIELD_EQ(inName,"emitter") ) { return hx::Val( emitter ); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return hx::Val( destroy_dyn() ); }
		if (HX_FIELD_EQ(inName,"compare") ) { return hx::Val( compare_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"geometry") ) { return hx::Val( geometry ); }
		if (HX_FIELD_EQ(inName,"pos_list") ) { return hx::Val( pos_list ); }
		if (HX_FIELD_EQ(inName,"renderer") ) { return hx::Val( renderer ); }
		if (HX_FIELD_EQ(inName,"sequence") ) { return hx::Val( sequence ); }
		if (HX_FIELD_EQ(inName,"_dropped") ) { return hx::Val( _dropped ); }
		if (HX_FIELD_EQ(inName,"toString") ) { return hx::Val( toString_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"max_verts") ) { return hx::Val( max_verts ); }
		if (HX_FIELD_EQ(inName,"set_layer") ) { return hx::Val( set_layer_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"color_list") ) { return hx::Val( color_list ); }
		if (HX_FIELD_EQ(inName,"max_floats") ) { return hx::Val( max_floats ); }
		if (HX_FIELD_EQ(inName,"vert_count") ) { return hx::Val( vert_count ); }
		if (HX_FIELD_EQ(inName,"draw_calls") ) { return hx::Val( draw_calls ); }
		if (HX_FIELD_EQ(inName,"show_stats") ) { return hx::Val( show_stats ); }
		if (HX_FIELD_EQ(inName,"pos_floats") ) { return hx::Val( pos_floats ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"tcoord_list") ) { return hx::Val( tcoord_list ); }
		if (HX_FIELD_EQ(inName,"normal_list") ) { return hx::Val( normal_list ); }
		if (HX_FIELD_EQ(inName,"update_view") ) { return hx::Val( update_view_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"tree_changed") ) { return hx::Val( tree_changed ); }
		if (HX_FIELD_EQ(inName,"color_floats") ) { return hx::Val( color_floats ); }
		if (HX_FIELD_EQ(inName,"compare_rule") ) { return hx::Val( compare_rule_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"visible_count") ) { return hx::Val( visible_count ); }
		if (HX_FIELD_EQ(inName,"tcoord_floats") ) { return hx::Val( tcoord_floats ); }
		if (HX_FIELD_EQ(inName,"normal_floats") ) { return hx::Val( normal_floats ); }
		if (HX_FIELD_EQ(inName,"list_geometry") ) { return hx::Val( list_geometry_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"submit_buffers") ) { return hx::Val( submit_buffers_dyn() ); }
		if (HX_FIELD_EQ(inName,"geometry_batch") ) { return hx::Val( geometry_batch_dyn() ); }
		if (HX_FIELD_EQ(inName,"set_show_stats") ) { return hx::Val( set_show_stats_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"submit_geometry") ) { return hx::Val( submit_geometry_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"geometry_compare") ) { return hx::Val( geometry_compare_dyn() ); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"static_batched_count") ) { return hx::Val( static_batched_count ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"dynamic_batched_count") ) { return hx::Val( dynamic_batched_count ); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"apply_default_uniforms") ) { return hx::Val( apply_default_uniforms_dyn() ); }
		if (HX_FIELD_EQ(inName,"submit_static_geometry") ) { return hx::Val( submit_static_geometry_dyn() ); }
		if (HX_FIELD_EQ(inName,"compare_rule_to_string") ) { return hx::Val( compare_rule_to_string_dyn() ); }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"submit_current_vertex_list") ) { return hx::Val( submit_current_vertex_list_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Batcher_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"all") ) { outValue = ( all ); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"_sequence_key") ) { outValue = ( _sequence_key ); return true; }
	}
	return false;
}

hx::Val Batcher_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 2:
		if (HX_FIELD_EQ(inName,"id") ) { id=inValue.Cast< ::String >(); return inValue; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"log") ) { log=inValue.Cast< bool >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"view") ) { view=inValue.Cast<  ::phoenix::Camera >(); return inValue; }
		if (HX_FIELD_EQ(inName,"name") ) { name=inValue.Cast< ::String >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"layer") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_layer(inValue.Cast< int >()) );layer=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"state") ) { state=inValue.Cast<  ::phoenix::BatchState >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"shader") ) { shader=inValue.Cast<  ::phoenix::Shader >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"enabled") ) { enabled=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"emitter") ) { emitter=inValue.Cast<  ::luxe::Emitter >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"geometry") ) { geometry=inValue.Cast<  ::luxe::structural::BalancedBST_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pos_list") ) { pos_list=inValue.Cast<  ::snow::api::buffers::ArrayBufferView >(); return inValue; }
		if (HX_FIELD_EQ(inName,"renderer") ) { renderer=inValue.Cast<  ::phoenix::Renderer >(); return inValue; }
		if (HX_FIELD_EQ(inName,"sequence") ) { sequence=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"_dropped") ) { _dropped=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"max_verts") ) { max_verts=inValue.Cast< int >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"color_list") ) { color_list=inValue.Cast<  ::snow::api::buffers::ArrayBufferView >(); return inValue; }
		if (HX_FIELD_EQ(inName,"max_floats") ) { max_floats=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"vert_count") ) { vert_count=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"draw_calls") ) { draw_calls=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"show_stats") ) { if (inCallProp == hx::paccAlways) return hx::Val( set_show_stats(inValue.Cast< int >()) );show_stats=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"pos_floats") ) { pos_floats=inValue.Cast< int >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"tcoord_list") ) { tcoord_list=inValue.Cast<  ::snow::api::buffers::ArrayBufferView >(); return inValue; }
		if (HX_FIELD_EQ(inName,"normal_list") ) { normal_list=inValue.Cast<  ::snow::api::buffers::ArrayBufferView >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"tree_changed") ) { tree_changed=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"color_floats") ) { color_floats=inValue.Cast< int >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"visible_count") ) { visible_count=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"tcoord_floats") ) { tcoord_floats=inValue.Cast< int >(); return inValue; }
		if (HX_FIELD_EQ(inName,"normal_floats") ) { normal_floats=inValue.Cast< int >(); return inValue; }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"static_batched_count") ) { static_batched_count=inValue.Cast< int >(); return inValue; }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"dynamic_batched_count") ) { dynamic_batched_count=inValue.Cast< int >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool Batcher_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"all") ) { all=ioValue.Cast< ::Array< ::Dynamic> >(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"_sequence_key") ) { _sequence_key=ioValue.Cast< int >(); return true; }
	}
	return false;
}

void Batcher_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("id","\xdb","\x5b","\x00","\x00"));
	outFields->push(HX_HCSTRING("enabled","\x81","\x04","\x31","\x7e"));
	outFields->push(HX_HCSTRING("layer","\xd1","\x81","\xc0","\x6f"));
	outFields->push(HX_HCSTRING("geometry","\xb2","\x02","\xa9","\xd2"));
	outFields->push(HX_HCSTRING("emitter","\x6e","\x35","\xf6","\xbe"));
	outFields->push(HX_HCSTRING("tree_changed","\xd3","\x31","\xee","\x4a"));
	outFields->push(HX_HCSTRING("pos_list","\x29","\x22","\xaf","\x03"));
	outFields->push(HX_HCSTRING("tcoord_list","\xdc","\x26","\x24","\x80"));
	outFields->push(HX_HCSTRING("color_list","\xfa","\xdf","\x02","\x8c"));
	outFields->push(HX_HCSTRING("normal_list","\xb6","\x98","\xc8","\xf4"));
	outFields->push(HX_HCSTRING("max_verts","\x87","\xcb","\x3f","\x2b"));
	outFields->push(HX_HCSTRING("max_floats","\xd2","\x86","\xa0","\x4c"));
	outFields->push(HX_HCSTRING("vert_count","\x81","\xdb","\x0c","\x72"));
	outFields->push(HX_HCSTRING("renderer","\x43","\xc5","\xdb","\xb2"));
	outFields->push(HX_HCSTRING("view","\x65","\x32","\x4f","\x4e"));
	outFields->push(HX_HCSTRING("shader","\x25","\xbf","\x20","\x1d"));
	outFields->push(HX_HCSTRING("draw_calls","\x5a","\xc0","\x31","\x4a"));
	outFields->push(HX_HCSTRING("dynamic_batched_count","\x69","\x37","\xa8","\x66"));
	outFields->push(HX_HCSTRING("static_batched_count","\xd8","\x88","\x51","\x4c"));
	outFields->push(HX_HCSTRING("visible_count","\x02","\xe6","\xa7","\x70"));
	outFields->push(HX_HCSTRING("log","\x84","\x54","\x52","\x00"));
	outFields->push(HX_HCSTRING("name","\x4b","\x72","\xff","\x48"));
	outFields->push(HX_HCSTRING("show_stats","\x1d","\xee","\xd2","\xb4"));
	outFields->push(HX_HCSTRING("sequence","\x41","\x1e","\xed","\xe8"));
	outFields->push(HX_HCSTRING("pos_floats","\xe2","\x71","\xb7","\xf8"));
	outFields->push(HX_HCSTRING("tcoord_floats","\x55","\x49","\xfd","\x3f"));
	outFields->push(HX_HCSTRING("color_floats","\xf3","\x05","\xd3","\x0b"));
	outFields->push(HX_HCSTRING("normal_floats","\xaf","\x65","\x05","\x7c"));
	outFields->push(HX_HCSTRING("state","\x11","\x76","\x0b","\x84"));
	outFields->push(HX_HCSTRING("_dropped","\x81","\x7d","\xa1","\x40"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Batcher_obj_sMemberStorageInfo[] = {
	{hx::fsString,(int)offsetof(Batcher_obj,id),HX_HCSTRING("id","\xdb","\x5b","\x00","\x00")},
	{hx::fsBool,(int)offsetof(Batcher_obj,enabled),HX_HCSTRING("enabled","\x81","\x04","\x31","\x7e")},
	{hx::fsInt,(int)offsetof(Batcher_obj,layer),HX_HCSTRING("layer","\xd1","\x81","\xc0","\x6f")},
	{hx::fsObject /*::luxe::structural::BalancedBST_phoenix_geometry_GeometryKey_phoenix_geometry_Geometry*/ ,(int)offsetof(Batcher_obj,geometry),HX_HCSTRING("geometry","\xb2","\x02","\xa9","\xd2")},
	{hx::fsObject /*::luxe::Emitter*/ ,(int)offsetof(Batcher_obj,emitter),HX_HCSTRING("emitter","\x6e","\x35","\xf6","\xbe")},
	{hx::fsBool,(int)offsetof(Batcher_obj,tree_changed),HX_HCSTRING("tree_changed","\xd3","\x31","\xee","\x4a")},
	{hx::fsObject /*::snow::api::buffers::ArrayBufferView*/ ,(int)offsetof(Batcher_obj,pos_list),HX_HCSTRING("pos_list","\x29","\x22","\xaf","\x03")},
	{hx::fsObject /*::snow::api::buffers::ArrayBufferView*/ ,(int)offsetof(Batcher_obj,tcoord_list),HX_HCSTRING("tcoord_list","\xdc","\x26","\x24","\x80")},
	{hx::fsObject /*::snow::api::buffers::ArrayBufferView*/ ,(int)offsetof(Batcher_obj,color_list),HX_HCSTRING("color_list","\xfa","\xdf","\x02","\x8c")},
	{hx::fsObject /*::snow::api::buffers::ArrayBufferView*/ ,(int)offsetof(Batcher_obj,normal_list),HX_HCSTRING("normal_list","\xb6","\x98","\xc8","\xf4")},
	{hx::fsInt,(int)offsetof(Batcher_obj,max_verts),HX_HCSTRING("max_verts","\x87","\xcb","\x3f","\x2b")},
	{hx::fsInt,(int)offsetof(Batcher_obj,max_floats),HX_HCSTRING("max_floats","\xd2","\x86","\xa0","\x4c")},
	{hx::fsInt,(int)offsetof(Batcher_obj,vert_count),HX_HCSTRING("vert_count","\x81","\xdb","\x0c","\x72")},
	{hx::fsObject /*::phoenix::Renderer*/ ,(int)offsetof(Batcher_obj,renderer),HX_HCSTRING("renderer","\x43","\xc5","\xdb","\xb2")},
	{hx::fsObject /*::phoenix::Camera*/ ,(int)offsetof(Batcher_obj,view),HX_HCSTRING("view","\x65","\x32","\x4f","\x4e")},
	{hx::fsObject /*::phoenix::Shader*/ ,(int)offsetof(Batcher_obj,shader),HX_HCSTRING("shader","\x25","\xbf","\x20","\x1d")},
	{hx::fsInt,(int)offsetof(Batcher_obj,draw_calls),HX_HCSTRING("draw_calls","\x5a","\xc0","\x31","\x4a")},
	{hx::fsInt,(int)offsetof(Batcher_obj,dynamic_batched_count),HX_HCSTRING("dynamic_batched_count","\x69","\x37","\xa8","\x66")},
	{hx::fsInt,(int)offsetof(Batcher_obj,static_batched_count),HX_HCSTRING("static_batched_count","\xd8","\x88","\x51","\x4c")},
	{hx::fsInt,(int)offsetof(Batcher_obj,visible_count),HX_HCSTRING("visible_count","\x02","\xe6","\xa7","\x70")},
	{hx::fsBool,(int)offsetof(Batcher_obj,log),HX_HCSTRING("log","\x84","\x54","\x52","\x00")},
	{hx::fsString,(int)offsetof(Batcher_obj,name),HX_HCSTRING("name","\x4b","\x72","\xff","\x48")},
	{hx::fsInt,(int)offsetof(Batcher_obj,show_stats),HX_HCSTRING("show_stats","\x1d","\xee","\xd2","\xb4")},
	{hx::fsInt,(int)offsetof(Batcher_obj,sequence),HX_HCSTRING("sequence","\x41","\x1e","\xed","\xe8")},
	{hx::fsInt,(int)offsetof(Batcher_obj,pos_floats),HX_HCSTRING("pos_floats","\xe2","\x71","\xb7","\xf8")},
	{hx::fsInt,(int)offsetof(Batcher_obj,tcoord_floats),HX_HCSTRING("tcoord_floats","\x55","\x49","\xfd","\x3f")},
	{hx::fsInt,(int)offsetof(Batcher_obj,color_floats),HX_HCSTRING("color_floats","\xf3","\x05","\xd3","\x0b")},
	{hx::fsInt,(int)offsetof(Batcher_obj,normal_floats),HX_HCSTRING("normal_floats","\xaf","\x65","\x05","\x7c")},
	{hx::fsObject /*::phoenix::BatchState*/ ,(int)offsetof(Batcher_obj,state),HX_HCSTRING("state","\x11","\x76","\x0b","\x84")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Batcher_obj,_dropped),HX_HCSTRING("_dropped","\x81","\x7d","\xa1","\x40")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo Batcher_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &Batcher_obj::_sequence_key,HX_HCSTRING("_sequence_key","\x40","\x34","\x6b","\xf7")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(void *) &Batcher_obj::all,HX_HCSTRING("all","\x21","\xf9","\x49","\x00")},
	{hx::fsInt,(void *) &Batcher_obj::vert_attribute,HX_HCSTRING("vert_attribute","\xce","\x47","\x70","\x43")},
	{hx::fsInt,(void *) &Batcher_obj::tcoord_attribute,HX_HCSTRING("tcoord_attribute","\xde","\x9c","\x72","\x7b")},
	{hx::fsInt,(void *) &Batcher_obj::color_attribute,HX_HCSTRING("color_attribute","\x00","\x17","\x4a","\xaf")},
	{hx::fsInt,(void *) &Batcher_obj::normal_attribute,HX_HCSTRING("normal_attribute","\xc4","\x34","\xe1","\x31")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String Batcher_obj_sMemberFields[] = {
	HX_HCSTRING("id","\xdb","\x5b","\x00","\x00"),
	HX_HCSTRING("enabled","\x81","\x04","\x31","\x7e"),
	HX_HCSTRING("layer","\xd1","\x81","\xc0","\x6f"),
	HX_HCSTRING("geometry","\xb2","\x02","\xa9","\xd2"),
	HX_HCSTRING("emitter","\x6e","\x35","\xf6","\xbe"),
	HX_HCSTRING("tree_changed","\xd3","\x31","\xee","\x4a"),
	HX_HCSTRING("pos_list","\x29","\x22","\xaf","\x03"),
	HX_HCSTRING("tcoord_list","\xdc","\x26","\x24","\x80"),
	HX_HCSTRING("color_list","\xfa","\xdf","\x02","\x8c"),
	HX_HCSTRING("normal_list","\xb6","\x98","\xc8","\xf4"),
	HX_HCSTRING("max_verts","\x87","\xcb","\x3f","\x2b"),
	HX_HCSTRING("max_floats","\xd2","\x86","\xa0","\x4c"),
	HX_HCSTRING("vert_count","\x81","\xdb","\x0c","\x72"),
	HX_HCSTRING("renderer","\x43","\xc5","\xdb","\xb2"),
	HX_HCSTRING("view","\x65","\x32","\x4f","\x4e"),
	HX_HCSTRING("shader","\x25","\xbf","\x20","\x1d"),
	HX_HCSTRING("draw_calls","\x5a","\xc0","\x31","\x4a"),
	HX_HCSTRING("dynamic_batched_count","\x69","\x37","\xa8","\x66"),
	HX_HCSTRING("static_batched_count","\xd8","\x88","\x51","\x4c"),
	HX_HCSTRING("visible_count","\x02","\xe6","\xa7","\x70"),
	HX_HCSTRING("log","\x84","\x54","\x52","\x00"),
	HX_HCSTRING("name","\x4b","\x72","\xff","\x48"),
	HX_HCSTRING("show_stats","\x1d","\xee","\xd2","\xb4"),
	HX_HCSTRING("sequence","\x41","\x1e","\xed","\xe8"),
	HX_HCSTRING("pos_floats","\xe2","\x71","\xb7","\xf8"),
	HX_HCSTRING("tcoord_floats","\x55","\x49","\xfd","\x3f"),
	HX_HCSTRING("color_floats","\xf3","\x05","\xd3","\x0b"),
	HX_HCSTRING("normal_floats","\xaf","\x65","\x05","\x7c"),
	HX_HCSTRING("on","\x1f","\x61","\x00","\x00"),
	HX_HCSTRING("off","\x6f","\x93","\x54","\x00"),
	HX_HCSTRING("add","\x21","\xf2","\x49","\x00"),
	HX_HCSTRING("empty","\x8d","\x3a","\xda","\x6f"),
	HX_HCSTRING("destroy","\xfa","\x2c","\x86","\x24"),
	HX_HCSTRING("remove","\x44","\x9c","\x88","\x04"),
	HX_HCSTRING("state","\x11","\x76","\x0b","\x84"),
	HX_HCSTRING("_dropped","\x81","\x7d","\xa1","\x40"),
	HX_HCSTRING("batch","\xba","\xe7","\xba","\xad"),
	HX_HCSTRING("prune","\x2a","\x73","\x94","\xc8"),
	HX_HCSTRING("draw","\x04","\x2c","\x70","\x42"),
	HX_HCSTRING("update_view","\x9b","\x47","\xcb","\x53"),
	HX_HCSTRING("apply_default_uniforms","\x6e","\xb8","\xfa","\x3e"),
	HX_HCSTRING("submit_geometry","\xf9","\xde","\xa8","\xaf"),
	HX_HCSTRING("submit_buffers","\x0c","\x2d","\x09","\xbe"),
	HX_HCSTRING("submit_static_geometry","\x3c","\x62","\x76","\x36"),
	HX_HCSTRING("submit_current_vertex_list","\x2c","\xd9","\x42","\xde"),
	HX_HCSTRING("geometry_batch","\x2d","\x43","\xe5","\x75"),
	HX_HCSTRING("set_layer","\x34","\xca","\xba","\x96"),
	HX_HCSTRING("toString","\xac","\xd0","\x6e","\x38"),
	HX_HCSTRING("compare","\xa5","\x18","\x69","\x83"),
	HX_HCSTRING("compare_rule_to_string","\xac","\x83","\x34","\x4e"),
	HX_HCSTRING("compare_rule","\x16","\x06","\x47","\x08"),
	HX_HCSTRING("geometry_compare","\xd8","\x76","\x77","\x6f"),
	HX_HCSTRING("list_geometry","\xf3","\x61","\xa0","\x84"),
	HX_HCSTRING("set_show_stats","\xda","\x5e","\xe8","\x4a"),
	::String(null()) };

static void Batcher_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Batcher_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Batcher_obj::_sequence_key,"_sequence_key");
	HX_MARK_MEMBER_NAME(Batcher_obj::all,"all");
	HX_MARK_MEMBER_NAME(Batcher_obj::vert_attribute,"vert_attribute");
	HX_MARK_MEMBER_NAME(Batcher_obj::tcoord_attribute,"tcoord_attribute");
	HX_MARK_MEMBER_NAME(Batcher_obj::color_attribute,"color_attribute");
	HX_MARK_MEMBER_NAME(Batcher_obj::normal_attribute,"normal_attribute");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Batcher_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Batcher_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Batcher_obj::_sequence_key,"_sequence_key");
	HX_VISIT_MEMBER_NAME(Batcher_obj::all,"all");
	HX_VISIT_MEMBER_NAME(Batcher_obj::vert_attribute,"vert_attribute");
	HX_VISIT_MEMBER_NAME(Batcher_obj::tcoord_attribute,"tcoord_attribute");
	HX_VISIT_MEMBER_NAME(Batcher_obj::color_attribute,"color_attribute");
	HX_VISIT_MEMBER_NAME(Batcher_obj::normal_attribute,"normal_attribute");
};

#endif

hx::Class Batcher_obj::__mClass;

static ::String Batcher_obj_sStaticFields[] = {
	HX_HCSTRING("_sequence_key","\x40","\x34","\x6b","\xf7"),
	HX_HCSTRING("all","\x21","\xf9","\x49","\x00"),
	HX_HCSTRING("vert_attribute","\xce","\x47","\x70","\x43"),
	HX_HCSTRING("tcoord_attribute","\xde","\x9c","\x72","\x7b"),
	HX_HCSTRING("color_attribute","\x00","\x17","\x4a","\xaf"),
	HX_HCSTRING("normal_attribute","\xc4","\x34","\xe1","\x31"),
	::String(null())
};

void Batcher_obj::__register()
{
	hx::Object *dummy = new Batcher_obj;
	Batcher_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("phoenix.Batcher","\xa8","\xb2","\x34","\x67");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Batcher_obj::__GetStatic;
	__mClass->mSetStaticField = &Batcher_obj::__SetStatic;
	__mClass->mMarkFunc = Batcher_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Batcher_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Batcher_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Batcher_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Batcher_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Batcher_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Batcher_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Batcher_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_53_boot)
HXDLIN(  53)		_sequence_key = (int)-1;
            	}
{
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_62_boot)
HXDLIN(  62)		all = ::Array_obj< ::Dynamic>::__new(0);
            	}
{
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_867_boot)
HXDLIN( 867)		vert_attribute = (int)0;
            	}
{
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_868_boot)
HXDLIN( 868)		tcoord_attribute = (int)1;
            	}
{
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_869_boot)
HXDLIN( 869)		color_attribute = (int)2;
            	}
{
            	HX_STACKFRAME(&_hx_pos_8831ea6108d72700_870_boot)
HXDLIN( 870)		normal_attribute = (int)3;
            	}
}

} // end namespace phoenix
